{
	"Ilz Apprentice": {
		name: "Ilz Apprentice",
		type: "creature",
		cost: 2,
		loyalty_cost: 0,
		school: SCROLLS,
		creature: {
			tags: ['Human'],
			attack: 1,
			life: 2,
			move: 2,
			image_num: 9
		}
	},

	"Acolyte": {
		name: "Acolyte",
		type: "creature",
		cost: 2,
		loyalty_cost: 1,
		school: SCROLLS,
		rules: "When you cast Acolyte, draw a card.",
		on_play: "def(class game game, class message.play_card info) ->commands [
		  me.do_summons(game, info),
		  game.players[game.current_player].draw_cards(game, 1)
		]",
		creature: {
			tags: ['Human'],
			attack: 1,
			life: 2,
			move: 2,
			image_num: 20
		}
	},

	"Mystic Scholar": {
		name: "Mystic Scholar",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: SCROLLS,
		creature: {
			activated_abilities: [
				{
					name: 'Consume',
					cost: 1,
					school: SCROLLS,
					rules: "Sacrifice this creature, draw 2 cards.",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
						set(creature.destroyed, true),
						game.players[creature.controller].draw_cards(game, 2)
					]"
				}
			],
			tags: ['Human'],
			attack: 1,
			life: 2,
			move: 2,
			image_num: 20
		}
	},

	"Golem": {
		name: "Golem",
		type: "creature",
		cost: 4,
		loyalty_cost: 2,
		school: SCROLLS,
		creature: {
			activated_abilities: [
				{
					name: 'Rebuild',
					cost: 2,
					school: SCROLLS,
					rules: "Remove all wounds from this creature.",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
						set(creature.wounds, 0)
					]"
				}
			],
			tags: ['Construct'],
			attack: 4,
			life: 4,
			move: 1,
			image_num: 61
		}
	},

	"Fireball": {
		name: "Fireball",
		type: "spell",
		school: SCROLLS,
		cost: 3,
		loyalty_cost: 3,
		rules: "Add three wounds to target creature.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		  add(creature.wounds, 3)
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc_or_die(info.targets[0])"
	},

	"Blink": {
		name: "Blink",
		type: "spell",
		school: SCROLLS,
		cost: 2,
		loyalty_cost: 3,
		is_response: true,
		
		rules: "Move target creature to the same column in target lane.",

		possible_targets: "
		 def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [],
			 [creature.loc | creature <- game.creatures, creature.is_valid_target(game, nplayer, me), not creature.is_building],
			 if(size(targets) = 1,
				[[row, targets[0][1]] | row <- range(game.rows), game.creature_at_loc([row, targets[0][1]]) = null]
			 ))",
		on_play: "def(class game game, class message.play_card info) ->commands
		  set(game.creature_at_loc_or_die(info.targets[0]).loc, info.targets[1])"
	},

	"Astral Walk": {
		name: "Astral Walk",
		type: "spell",
		school: SCROLLS,
		cost: 2,
		loyalty_cost: 3,
		is_response: true,
		
		rules: "Move target creature up to two tiles forwards or backwards.",

		possible_targets: "
		  def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [],
			 [creature.loc | creature <- game.creatures, creature.is_valid_target(game, nplayer, me), not creature.is_building],
			 if(size(targets) = 1,
			   filter([[targets[0][0], targets[0][1]+col] | col <- [-2,-1,1,2]],
				      game.is_loc_on_board(value) and
					  game.creature_at_loc(value) = null)
			 ))",
		on_play: "def(class game game, class message.play_card info) ->commands
		  set(game.creature_at_loc_or_die(info.targets[0]).loc, info.targets[1])"
	},

	"Library": {
		name: "Library",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: SCROLLS,
		creature: {
			tags: ["Library"],
			life: 3,
			is_construct: true,
			image_num: 8,
			activated_abilities: [
				{
					name: 'Study',
					cost: 1,
					loyalty_cost: 0,
					exhausts_creature: true,
					school: SCROLLS,
					rules: "Draw a card.",
					on_play: "
					 def(class game game, class creature creature, class message.play_ability info) ->commands [
						game.players[creature.controller].draw_cards(game, 1)
					]"
				}
			]
		}
	},
	
	"Polymorph": {
		name: "Polymorph",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: SCROLLS,
		is_response: true,
		rules: "Transform target creature into a Giant Frog.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands target.transform(game, lib.citadel.create_creature('Giant Frog'))
			asserting size(info.targets) = 1
			where target = game.creature_at_loc_or_die(info.targets[0])
		",
	},

	"Giant Frog": {
		name: "Giant Frog",
		type: "creature",
		cost: 2,
		loyalty_cost: 1,
		school: SCROLLS,
		creature: {
			tags: ['Frog'],
			attack: 3,
			life: 2,
			move: 2,
			image_num: 73
		}
	},

	"Charge!": {
		name: "Charge!",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: SCROLLS,
		rules: "Target creature gains Charge.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands add(game.creature_at_loc_or_die(info.targets[0]).abilities, ['Charge'])
					asserting size(info.targets) = 1",
	},
	
	"Council of Seven": {
		name: "Council of Seven",
		type: "spell",
		school: SCROLLS,
		cost: 4,
		loyalty_cost: 3,
		rules: "Discard your hand, draw seven cards.",
		on_play: "def(class game game, class message.play_card info) ->commands [
			game.player_obj.discard_cards(range(size(game.player_obj.hand))),
			game.player_obj.draw_cards(game, 7)
		]",
	},
	
	"Confusion": {
		name: "Confusion",
		type: "spell",
		school: SCROLLS,
		is_response: true,
		cost: 3,
		loyalty_cost: 3,
		rules: "You gain control of target creature this turn. This creature cannot enter the endzone this turn.",
		possible_targets: "enemy_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		 [set(creature.controller, game.current_player_index),
			set(creature.can_enter_endzone, false),
			creature.add_triggered_ability_until_end_of_turn({
				on_end_turn: 'def(class creature creature, class game game) ->commands [set(creature.controller, args.original_controller), 
					set(creature.can_enter_endzone, args.original_enter_endzone)]',
				args: { original_controller: creature.controller, original_enter_endzone: creature.can_enter_endzone }
			})]
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc_or_die(info.targets[0])",
	},
	
	"Humboldt's Curse": {
		name: "Humboldt's Curse",
		type: "spell",
		school: SCROLLS,
		is_response: true,
		cost: 2,
		loyalty_cost: 1,
		rules: "Target creature gets &-;&1;&move;.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play_on_creature: "def(class game game, class creature target) ->commands [add(target.move, -1)]",
	},
	
	"Humboldt's Trick": {
		name: "Humboldt's Trick",
		type: "spell",
		school: SCROLLS,
		is_response: true,
		cost: 3,
		loyalty_cost: 2,
		rules: "Target creature gets &+;&1;&move; and &-;&2;&attack;.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands [add(creature.move, 1), add(creature.attack, -2)]
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc_or_die(info.targets[0])",
	},
	
	"Rolland's Little Helper": {
		name:  "Rolland's Little Helper",
		type: "creature",
		school: SCROLLS,
		cost: 3,
		loyalty_cost: 2,
		creature: {
			activated_abilities: [
				{
					name: 'Sacrifice',
					school: SCROLLS,
					is_response: true,
					cost: 2,
					rules: "Sacrifice this creature, draw 3 cards.",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
						game.player_obj.draw_cards(game,3), 
						set(creature.destroyed, true)]",
				}
			],
			tags: ['Arcane'],
			attack: 3,
			life: 3,
			move: 2,
			image_num: 49
		}
		
	},

	"Endless Studies": {
		name: "Endless Studies",
		type: "spell",
		school: SCROLLS,
		cost: 0,
		loyalty_cost: 2,
		rules: "Draw a card.",
		on_play: "def(class game game, class message.play_card info) ->commands
		  game.players[game.current_player].draw_cards(game, 1)",
	},

	"Divine the Future": {
		name: "Divine the Future",
		type: "spell",
		school: SCROLLS,
		cost: 2,
		loyalty_cost: 3,
		rules: "Look at the top 5 cards of your deck, discard them or put them back.",
		on_play: "def(class game game, class message.play_card info) ->commands if(info.choices, [
			if(info.choices[0] = 1, [
				add(game.player_obj.discard_pile, game.player_obj.deck[:5]),
				set(game.player_obj.deck, game.player_obj.deck[5:]),
			])
		],
		 if(game.player_obj.no_cards_to_draw, null,
		 [
		 	set(game.player_obj.deck, cards.deck),
		 	set(game.player_obj.discard_pile, cards.discard_pile),
			game.set_current_choice({
				card: me,
				info: info,
				text: 'Choose whether to discard the cards',
				options:
				map(cards.deck[:depth],
				{
					type: 'card',
					card: value,
					value: null,
				}) +
				
				[
				{
					type: 'button',
					value: 0,
					text: 'Keep',
				},
				{
					type: 'button',
					value: 1,
					text: 'Discard',
				}
				]
			}),
		 ] where cards = game.player_obj.guarantee_deck_size(game, depth))
		) where depth = 5
		",
	},

	"Tactical Blunder": {
		name: "Tactical Blunder",
		type: "spell",
		school: SCROLLS,
		cost: 1,
		loyalty_cost: 3,
		is_response: true,
		rules: "Change the summoning location of target creature currently being summoned.",
		possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets != [], null, 
			 if(summoning and summoning.card, summoning.card.possible_targets(game, summoning.player_index, []), [])
			 where summoning = class message.play_card|null <-
			    find(reverse(game.stack), is_creature(value)))
		     where is_creature = overload(
			 	def(class message.play_card info) ->bool info.card.type = 'creature' and size(info.targets) = 1
				    asserting info.card,
				def(any info) ->bool false
			 )",
		on_play: "def(class game game, class message.play_card info) ->commands
		  set(summoning.targets, info.targets)
			 where summoning = class message.play_card <-
			   find(reverse(game.stack), is_creature(value))
		     where is_creature = overload(
			 	def(class message.play_card info) ->bool info.card.type = 'creature' and size(info.targets) = 1
				   asserting info.card,
				def(any info) ->bool false
			 )",

	},

	"Scry": {
		name: "Scry",
		type: "spell",
		school: SCROLLS,
		cost: 0,
		loyalty_cost: 4,
		rules: "Look at the top 5 cards of your deck, put one of them into your hand and the rest on the bottom of your deck.",
		on_play: "def(class game game, class message.play_card info) ->commands if(info.choices,
		 [
		   set(game.player_obj.deck,
		       filter(game.player_obj.deck, index != info.choices[0])),
		   add(game.player_obj.hand,
		       [game.player_obj.deck[info.choices[0]]]),
		 ],
		 if(size(game.player_obj.deck) + size(game.player_obj.discard_pile) = 0, null,
		 [
		 	set(game.player_obj.deck, new_deck),
		 	set(game.player_obj.discard_pile, new_discard_pile),
			game.set_current_choice({
				card: me,
				info: info,
				text: 'Choose a card to put in your hand',
				options: map(new_deck[:min(size(new_deck), depth)],
				   {
						type: 'card',
						card: value,
						value: index,
				   }),
			}),
		 ]
		where new_deck = if(size(game.player_obj.deck) < depth, game.player_obj.deck + shuffle(game.player_obj.discard_pile), game.player_obj.deck)
		where new_discard_pile = if(size(game.player_obj.deck) < depth, game.player_obj.discard_pile, [])
	  )) where depth = 5",
	},
	
	"Flesh Golem": {
		name: "Flesh Golem",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: SCROLLS,
		creature: {
			activated_abilities: [
				{
					name: 'Re-make',
					cost: 2,
					school: [1,4],
					is_response: false,
					rules: "If Flesh Golem is wounded, sacrifice it, summon a copy of it in its place, but with &+;&1;&attack; and &+;&1;&life;.",
					is_usable: "def(class game game, class creature creature) ->bool creature.wounds > 0 and ('Exhausted' not in creature.status_effects)",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
						set(creature.destroyed, true),
						game.summon_creature(construct('creature', {
							name: 'Flesh Golem',
							tags: ['Construct', 'Golem'],
							school: SCROLLS,
							attack: creature.attack + 1,
							controller: creature.controller,
							life: creature.life + 1,
							move: 1,
							wounds: 0,
							initiative: 20,
							image_num: 75,
							loc: creature.loc,
							activated_abilities: creature.activated_abilities,
							}))
					]"
				}
			],
			tags: ['Construct', 'Golem'],
			attack: 4,
			life: 4,
			move: 1,
			image_num: 75
		}
	},

	"Read Mind": {
		name: "Read Mind",
		type: "spell",
		cost: 0,
		loyalty_cost: 3,
		school: SCROLLS,
		rules: "Look at your opponent's hand.\nYou gain +&1;&mana;.",

		on_play: "def(class game game, class message.play_card info) ->commands if(info.choices, null, [
		add(game.player_obj.resources, 1),
		if(game.opponent_obj.hand, game.set_current_choice({
			card: me,
			info: info,
			text: q(Look at your opponent's hand. Click a card when they're done.),
			options: map(game.opponent_obj.hand, {
				type: 'card',
				card: value,
				value: index,
			})
		}))])",
	},
	
	"Tower of Levitation": {
		name: "Tower of Levitation",
		type: "creature",
		cost: 3,
		loyalty_cost: 4,
		school: 4,
		rules: "Creatures you control in this lane have the ability: 'Levitate: This creature gains Flying this turn.'",
		creature: {
			tags: ["Tower"],
			life: 3,
			is_construct: true,
			image_num: 5,
			static_ability_effect: "if(creature != target and creature.controller = target.controller and creature.loc[0] = target.loc[0], 
				target.add_ability_static_duration({
					name: 'Levitate',
					cost: 2,
					school: 4,					
					is_response: true,
					rules: 'Gain Flying until the end of the turn',
					is_usable: 'def(class game game, class creature creature) ->bool not (q(Flying) in creature.abilities)',
					on_play: 'def(class game game, class creature creature, message.play_ability info) ->commands creature.add_ability_until_end_of_turn(q(Flying))'
				})
			)",
		}
	},
	
	"Golem Foundry": {
		name: "Golem Foundry",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: 4,
		rules: "At the end of your turn, Golem Foundry gains &+;&1;&energy; if it has &0;&exhaust;.\nAt the beginning of your turn, if Golem Foundry has &3;&energy;, sacrifice it, summon a 5/5/1 'Iron Golem' creature in its place.",
		creature: {
			tags: ['Construct', 'Foundry'],
			life: 3,
			is_construct: true,
			image_num: 5,
			on_end_turn: "def(class game game) ->commands
				if(game.current_player_index = controller and not is_exhausted,
					add(me.energy, 1)
			)",
			on_begin_turn: "def(class game game) ->commands
			  if(me.energy = 3 and game.current_player_index = controller, [
				set(me.destroyed, true),
				game.summon_creature(construct('creature', {
					name: 'Iron Golem',			
					tags: ['Construct', 'Golem'],
					abilities: ['Haste'],
					school: 4, 
					attack: 5,
					controller: game.current_player_index,
					life: 5,
					move: 1,
					initiative: 20,
					image_num: 76,
					loc: me.loc,
				}))
			])",
		},
	},
	
	"Duff's Device": {
		name: "Duff's Device",
		type: "spell",
		cost: 3,
		loyalty_cost: 3,
		school: 4,
		rules: "Creatures on Duff's Device can move to other Duff's Devices.",
		possible_targets: "def(class game game, int nplayer, [[int]] targets) -> [[int]]|null
		   if(size(targets) = 2, null,
		      filter(game.players[nplayer].summoning_locs(game, construct('creature', {name: q(Duff's Device), school: 4, is_construct: true, life: 3, image_num: 5})),
			         not (value in targets)))",
		on_play: "def(class game game, class message.play_card info) ->commands
		 map(info.targets, game.summon_construct(construct('creature', {
			name: q(Duff's Device),
			tags: ['Construct', q(Duff's Device)],
			school: 4,
			life: 3,
			controller: game.current_player,
			loc: value,
			image_num: 5,
			is_construct: true,
			static_ability_effect: q(if(creature != target and creature.controller = target.controller and creature.loc[0] = target.loc[0], 
				target.add_ability_static_duration({
					name: 'Teleport',
					cost: 3,
					school: 4,					
					is_response: true,
					exhausts_creature: true,
					rules: q(Teleport to another lane with a Duff's device in it),
					is_usable: q(def(class game game, class creature creature) ->bool
					   not ('Exhausted' in creature.status_effects)),
					possible_targets: q(def(class game game, class creature creature, [[int]] targets) ->[[int]]|null
						if(targets = [], [[construct.loc[0], creature.loc[1]] | construct <- game.creatures, 
							q(Duff's Device) in construct.tags, 
							construct.controller = game.current_player_index, 
							creature.loc[0] != construct.loc[0], 
							game.creature_at_loc([construct.loc[0], creature.loc[1]]) = null]
						)
					),
					on_play: q(def(class game game, class creature creature, message.play_ability info) ->commands set(creature.loc, info.targets[0]) asserting size(info.targets) = 1),
				})
			))
		})))"
	},
}
