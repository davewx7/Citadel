{
	id: "title_controller",
	prototype: ["title_controller_base"],
	is_human: true,
	hitpoints: 20,
	editor_info: { category: "player" },
    hidden_in_game: true,

	is_strict: true,

	types: {

	},

	consts: {
		BUTTON_WIDTH: 220,
		BUTTON_HEIGHT: 35,
	},
	
    properties: {

	gui_left_edge: "int :: lib.gui.py(232)",
	gui_right_edge: "int :: lib.gui.py(1206)",


	offline_mode: "bool :: mm_client = null",
	
	process: "def() ->commands [
		if(_player_profile_dirty, draw_player_profile()),
		if(_debug_label_mouse_loc, _debug_show_mouse_loc()),

		if(me._internal_client, tbs_process(me._internal_client)),

		if(cycle%600 = 0, trigger_garbage_collection()),

	]",

	_request_server_info: "bool :: true",

	blankscreen: "def() ->commands
		[remove_object(c) | c <- level.chars, c != me]
	",

	recent_games_updated: "def() ->commands
	if(dialog != null, dialog.update_games())
	where dialog = find(level.chars, value is obj recent_games_dialog)
	",

	open_packs: "def() ->commands
	execute(me, [
		if(opening_packs, opening_packs.return_to_titlescreen(),
		
		transition_screen(spawn('open_packs_screen', {
			controller: me,
		}), [enum transition_zoom_in, enum transition_after_zoom, enum transition_no_remove_objects]
		)
		)
	])

	where opening_packs = find(level.chars, value is obj open_packs_screen)
	",

	show_recent_games: "def() ->commands
	execute(me,
		if(mm_client != null, tbs_send(mm_client, { type: 'get_recent_games', user: username }));
		spawn('recent_games_dialog', {
			mid_x: level_width/2,
			mid_y: level_height/2,
			controller: me,
		}, [
		])
	)
	",

	_debug_label_mouse_loc: { type: "bool", default: false },
	_debug_mouse_loc: { type: "null|obj label" },
	_debug_show_mouse_loc: "def() ->commands [
		remove_object(_debug_mouse_loc),
		spawn('label', 0, 0, {
			x: lib.gui.px(1370),
			y: 0,
			zorder: 20000,
			_font_size: 16,
			_text: ['(' + str(mouse_x) + ',' + str(mouse_y) + ')']
		}, [
			set(_debug_mouse_loc, child)
		]),
	]",

	mouse_x: "int<- ctrl_mice[0][0]",
	mouse_y: "int<- ctrl_mice[0][1]",

		editparticles: "def() ->commands [
			set(level.frame_buffer_shaders, []),
			game_preferences().set_preference_value('particle_editor', true),
			map(level.chars, remove_object(value)),

			if(find(level.chars, value is obj particle_editor) = null,
				add_object(object_playable('particle_editor', 400, 400, 1, {
					draggable: true,
					return_to_titlescreen: def() ->commands execute(me, [
						map(level.chars, remove_object(value)),
						add_object(me),
						me.show_devtools(),
						lib.citadel.add_main_background_shader(level),
					]),
				}))
			)
		]",

		load_stats: "def() ->commands [
			download_stats();

			spawn('stats_display', {
				x: lib.gui.py(200),
				y: lib.gui.py(40),
				_width: lib.gui.py(1300),
				_height: lib.gui.py(840),
				zorder: 5000,
			})
		]",

		adjustcards: "def() ->commands [
			[remove_object(c) | c <- level.chars, c != me],
			add_object(object_playable('card_adjustment_controller', 0, 0, 1, {_mm_client_state: _mm_client_state, title_controller: me}))
		]",

		editanimations: "[
			add_object(object_playable('animation_sandbox', 0, 0, 1, {})),
		]",

		selected_deck_category: "string <- if(decks, lib.citadel.preferences.deck_category or 'starter', 'starter')",
		selected_deck: "string <-
		if(res in table, res, keys(table)[0])
		  where table = if(selected_deck_category = 'custom', decks, lib.json.get_document_map('data/starting-decks.cfg'))
		  where res = if(selected_deck_category = 'custom', lib.citadel.preferences.selected_custom_deck, lib.citadel.preferences.selected_starter_deck)",

        _internal_client: { type: "object|null", default: null },
		_session_id: { type: "int", default: -1 },

		client_state: "class mm_client_state :: _mm_client_state",
		decks: "DeckMap :: account_info.decks",

		//show a toast about a multiplayer game being available unless
		//we are already in the multiplayer lobby.
		should_notify_multiplayer_queue: "def() ->bool
			if(_screen_controller is obj multi_lobby_controller, false, true)
		",

		_default_section: { type: "int", default: 0 },

		enter_tutorial: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('tutorial_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		enter_puzzles: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('puzzle_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		enter_single: "def(custom_obj old_controller) ->commands
		execute(me,
			spawn('single_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		)
		",

		in_multi_lobby: "bool :: _screen_controller is obj multi_lobby_controller",

		goto_multiplayer_lobby: "def() ->commands
			enter_multi()
		",

		enter_multi: "def(null|custom_obj old_controller=null) ->commands
		execute(me,
		transition_screen(_enter_multi_immediate(old_controller),

			[enum transition_zoom_in, enum transition_after_zoom, enum transition_no_remove_objects]
		)
		)
		",

		_enter_multi_immediate: "def(null|custom_obj old_controller=null) ->commands
		[
			set(return_from_game_override, null),
			set(screen_mode, enum multi_screen),
			[remove_object(c) | c <- level.chars, c != me, c not in all_chat_widgets, c not in all_profile_widgets, c not in all_users_online_widgets, c != _quest_heading, (c is obj quest_display) = false]
			where all_profile_widgets = if(_player_profile_pane != null, spawned_descendants(_player_profile_pane), []) + if(_choose_deck_controller != null, spawned_descendants(_choose_deck_controller), [])
			where all_chat_widgets = if(chat_widget != null, spawned_descendants(chat_widget), [])
			where all_users_online_widgets = if(users_online_pane != null, spawned_descendants(users_online_pane), [])
			where users_online_pane = find(level.chars, value is obj users_online_pane),
			spawn('multi_lobby_controller', 0, 0, {
				title_controller: me,
				return_controller: old_controller,
			}, [
				set(me._screen_controller, child)
			])
		]
		",

		_replay_options: { type: "map", default: {} },

		watch_replay: "def(string game_id, map options={}) ->commands
		execute(me,	[
			set(_replay_options, options),
			if(mm_client != null, tbs_send(mm_client, { type: 'get_replay', id: game_id })),
		]
		)
		",

		replay_perspective: { type: "int", default: 0 },

		start_replay: "def(map replay) ->commands
			enter_game(
  				object_playable('citadel_controller', 336, 372, 0, {
				observer: true,
				_observer_perspective: replay_perspective,
				game_created: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
				_replay: replay,
				_replay_options: _replay_options,
				respond_to_challenge: me.return_from_game_to_challenge,
			}))
		",

		return_from_game_override: { type: "null|function(bool, null|class game_state)->commands" },

		return_from_game: "def(bool result, null|class game_state state)->commands
		execute(me, [
			add_object(me),
			(set(level.frame_buffer_shaders, []); lib.citadel.add_main_background_shader(level)),
			if(_screen_controller != null, add_object(_screen_controller)),
		];

		if(return_from_game_override,
		   return_from_game_override(result, state),
		   _screen_controller is obj multi_lobby_controller,
		   show_ui(); _enter_multi_immediate(),
		   show_ui()
		)
		)",

		return_from_game_to_challenge: "def() ->commands
			return_from_game(false, null);
			remove_object(me);
			add_object(me);
			show_ui();
			_enter_multi_immediate()
		",

		enter_library: "def(custom_obj old_controller, null|string deck=null, null|function()->commands exit_override=null, bool god_mode=false) ->commands
		execute(me, [
			remove_object(me),
			add_object(library),
			library.suspend_preloads(20),
			set(screen_mode, enum library_screen),
		  ]
		  where library = object_playable('library_controller', 0, 0, 1, {
				title_controller: me,
				return_controller: old_controller,
				_mm_client_state: _mm_client_state,
				deck_rules: construct('deck_rules', if(god_mode, {max_duplicates: 50}, {})),
				_force_edit_deck: deck,
				_exit_override: exit_override,
				_god_mode: god_mode,
				specified_collection: if(god_mode, fold(map(lib.citadel.card_sets, lib.citadel.get_cards_in_set(value.id)), a+b, [])*3),
			}
			)
		)
		",

		possible_avatars: "[string] :: lib.citadel.basic_avatars",

		close_settings: "def() ->commands
		[
		]
		",

		force_campaign_world_map: { type: "bool", default: false },

		set_campaign_controller: "def(bool force_clear=false, string campaign_name='') ->commands
		if(campaign_name, set(_mm_client_state.account_info.campaign_location, campaign_name));
		if(force_campaign_world_map, [
			spawn('map_campaign_controller', 0, 0, {
				_mm_client_state: _mm_client_state
			}, [
				set(_screen_controller, child),
			]),

			set(force_campaign_world_map, false),
		],

		if((campaign_doc is map) and campaign_doc['campaign_type'],
		[
		   add_object(object_playable((string<- campaign_doc['campaign_type']) + '_campaign_controller', 0, 0, 1, {
			 _mm_client_state: _mm_client_state,
			 _title_controller: me,
		   }))
		],

		[
			set(_campaign_controller, ctrl),
			add_object(ctrl),
			if(ctrl != _screen_controller, [
				set(_screen_controller, ctrl),
			]),

			set(_screen_controller, ctrl),
		] where ctrl = if(_campaign_controller and force_clear = false,
		                  _campaign_controller,
						  object('campaign_controller', 0, 0, {
								 _mm_client_state: _mm_client_state,
						  }))
		 )
		  where campaign_doc = if(_mm_client_state.account_info.campaign_location is string, lib.json.get_document_map('data/' + _mm_client_state.account_info.campaign_location))
		)",

		_campaign_controller: { type: "null|obj campaign_controller" },

		_screen_controller: { type: "custom_obj|null" },
		set_screen_controller: "def(custom_obj obj) ->commands set(_screen_controller, obj)",
		get_screen_controller: "custom_obj|null :: _screen_controller",

		_welcome_label: { type: "custom_obj|null" },
		_logout_label: { type: "custom_obj|null" },

		show_update_status: "def() ->commands [
			set(me.widgets, [
				{ x: 4, y: level_height - lib.gui.px(124), type: 'label', id: 'module_update_status', size: lib.gui.px(12), text: 'Argentum Age version ' + str(MODULE_VERSION), color: 'white' },
				{ x: 4, y: level_height - lib.gui.px(110), type: 'label', id: 'module_update_status', size: lib.gui.px(12), text: if(auto_update_status().attempt_module, if(auto_update_status().complete_module, 'Citadel up-to-date', if(err = 'no_newer_module', 'Argentum Age up to date', err is string, 'Error updating Citadel: ' + err, 'Citadel update timed out') where err = auto_update_status().module_error), 'Not auto-updating Citadel'), color: 'white' },
				{ x: 4, y: level_height - lib.gui.px(96), type: 'label', id: 'anura_update_status', size: lib.gui.px(12), text: if(auto_update_status().attempt_anura, if(auto_update_status().complete_anura, 'Anura up-to-date', if(err = 'no_newer_module', 'Anura up to date', err is string, 'Error updating Anura: ' + err, 'Anura update timed out') where err = auto_update_status().anura_error), 'Not auto-updating Anura'), color: 'white' },
			]),
		]",

		spawn_deck_summaries: "def() ->commands [
			[remove_object(c) | c <- level.chars, c is obj library_deck_summary],

			map(decks, spawn('library_deck_summary', 0, 0, {selected: index = if(selected_index >= 0, selected_index, 0), zorder: 500, deck_name: key, x2: level_width, y: lib.gui.py(28 + 72 + 72*index), _mm: me}))
			    where selected_index = index(keys(decks), find(keys(decks), value = lib.citadel.preferences.selected_deck)),
		]",

		send_message: "def(map msg) ->commands execute(me, [
			if(mm_client != null, tbs_send(mm_client, msg))
		])",

		grant_cards: "def(string|null user_id=null) ->commands [
			execute(me, if(mm_client != null, tbs_send(mm_client, { type: 'admin_operation', msg: { user: user_id or username, type: 'grant', sets: ['*'] } })))
		]",

		enter_game: "def(obj citadel_controller playable, bool immediate=false) ->commands
		execute(me,
			if(immediate, cmd, transition_screen(cmd, [enum transition_zoom_in, enum transition_all_zorders]))
			where cmd = [
				map(level.chars, remove_object(value)),
				add_object(playable),
			]
		)
		",

		join_game: "def(string host, int port, int|null session_id_override=null) ->commands execute(me, [
			//clear challenges now that we're entering a game.
			set(lib.tbs.open_challenges, []),

			enter_game(playable)
  			where playable = object_playable('citadel_controller', 336, 372, 0, {
				game_server_address: host,
				game_server_port: port,
				session_id: if(session_id_override != null, session_id_override, _mm_client_state.session_id),
				selected_deck: me.selected_deck,
				selected_deck_category: me.selected_deck_category,
				game_created: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
				respond_to_challenge: me.return_from_game_to_challenge,
			})
		])",

		request_observe_game: "def(string username) ->commands
			execute(me, if(mm_client != null, tbs_send(mm_client, { type: 'request_observe', target_user: username })))
		",

		observe_game: "def(GameServer server, string|null target_user=null, int|null session_override=null) -> commands [
			let cl = controller.create_tbs_client();
			let request = tbs_blocking_request(cl, {
				type: 'observe_game',
				user: username,
			});

			request.block();

			if(response is map and response.type = 'observing_game',
			   enter_game(controller),
			   spawn_notification('Could not observe game')
			) where response = request.response
		]
		  where controller =
  				object_playable('citadel_controller', 336, 372, 0, {
				game_server_address: TBS_SERVER_ADDRESS,
				game_server_port: server.port,
				session_id: (session_override or 1d1000000), //_mm_client_state.session_id,
				game_created: true,
				observer: true,
				_mm_client_state: _mm_client_state,
				return_callback: me.return_from_game,
				_observer_perspective: perspective,
				respond_to_challenge: me.return_from_game_to_challenge,
			})
		  where perspective = if(target_user and (lower(target_user) in map(server.users, lower(value))), index(map(server.users, lower(value)), lower(target_user)))
		",

		_challenge_text: "def(string username) ->string sprintf(q(%s has challenged you to a game!), username)",

		click_challenge: "def(string username) ->commands
			if(get_screen_controller and not in_multi_lobby,
				transition_screen(; execute(get_screen_controller, enter_multi(get_screen_controller)), [enum transition_zoom_in, enum transition_after_zoom, enum transition_all_zorders]),

				issue_challenge(username)
			)
		",


		return_to_main: "def() ->commands [
			if(_logout_label and (_logout_label not in level.chars), add_object(_logout_label)),
			if(_welcome_label and (_welcome_label not in level.chars), add_object(_welcome_label)),
		]
		",

		transition_screen: "def(commands cmd, [enum {transition_zoom_in, transition_after_zoom, transition_no_remove_objects, transition_all_zorders, transition_options_zorder_only}] flags=[]) ->commands
		//bool zoom_in=true, bool after_zoom=true) ->commands
		execute(me,
		[
			spawn('zoom_effect_controller', 0, 0, {
				begin_zorder: if(enum transition_all_zorders in flags, -10000, enum transition_options_zorder_only in flags, 100, -10),
				end_zorder: if(enum transition_all_zorders in flags, 50000, 2000),
				source_area: [0.0,0.0,1.0,1.0],
				dest_area: [0.0,0.0,1.0,1.0],
				flat_color: [0.09,0.14,0.18,1.0],
			}, [
				animate(child, {
					dest_area: if(enum transition_zoom_in in flags, [-0.25,-0.25,1.25,1.25], [0.1,0.1,0.9,0.9]),
					effect_alpha: 0.0,
					flat_color_mix: if(enum transition_after_zoom in flags, 0.0, 1.0),
				}, {
					duration: if(MODULE_OPTIONS.startgame, 1, 20),
					on_complete: ; [
						remove_object(child),
						if(enum transition_no_remove_objects not in flags, [ remove_object(c) | c <- level.chars, (c is obj title_controller) = false ]),
						cmd,

						if(enum transition_after_zoom in flags,

						spawn('zoom_effect_controller', 0, 0, {
							begin_zorder: if(enum transition_all_zorders in flags, -10000, enum transition_options_zorder_only in flags, 100, -10),
							end_zorder: 2000,
							source_area: [0.0,0.0,1.0,1.0],
							dest_area: if(enum transition_zoom_in in flags, [0.1,0.1,0.9,0.9], [-0.25,-0.25,1.25,1.25]),
							effect_alpha: 0.0,
							flat_color: [0.09,0.14,0.18,1.0],
						}, [
							animate(child, {
								dest_area: [0.0,0.0,1.0,1.0],
								effect_alpha: 1.0,
							}, {
								duration: 20,
								on_complete: remove_object(child)
							})
						])
						),
					]
				})
			]),
		]
		)
		",

		_specified_deck: { type: "null|[string]" },
		set_specified_deck: "def(null|[string] deck) ->commands set(_specified_deck, deck)",

		play_against_deck: "def([string] enemy_deck) ->commands
		execute(me,
		[
			play_single_player_game(scenario)
		]
		where scenario = {
			name: 'Challenge',
			text: '',
			set: 'core',
			avatar: 'janus-the-great.png',
			portrait: 'janus-the-great.png',
			portrait_scale: 0.2,
			portrait_translate: [0,0],
			enemy_name: 'Catherine',
			bot_args: {
				deck: str(enemy_deck),
			}
		}
		)",

		play_test: "def(string name) ->commands
		if(scenario = null,
			debug(['No such test. Valid tests:', map(tests, value.name)]),
			set(_specified_deck, scenario.player_deck);
			play_single_player_game(scenario)
		)
		where scenario = find(tests, value.name = name)
		where tests = [Scenario]<- get_document('data/test-cases.cfg')
		",

		_game_setup_message: { type: "null|map" },

		_scenario_playing: { type: "null|Scenario" },

		_target_start_single_player: { type: "null|int" },

		send_stats: "def(string table_name, [string|int|decimal|bool|null] data) ->commands
		let msg = {
			user: username,
			data: [
			{
				table: table_name,
				rows: [
					data
				]
			}
			]
		};
		let client = tbs_client('127.0.0.1', 24567);
		let request = tbs_blocking_request(client, msg);
		request.block();
		debug(['GOT RESPONSE', request.response])

		",

		play_single_player_game: "def(Scenario scenario) ->commands
		execute(me,
		if(scenario.player_deck, set_specified_deck(scenario.player_deck));
		schedule(10, lib.sound.play_sound(me, 'gameplay/game_start'));

		set(_session_id, 1);

		let msg = {
			type: 'create_game',
			starting_units: scenario.starting_units,
			map_dimensions: scenario.map_dimensions,
			map_lanes: scenario.map_lanes,
			player_resources: scenario.player_resources,
			trophies: scenario.trophies,
			skip_mulligan: scenario.skip_mulligan,
			no_shuffle: scenario.no_shuffle,
			users: if(scenario.play_second, reverse(users), users) where users = [{user: username, avatar: account_info.avatar, session_id: _session_id, quests: account_info.quests}, {user: scenario.enemy_name, bot_type: scenario.bot_type or 'eval', args: { name: scenario.enemy_name, avatar: scenario.avatar }, bot_args: scenario.bot_args or {}, bot: true, session_id: _session_id+1, avatar: scenario.avatar}],
			tutorial: scenario.tutorial,
			setup_commands: scenario.setup_commands,
		}
		;

		set(_scenario_playing, scenario);
		set(_game_setup_message, msg);

		let client = tbs_internal_client();

		let request = tbs_blocking_request(client, msg);

		//this will make it so the transition animation to start a game
		//occurs at the same time as the game request is sent and handled.
		//we will only go to the next command after both the game is set
		//up and the transition finishes.
		[
			request.block(),
			transition_effect_blocking('zoom_in'),
		];

		if((not request.response is map) or (map<-request.response).type != 'game_created', [
			debug(['ERROR CREATING GAME', request.response]),
			cancel(),
		]);

		start_game()
		)
		",

		start_game: "def() ->commands
		if(_target_start_single_player is int and _target_start_single_player > cycle,
		   schedule(_target_start_single_player - cycle, ; start_game()),

		[
		enter_game(playable, _target_start_single_player is int),
		set(_target_start_single_player, null),
		set(_specified_reward, null),
		set(_specified_deck, null),

		set(_game_setup_message, null),
		set(_scenario_playing, null),
		]
		   where playable = object_playable('citadel_controller', 336, 372, 0,
		   {
			scenario: _scenario_playing,
			puzzle_name: if(_scenario_playing and _scenario_playing.skip_mulligan, _scenario_playing.name),
		    game_setup_message: _game_setup_message,
			_mm_client_state: _mm_client_state,
			game_server_address: '',
			game_server_port: 23456,
			session_id: me._session_id,
			game_created: true,
			_title_controller: me,
			selected_deck: me.selected_deck,
			selected_deck_category: me.selected_deck_category,
			return_callback: me.return_from_game,
			specified_deck: _specified_deck,
			specified_reward: _specified_reward,
			respond_to_challenge: me.return_from_game_to_challenge,
			client_tutorial_args: if(_scenario_playing, _scenario_playing.client_tutorial_args) or {},
			}
		   )
		 )
		",

		_specified_reward: { type: "CampaignRewardInfo|null" },
		set_specified_reward: "def(CampaignRewardInfo|null reward) ->commands
			set(_specified_reward, reward)
		",

		_quest_heading: { type: "null|obj label" },

		claim_quest: "def(string quest) ->commands
			execute(me,
				if(mm_client != null, tbs_send(mm_client, { type: 'claim_quest', quest: quest }))
			)
		",

		update_quests: "def() ->commands [
			set(_adjust_gold_display, 0),

			[ remove_object(c) | c <- level.chars, c is obj quest_display ],

			remove_object(_quest_heading),
			set(_quest_heading, null),

			if(screen_mode in [enum titlescreen, enum multi_screen],
			map(ordered_quests, spawn('quest_display', {
				x: quest_xpos,
				y: quest_ypos + index*lib.gui.py(46),
				quest: lib.quest.create(value),
				controller: me,
				zorder: 3000,
			}, [
				if(index = 0,
					spawn('label', {
						x: quest_xpos,
						y: quest_ypos - lib.gui.py(46),
						_force_width: round_to_even(lib.gui.py(206)),
						_force_height: round_to_even(lib.gui.py(46)),
						_text: ['Daily Quests'],
						_font_size: lib.gui.py(18),
						_bg_color: [0.1,0.1,0.1,0.6],
						_halign: 'none',
						_valign: 'none',
						zorder: 3000,
					}, [
						set(_quest_heading, child),
					])
				),

				if(prev_quest != null, child.animate_value(prev_quest.current_value, value.current_value)),
				if(value in just_complete_quests,
				[
					add(_adjust_gold_display, quest_info.reward),
					animate(child, {
						brightness: 512,
						scale: 1.5,
					}, {
						name: 'finish_quest',
						replace_existing: false,
						duration: 20,
					});

					animate(child, {
						alpha: 0
					}, {
						name: 'finish_quest',
						replace_existing: false,
						duration: 20,
						on_complete: remove_object(child)
					})
				]
				),
				if(value in account_info.quests and index(ordered_remaining_quests, value) != index, schedule(50, animate(child, { y: quest_ypos + index(ordered_remaining_quests, value)*lib.gui.py(46)}, { duration: 10 })))
			])
			where quest_info = lib.quest.create(value)
			
			where prev_quest = find(previous_quests, value.type = context.value.type))
			),

			write_document(username + '/known-quests.cfg', { quests: account_info.quests, complete_quests: account_info.complete_quests }),
			; if(_adjust_gold_display != 0,
				schedule(30, animate(me, { _adjust_gold_display: 0 }, { duration: _adjust_gold_display*2 }))
			)

		] where ordered_quests = sort(account_info.quests + just_complete_quests, a.assigned_date < b.assigned_date)
		  where ordered_remaining_quests = sort(account_info.quests, a.assigned_date < b.assigned_date)
		  where just_complete_quests = filter(account_info.complete_quests, find(previous_complete_quests, value.type = context.value.type) = null)
		  where previous_complete_quests = if(previous_quests_doc is { quests: [Quest], complete_quests: [Quest] }, previous_quests_doc.complete_quests, [])
		  where previous_quests = if(previous_quests_doc is { quests: [Quest], complete_quests: [Quest] }, previous_quests_doc.quests, [])
		  where previous_quests_doc = get_document(username + '/known-quests.cfg', [enum user_preferences_dir, enum null_on_failure, enum json]) or []
		  where quest_xpos = lib.gui.py(614)
		  where quest_ypos = lib.gui.py(656)
		  ",

		_adjust_gold_display: { type: "int", default: 0, set: "if(value != _data, [set(_data, value), set(_player_profile_dirty, true)])" },
		_adjust_level_display: { type: "decimal", default: 0.0, set: "if(value != _data, [set(_data, value), set(_player_profile_dirty, true)])" },

		_player_profile_pane: { type: "null|obj player_profile_pane" },
		_choose_deck_controller: { type: "null|obj choose_deck_controller" },

		_player_profile_dirty: { type: "bool", default: false },

		_prev_level: { type: "decimal|null" },

		update_player_profile: "def() ->commands [
			set(_player_profile_dirty, true),

			if(_prev_level != null and _prev_level != account_info.level, [
				add(_adjust_level_display, (account_info.level - _prev_level));
				schedule(30, animate(me, { _adjust_level_display: 0 }, { duration: 30 })),
			]),

			set(_prev_level, account_info.level),
		]",

		draw_player_profile: "def() ->commands ; execute(me, [
			set(_player_profile_dirty, false),

			remove_object(_player_profile_pane),

			spawn('player_profile_pane', {
				x: gui_right_edge + lib.gui.py(18),
				y: lib.gui.py(24),
				zorder: -200,
				title_controller: me,
				_adjust_gold_display: _adjust_gold_display,
				_adjust_level_display: _adjust_level_display,
			}, [
				set(me._player_profile_pane, child),
			]),

		])",

		draw_choose_deck_controller: "def() ->commands ; execute(me, [
			remove_object(_choose_deck_controller),

			spawn('choose_deck_controller', { 
				title_controller: me,
				current_controller: me,
				_collapsed: true,

				x: lib.gui.py(765),
				y2: lib.gui.py(699),
				_deck_widget_width: 214,
				right_side: true,

				zorder: 3000,
			}, [
				set(me._choose_deck_controller, child),
			]),
		])",

		screen_mode: { type: "enum { titlescreen, campaign_screen, multi_screen, library_screen }", default: "@eval enum titlescreen" },

		_present_ui: "def() ->commands 
		[

			[update_player_profile(); draw_player_profile(); draw_choose_deck_controller()],

			set(screen_mode, enum titlescreen),

			set(_screen_controller, null),

			set(_internal_client, null),
			set(_session_id, -1),

			if(game_title != null, [
				add_object(game_title),
				animate(game_title, {
					_font_size: lib.gui.py(34),
				}, {
					duration: 10,
					on_process: fire_event(game_title, 'create'),
					on_complete: fire_event(game_title, 'create'),
				}),

				animate(game_title, {
					x: lib.gui.py(102),
					mid_y: lib.gui.py(48),
				}, {
					duration: 20,
				}),
			]),

			if(game_logo != null, [
				add_object(game_logo),
				animate(game_logo, {
					size: lib.gui.py(74),
					mid_x: lib.gui.py(56),
					mid_y: lib.gui.py(68),
				}, {
					duration: 20,
				})
			]),

			spawn('button_controller', {
				text: q(Terms &amp; Conditions),
				x2: lib.gui.py(160),
				y2: level_height - lib.gui.py(20),
				_font_size: lib.gui.py(10),
				button_width: lib.gui.py(100), 
				button_height: lib.gui.py(24), 
				on_click: def()->commands spawn('terms_and_conditions', {}),
				zorder: zorder+1,
				color_scheme: lib.citadel.library_color_scheme,
			}),

			if(MODULE_OPTIONS.devtools,
				spawn('button_controller', {
					text: 'Devtools',
					x2: lib.gui.py(160),
					y2: level_height - lib.gui.py(50),
					_font_size: lib.gui.py(16),
					button_width: lib.gui.py(100), 
					button_height: lib.gui.py(24), 
					on_click: me.show_devtools,
					zorder: zorder+1,
					color_scheme: lib.citadel.library_color_scheme,
				})
			),

			spawn('game_icon', {
				size: lib.gui.py(32),
				icon: 'gear-hammer.svg',
				x: lib.gui.py(20),
				y2: level_height - lib.gui.py(20),
				mouse_enter_handler: def(obj game_icon icon) ->commands [
					set(icon.draw_color, [1.0, 1.0, 0.5, 1.0]),
					icon.invalidate(),
				],

				mouse_leave_handler: def(obj game_icon icon) ->commands [
					set(icon.draw_color, [1.0, 1.0, 1.0, 1.0]),
					icon.invalidate(),
				],

				click_handler: def(obj game_icon icon)->commands execute(me, escape_menu()),
			}),

			spawn('news_updates_pane', {
				x: gui_right_edge - lib.gui.py(370),
				y: lib.gui.py(608),
				title_controller: me,
			}),

			spawn('title_option_widget', {
				mid_x: gui_left_edge + int((gui_right_edge - gui_left_edge)*0.2),
				mid_y: level_height/2,
				zorder: 200,
				_width: lib.gui.py(220),
				_portrait: 'garron-the-smuggler.png',
				_name: 'Campaign',
				click_handler: def(obj title_option_widget w)->commands me._enter_campaign_screen(),
			}),

			spawn('title_option_widget', {
				mid_x: gui_left_edge + int((gui_right_edge - gui_left_edge)*0.5),
				mid_y: level_height/2,
				zorder: 200,
				_width: lib.gui.py(220),
				_portrait: 'staged-duel.png',
				_name: if (offline_mode, 'Single player', 'Multiplayer'),
				click_handler: def(obj title_option_widget w)->commands me.enter_multi(),
			}),

			spawn('title_option_widget', {
				mid_x: gui_left_edge + int((gui_right_edge - gui_left_edge)*0.8),
				mid_y: level_height/2,
				zorder: 200,
				_width: lib.gui.py(220),
				_portrait: 'greatlibrary.png',
				_name: 'Library',
				click_handler: def(obj title_option_widget w)->commands transition_screen(; me.enter_library(me), [enum transition_zoom_in, enum transition_after_zoom, enum transition_all_zorders]),
			}),

			; update_quests(),

		]",

		_return_from_campaign: "def() ->commands 
		map(filter(level.chars, value is obj campaign_location_display),
			animate(value, {
				alpha: 0,
			}, {
				duration: 20,
			})
		);
		transition_screen(; [
			remove_object(me),
			add_object(me);
			show_ui()
		],
		[enum transition_after_zoom, enum transition_options_zorder_only]
		)
		",

		campaign_loc_info: "def() ->class campaign_location
			find_or_die(lib.citadel.get_campaign_locations(), value.name = loc)
			where loc = get_campaign_location()
		",

		get_campaign_location: "def() ->string
		if(loc != null, loc.name,

		   //for now we start the player at Ilz Academy.
		   find_or_die(lib.citadel.get_campaign_locations(), value.display_name = 'Ilz Academy').name
		)

		where loc = find(lib.citadel.get_campaign_locations(), _mm_client_state.account_info.campaign_location in [value.name, value.display_name])
		",

		set_campaign_location: "def(string name) ->commands
		execute(me,
			set(_mm_client_state.account_info.campaign_location, name);
			lib.mm_client_transaction.clear_transactions_of_type('set_campaign_location');
			execute_transaction({
				type: 'set_campaign_location',
				campaign_location: name,
			})
		)
		",

		execute_transaction: "def(map info) ->commands
		if(mm_client != null,
		[
			lib.mm_client_transaction.record_transaction(uuid, msg),
			tbs_send(mm_client, msg),
		]
		where msg = info + { uuid: uuid }
		where uuid = string<- (info['uuid'] or generate_uuid())
		)
		",

		set_campaign_flag: "def(string name) ->commands
		execute(me, if(name not in _mm_client_state.account_info.campaign_flags, [
			add(_mm_client_state.account_info.campaign_flags, [name]),
			if(mm_client != null,
				tbs_send(mm_client, {
					type: 'set_campaign_flag',
					campaign_flag: name,
				})
			)
		]))",

		get_campaign_flags: "def() ->[string]
			_mm_client_state.account_info.campaign_flags
		",

		apply_campaign_reward: "def(CampaignRewardInfo reward) ->commands
		[
			if(reward.location != null, set_campaign_location(reward.location)),
			if(reward.gold, award_gold(reward.gold)),
			if(reward.packs, award_packs('core', reward.packs)),
			if(reward.cards, award_cards_on_server(reward.cards)),
			map(reward.flags, set_campaign_flag(value)),
		]",

		award_gold: "def(int num) ->commands
		execute(me, [
			add(_mm_client_state.account_info.gold, amount),
			execute_transaction({
				type: 'award_gold',
				amount: num,
			})
		])
		where amount = int<- max([-_mm_client_state.account_info.gold, num])
		",

		award_packs: "def(string set, int num) ->commands
		execute(me, [
			set(_mm_client_state.account_info.packs, _mm_client_state.account_info.packs + {(set): (_mm_client_state.account_info.packs[set] or 0) + num}),
			set(_player_profile_dirty, true),

			execute_transaction({
				type: 'award_packs',
				set: set,
				num: num,
			})
		])
		",

		award_cards_on_server: "def([string] cards) ->commands
		execute(me, [
			execute_transaction({
				type: 'award_cards',
				cards: cards,
			})
		])
		",

		buy_pack: "def(string set) ->commands
		execute(me, [
			set(_player_profile_dirty, true),
			if(mm_client != null,
				tbs_send(mm_client, {
					type: 'buy_pack',
					set: set,
				})
			)
		])
		",

		unlock_campaign_location: "def(string name) ->commands
		execute(me, if(name not in _mm_client_state.account_info.unlocks, [
			add(_mm_client_state.account_info.unlocks, [name]),
			add(_recent_campaign_location_unlocks, [name]),
			if(mm_client != null,
				tbs_send(mm_client, {
					type: 'unlock_campaign_location',
					campaign_location: name,
				})
			)
		]))",

		campaign_location_unlocked: "def(string name) ->bool
			name in _mm_client_state.account_info.unlocks
		",

		_recent_campaign_location_unlocks: { type: "[string]", default: [] },

		show_campaign: "def() ->commands
		[
			set(screen_mode, enum campaign_screen),
			[remove_object(c) | c <- level.chars, c != me, c not in all_chat_widgets, c not in all_profile_widgets, c not in all_users_online_widgets]
			where all_profile_widgets = if(_player_profile_pane != null, spawned_descendants(_player_profile_pane), []) + if(_choose_deck_controller != null, spawned_descendants(_choose_deck_controller), [])
			where all_chat_widgets = if(chat_widget != null, spawned_descendants(chat_widget), [])
			where all_users_online_widgets = if(users_online_pane != null, spawned_descendants(users_online_pane), [])
			where users_online_pane = find(level.chars, value is obj users_online_pane),

			spawn('combo_label', 0, 0, {
				x: gui_left_edge + lib.gui.py(14),
				y: level_height - lib.gui.py(54),
				zorder: 200,
				_text: 'Main Menu',
				_font_size: lib.gui.py(26),
				left_rect: lib.gui.lib.gui.py(-4),
				right_rect: lib.gui.lib.gui.py(2),
				grouping: 'back',
				index: 0,
				click_handler: def(obj combo_label lb) ->commands me._return_from_campaign(),
			}, [
			]),

			spawn('campaign_location_display', {
				location: loc_info,
				mid_x: gui_right_edge/2,
				mid_y: int(level_height*0.47),
				zorder: -220,

				explore_handler: def()->commands me.campaign_encounter(loc_info.name),

				alpha: 0,
			}, [
				animate(child, {
					alpha: 255,
				}, {
					duration: 20,
				})
			]),
/*
			map(campaign_locations,
				spawn('title_option_widget', {
					mid_x: if(size(campaign_locations) = 1, (left_edge+right_edge)/2, int(left_edge + spacing*index)),
					mid_y: level_height/2,
					zorder: 200,
					_width: lib.gui.py(220),
					_portrait: value.image,
					_name: value.display_name or value.name,
					click_handler: def(obj title_option_widget w)->commands me.campaign_encounter(value.name),
				}, [
					if(value.name in _recent_campaign_location_unlocks, [
						set(child.alpha, 0),
						schedule(40,
							animate(child, {
								alpha: 255,
							}, {
								duration: 60,
							})
						),
					])
				])
			)

			where spacing = (right_edge - left_edge)/decimal(spaces)
			where right_edge = gui_left_edge + int((gui_right_edge - gui_left_edge)*0.8)
			where left_edge = gui_left_edge + int((gui_right_edge - gui_left_edge)*0.2)
			where spaces = max(1, size(campaign_locations)-1),

*/
			set(_recent_campaign_location_unlocks, []),
		]
		where campaign_locations = filter(lib.citadel.get_campaign_locations(), value.name in shown_locs)
		where shown_locs = [loc_info.name] + loc_info.adjacent + filter(loc_info.adjacent_locked, campaign_location_unlocked(value))
		where loc_info = campaign_loc_info()
		",

		_enter_campaign_screen: "def() ->commands 
		//when entering the campaign screen we want the quest display to zoom out, so set it to zorder 0
		[set(c.zorder, 0) | c <- level.chars, c is obj quest_display or c = _quest_heading];
		transition_screen(;
		show_campaign(),
		[enum transition_zoom_in, enum transition_after_zoom, enum transition_no_remove_objects]
		)
		",

		update_challenges: "def() ->commands
		if(new_challenges != lib.tbs.open_challenges, [
			set(lib.tbs.open_challenges, new_challenges);
			[[ ch.refresh() | ch <- level.chars, ch is obj user_online_entry, ch.info.id = c.user] | c <- lib.tbs.open_challenges, c not in new_challenges]
		])
			where new_challenges = filter(lib.tbs.open_challenges, value.expiry_time > time().unix)
		; schedule(60, ; update_challenges())
		",

		create: "def() ->commands [
			lib.mm_client_transaction.process_transactions(me),
			lib.citadel.add_main_background_shader(level); update_challenges(),
		]
		",

		spawned_descendants: "def(custom_obj o, [custom_obj] existing=[]) ->[custom_obj]
		if(o in existing, [],
			[o] + fold(map(o.spawned_children, spawned_descendants(value, existing + [o])), a+b, [])
		)
		",

		show_devtools: "def() ->commands
		execute(me,
		[remove_object(c) | c <- level.chars, c != me, c not in profile_pane_children]
		
		where profile_pane_children = if(profile_pane, spawned_descendants(profile_pane), [])
		where profile_pane = find(level.chars, value is obj player_profile_pane);

		spawn('button_controller', {
			text: 'Edit Campaign',
			x: lib.gui.py(20),
			y2: lib.gui.py(60),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: def()->commands me.editcampaign,
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		});

		spawn('button_controller', {
			text: 'Adjust Cards',
			x: lib.gui.py(20),
			y2: lib.gui.py(100),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: me.adjustcards,
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		});

		spawn('button_controller', {
			text: 'Edit Particles',
			x: lib.gui.py(20),
			y2: lib.gui.py(140),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: me.editparticles,
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		});

		spawn('button_controller', {
			text: 'Load Stats',
			x: lib.gui.py(20),
			y2: lib.gui.py(180),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: me.load_stats,
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		});

		spawn('button_controller', {
			text: 'Grant Pack',
			x: lib.gui.py(300),
			y2: lib.gui.py(60),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: def()->commands me.award_packs('core', 1),
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		});

		spawn('button_controller', {
			text: 'Grant Gold',
			x: lib.gui.py(300),
			y2: lib.gui.py(100),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: def()->commands me.award_gold(100),
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		});

		spawn('button_controller', {
			text: 'Back',
			trap_escape: true,
			x: lib.gui.py(20),
			y2: lib.gui.py(380),
			_font_size: lib.gui.py(16),
			button_width: lib.gui.py(120), 
			button_height: lib.gui.py(24), 
			on_click: (def()->commands
				[remove_object(c) | c <- level.chars, c != me];
				show_ui()
			),
			zorder: zorder+1,
			color_scheme: lib.citadel.library_color_scheme,
		})

		)
		",

		editcampaign: "commands ::
		[remove_object(c) | c <- level.chars, c != me];
		spawn('campaign_location_editor', {
		})
		",

		edit_dialog: "def(string node, int selected_node_index=0, null|function()->commands return_fn=null) ->commands
		[remove_object(c) | c <- level.chars, c != me];

		spawn('campaign_dialog_editor', {
			x: level_width - lib.gui.py(400),
			y: lib.gui.py(10),
			width: lib.gui.py(400),
			height: lib.gui.py(800),

			nodes: [lib.campaign_encounter.get_campaign_dialog_node(node)],
			selected_node_index: selected_node_index,

			title_controller: me,

			_return: if(return_fn != null, return_fn,
				(def() ->commands
					[remove_object(c) | c <- level.chars, c != me];
					show_ui()
				)
			),

		})

		",

		test_dialog: "def(string node) ->commands
		[remove_object(c) | c <- level.chars, c != me];

		spawn('campaign_encounter_dialog', {
			controller: me,
			location_name: 'Test',
			encounter: encounter,
			_starting_objects: [],
		})

		where encounter = construct('campaign_encounter', {
			node: node,
		})
		",

		campaign_encounter: "def(string location_name) ->commands
		transition_screen(;
		[
			[remove_object(c) | c <- level.chars, c != me, c not in all_chat_widgets, c not in all_profile_widgets, c not in all_choose_deck_widgets]
			where all_profile_widgets = if(_player_profile_pane != null, spawned_descendants(_player_profile_pane), []) + if(_choose_deck_controller != null, spawned_descendants(_choose_deck_controller), [])
			where all_chat_widgets = if(chat_widget != null, spawned_descendants(chat_widget), [])
			where chat_widget = find(level.chars, value is obj chat_widget)
			where all_choose_deck_widgets = if(choose_deck_widget != null, spawned_descendants(choose_deck_widget), [])
			where choose_deck_widget = find(level.chars, value is obj choose_deck_controller);
			spawn('campaign_encounter_dialog', {
				controller: me,
				location_name: location_name,
				encounter: lib.campaign_generator.generate_encounter(me, loc_info),
				_starting_objects: level.chars,
			}),
		] where loc_info = find_or_die(lib.citadel.get_campaign_locations(), value.name = location_name),

		[enum transition_zoom_in, enum transition_no_remove_objects])
		",

		add_campaign_quest: "def(string quest_id) ->commands
			if(quest_id not in lib.citadel.campaign_quest_progress,
				add(lib.citadel.campaign_quest_progress, {(quest_id): 0});
				if(encounter_dialog, encounter_dialog.update_campaign_quest_progress(quest_id))
			)
			where encounter_dialog = find(level.chars, value is obj campaign_encounter_dialog)
		",

		progress_campaign_quest: "def(string quest_id, int amount) ->commands
			add(lib.citadel.campaign_quest_progress, {(quest_id): (lib.citadel.campaign_quest_progress[quest_id] or 0) + amount});

			if(encounter_dialog != null, encounter_dialog.progress_campaign_quest(quest_id, amount))
			where encounter_dialog = find(level.chars, value is obj campaign_encounter_dialog)
		",

		complete_campaign_quest: "def(string quest_id) ->commands
		set(lib.citadel.campaign_quest_progress, remove_from_map(lib.citadel.campaign_quest_progress, quest_id));
			if(encounter_dialog != null, encounter_dialog.complete_campaign_quest(quest_id))
			where encounter_dialog = find(level.chars, value is obj campaign_encounter_dialog)
			
		",
    },
      
	events: {

	window_resize: "
	[
		game_preferences().set_preference_value('min_window_width', width, [enum persistent]);
		game_preferences().set_preference_value('max_window_width', width, [enum persistent]);
		game_preferences().set_preference_value('min_window_height', height, [enum persistent]);
		game_preferences().set_preference_value('max_window_height', height, [enum persistent]);
		set(level.dimensions, [0,0,width,height]);

		lib.gui.set_screen_dimensions(level);

		show_ui()
	]

	where width = max(800, arg.width)
	where height = max(600, arg.width)


	",
	
	quit_game: "
		//The user is closing out the app. Quit elegantly by
		//sending a message saying so to the server.
		set(level.quitting_game, false);
		quit_game_to_desktop()
	",

	settings_menu: "
	if(main_menu_combo,
	[
		set(level.show_builtin_settings_dialog, false),
		main_menu_combo.click_handler(main_menu_combo),
		cancel(),
	]

	)

	where main_menu_combo = find(level.chars, value is obj combo_label and value.grouping = 'back')

	",


	being_added: "return_to_main()",

	"+spawn_objects": "[
//		spawn_deck_summaries(),
	]",
	
	type_updated: "show_ui()",

	"+do_observe": "teleport('observation_lobby.cfg', '', 'fade', playable)
	    where playable = object_playable('observation_lobby_controller', 0, 0, 0, { client: tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT) })",
	
	"+do_mp_lobby": "teleport('matchmaking_lobby.cfg', '', 'fade', playable)
		where playable = object_playable('matchmaking_lobby_controller', 0, 0, 0, { _mm_client_state: _mm_client_state, selected_deck: selected_deck })
	",
	
	},

}
