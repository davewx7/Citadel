{
	"id": "card",

	is_strict: true,
	always_active: true,
//	mouse_drag_threshold: 5,

	types: {
		CostKey: "{
			card_size: decimal,
			base_cost: int,
			loyalty_cost: int,
			schools: [int],
			per_school: null|[int],
		}",
	},

	on_mouse_enter: "[
	  if(is_on_stack_and_targetable and controller is obj citadel_controller,
		controller.enter_targetable_card(me)
	  ),
	  if(mouse_enter_handler, mouse_enter_handler()),
	  if(in_opponent_hand and controller is obj citadel_controller, controller.mouse_enter_opponent_card(me)),
	  set(mouse_over, true),
	  if(in_ability, animate(me, { card_size: 1.6 }, { duration: 15 })),
	  if(in_victory and find(animated_movements, value = 'victory_card_move') = null, [
		animate(me, {
			mid_x: mid_x,
			mid_y: (mid_y + screen_height/2)/2,
			card_size: card_size*2,
			zorder: zorder+10,
		}, {
			duration: 10,
			name: 'card_move',
			replace_existing: true,
		}),

		set(_starting_state, {mid_x: mid_x, mid_y: mid_y, card_size: card_size, zorder: zorder})
		]),
	  if(is_choice and animated_movements = [], [
		lib.sound.play_sound(me, 'choice-mouseover-card'),
		show_halo(),
		]),
	]",

	on_mouse_leave: "[
	  if(mouse_leave_handler, mouse_leave_handler()),

	  if(is_on_stack_and_targetable and controller is obj citadel_controller,
		controller.leave_targetable_card(me)
	  ),

	  if(in_opponent_hand and controller is obj citadel_controller, controller.mouse_leave_opponent_card(me)),
	  set(mouse_over, false),
	  if(in_ability, animate(me, { card_size: 1.0 }, { duration: 15 })),
	  if(in_victory and _starting_state != null, [
		animate(me, {
			mid_x: _starting_state.mid_x,
			mid_y: _starting_state.mid_y,
			card_size: _starting_state.card_size,
			zorder: _starting_state.zorder,
		}, {
			duration: 10,
			name: 'victory_card_move',
			replace_existing: true,
		}),

		set(_starting_state, null)
	]),
	  if(is_choice, [
	    hide_halo(),
	  ]),
	]",

	on_drag_start: "if(ignore_clicks = false and not is_placeholder, [
		swallow_mouse_event(),
		if(allow_drag, [
			set(drag_pos, [mouse_x, mouse_y]),
			if('card_move' in animated_movements, animate(me, { mid_y_decimal: mid_y }, { duration: 0, name: 'card_move', replace_existing: true})),
		]),
		if(controller != null, controller.mouse_drag_card_start(me)),
	]
	 where mouse_x = lib.gui.mouse_pos(level)[0]
	 where mouse_y = lib.gui.mouse_pos(level)[1]
	)",

	on_drag: "if(ignore_clicks = false and not is_placeholder, [
	  swallow_mouse_event(),
	  if(drag_pos and allow_drag, [
		set(drag_pos, [mouse_x, mouse_y]),
		add(x, dx),
		add(y, dy),
		map(arrows, [set(value.start_point, [value.start_point[0] + dx, value.start_point[1] + dy]), fire_event(value, 'create')]),

	] where dx = mouse_x - drag_pos[0]
	  where dy = mouse_y - drag_pos[1]),
	  if(controller != null, controller.mouse_drag_card(me))
	]
	 where mouse_x = lib.gui.mouse_pos(level)[0]
	 where mouse_y = lib.gui.mouse_pos(level)[1]
	)",

	on_drag_end: "if(ignore_clicks = false and not is_placeholder, [
	  set(drag_pos, null),
	  if(controller != null, controller.mouse_drag_card_end(me)),
	])",

	on_click: "
	if(ignore_clicks or is_placeholder, null,
	click_handler != null, [
		swallow_mouse_event(),
		click_handler(),
	],
	hand_card_off_to_side, if(controller is obj citadel_controller, [
		controller.tile_clicked(null),
		swallow_mouse_event(),
	]),
	controller != null and (controller.paused = false or is_choice), [
		swallow_mouse_event(),
		if(is_choice and (choice_index is int),
		[
		   hide_halo(),
	       controller.option_clicked(choice_index, choice_value),
		],
	
	       switch(mouse_button, 
				1, controller.card_clicked(me),
				3, controller.card_right_clicked(me),
			null))
	])
	 where mouse_button = int<- arg.mouse_button",

	on_type_updated: "lib.citadel.card_cost_cache.clear(); lib.citadel.card_animation_cache.clear(); fire_event('render')",

	on_draw: "[
		set(scale, card_size/card_size_rendered)
	]",

	on_process: "[
	  if(_dirty, fire_event('render')),
	  set(brightness, if(highlight and level.cycle%50 < 25, 512, 255)),
	 ]",

	properties: {

		screen_width: "int :: level.dimensions[2] - level.dimensions[0]",
		screen_height: "int :: level.dimensions[3] - level.dimensions[1]",

		_x_fractional: { type: "decimal", default: 0.0 },
		_y_fractional: { type: "decimal", default: 0.0 },

		x_fractional_shader: "decimal :: _x_fractional",
		y_fractional_shader: "decimal :: _y_fractional",

		mid_x_decimal: { variable: false, type: "decimal", get: "mid_x + _x_fractional", set: "[set(mid_x, floor(value)), set(_x_fractional, value - floor(value))]" },
		mid_y_decimal: { variable: false, type: "decimal", get: "mid_y + _y_fractional", set: "[set(mid_y, floor(value)), set(_y_fractional, value - floor(value))]" },

		hue_shift_xdelta: { type: "decimal", init: "card_type.hue_shift_xdelta" },

		hue_shift: {
			type: "decimal",
			init: "
				if('hue_shift' in adjustments, decimal<- adjustments['hue_shift'], card_type.hue_shift)
		
				where adjustments = lib.citadel.card_adjustments[card_type.internal_id] or {}
			",
		},

		saturation_multiplier: {
			type: "decimal",
			init: "
				if('saturation_multiplier' in adjustments, decimal<- adjustments['saturation_multiplier'], 1.0)
		
				where adjustments = lib.citadel.card_adjustments[card_type.internal_id] or {}
			",
		},

		luminance_multiplier: {
			type: "decimal",
			init: "
				if('luminance_multiplier' in adjustments, decimal<- adjustments['luminance_multiplier'], 1.0)
		
				where adjustments = lib.citadel.card_adjustments[card_type.internal_id] or {}
			",
		},

		stretch_image_edges: "bool :: card_type.stretch_image_edges",

		ignore_clicks: { default: false },

		rarity: "int :: if(card_type is class card, card_type.rarity, 0)",

		arrows: { type: "[obj arrow]", default: [], set: "
		if(value != _data, [
			map(_data, remove_object(value)),
			map(value, add_object(value)),
			set(_data, value),
		])" },


		effect_alpha: { type: "decimal", default: 1.0 },

		image_grayscale: { type: "decimal", default: 0.0 },

		flip_card: {
			type: "decimal",
			default: 0.0,
			set: "[
				set(_data, value),
				if(val = 0.0, [
					set(uv_array, null),
					set(xy_array, null),
				], [
					set(uv_array, [0,0,1,0,1,1,0,1,0,0]),
					set(xy_array, [val,ypos, inv_value,-ypos, inv_value,1-ypos, val,1+ypos, val,ypos]),
				]),
			] where inv_value = 1.0 - val
			  where val = if(value < 0.5, value, 1.0 - value)
			  where ypos = sin(value*180.0)*0.1*if(value < 0.5, 1.0, -1.0)
			  ",
		},

		mouse_over: { default: false },
		click_handler: { type: "null|function()->commands" },

		mouse_enter_handler: { type: "null|function()->commands" },
		mouse_leave_handler: { type: "null|function()->commands" },

		_card_tips: { type: "[obj tip_dialog]", default: [] },
		_subcard_tips: { type: "[obj card]", default: [] },

		_starting_state: { type: "null|{mid_x: int, mid_y: int, card_size: decimal, zorder: int}" },


		_rules_text_width: "0.91",

		calculate_font_size: "def(int cur_size=16) ->int

		if(find(fragments, value.y + value.height > max_height) = null, cur_size, calculate_font_size(cur_size-1))
		
			  where fragments = c.markup_text(q(<font size=') + cur_size + q('>) + card_type.rules_text + q(</font>), _rules_text_width*300.0, -1.0)
			  where max_height = 90.0
			  where c = canvas()
		
		",

		show_card_tips: "def() ->commands execute(me, [
			clear_card_tips(),

			map(card_type.subcard_tips[:size(positions)],
				spawn('card', {
					card_type: lib.citadel.create_card(value),
					card_size: 1.5,
					show_shadow: true,
					mid_x: positions[index][0],
					mid_y: positions[index][1],
					zorder: me.zorder,
				}, [
					add(me._subcard_tips, [child]),
				])
			),

			map([{title: string, text: string }] :: card_type.rules_tips[size(card_type.subcard_tips):size(positions)],
				spawn('tip_dialog', {
					zorder: zorder+1,
					_tip: {
						key: 'tip',
						text: info.text,
						targets: [me],
					},
					_title: info.title,
					_has_close: false,
					_width: lib.gui.py(220),
					_height: lib.gui.py(120),

					x: positions[size(card_type.subcard_tips) + index][0],
					y: positions[size(card_type.subcard_tips) + index][1],
				}, [
					add(me._card_tips, [child]),
				])
				where info = {title: string, text: string} <- value
			)
		])
		where positions = filter(all_positions, find(exclusion_zones, xpos > value[0] and xpos < value[2] and ypos > value[1] and ypos < value[3]) = null where xpos = value[0] where ypos = value[1])
		where all_positions = [
			[x2 + lib.gui.py(180), y + lib.gui.py(60) + y_adj],
			[x2 + lib.gui.py(180), mid_y + y_adj],
			[x2 + lib.gui.py(180), y2 - lib.gui.py(60) + y_adj],
			[x - lib.gui.py(180), y + lib.gui.py(60) + y_adj],
			[x - lib.gui.py(180), mid_y + y_adj],
			[x - lib.gui.py(180), y2 - lib.gui.py(60) + y_adj],
		]
		   where y_adj = if(y2 > bottom_y, bottom_y - y2, 0)
		   where bottom_y = level.dimensions[3] - lib.gui.py(100)
		   where exclusion_zones = map(existing_tips, [value.x-lib.gui.py(110), value.y-lib.gui.py(60), value.x2+lib.gui.py(110), value.y2+lib.gui.py(60)])
		   where existing_tips = filter(level.chars, value is obj tip_dialog)",

		clear_card_tips: "def() ->commands [
			map(_card_tips, remove_object(value)),
			set(me._card_tips, []),

			map(_subcard_tips, remove_object(value)),
			set(me._subcard_tips, []),
		]",

		highlight: { default: false },

		play_sound: "def(string|null fname) ->commands
			if(fname != null, sound(fname, lib.sound.sound_volume(fname)))",

		_dirty: { type: "bool", default: true },

		_calculate_cost_key: "null|CostKey ::

		if(card_type.loyalty_cost > 0,
		{
			card_size: native_card_size(card_size),
			base_cost: _base_cost,
			loyalty_cost: card_type.loyalty_cost,
			schools: card_type.school_list,
			per_school: _loyalty_cost_per_school,
		})",

		_last_cost_key: { type: "null|CostKey" },

		//State to let us know if anything about the way the card would be
		//drawn has changed and the card needs re-rendering.
		_calculate_render_key: "{type: string, card_size: decimal}|{name: string, search: null|[string], card_size: decimal, unique_creature: null|string, dirty: int} ::
		if(is_placeholder, { type: 'place', card_size: card_size },
		   show_back, { type: 'back', card_size: card_size },
		   {
			  name: card_type.name,
			  search: search_string,
			  card_size: native_card_size(card_size),
			  unique_creature: card_type.unique_creature,
			  dirty: card_type.dirty_count,
		   }
		)
		",
		_last_render_key: { type: "{type: string, card_size: decimal}|{name: string, search: null|[string], card_size: decimal, unique_creature: null|string, dirty: int}|null" },
		card_needs_rerender: "_calculate_cost_key != _last_cost_key or _calculate_render_key != _last_render_key",
		card_needs_high_priority_rerender: "_calculate_cost_key != _last_cost_key",

		is_placeholder: { type: "bool", default: false, change: "set(_dirty, true)" },
		show_back: { type: "bool", default: false, change: "set(_dirty, true)" },

		search_string: { type: "null|[string]", change: "set(_dirty, true)" },
		highlight_search_terms: "def(string type, string text) ->string
			if(search_string = null, text,
				_highlight_search_terms_internal(text, search_string)
			)
		",

		_highlight_search_terms_internal: "def(string text, [string] terms) ->string
			if(terms = [], text,
				_highlight_search_terms_internal(regex_replace(text, '(^|>)([^<>]*)(' + terms[0] + ')([^<>]*)(<|$)', q($1$2<font tag='highlight'>$3</font>$4$5), ['icase']), terms[1:])
			)
		",

		set_show_back: "def(bool new_value) ->commands if(new_value != show_back, [
			set(_last_render_key, null),
			set(show_back, new_value),
			if(new_value, [
				fire_event('render'),
			]),
		])",

		flip_card_over: "def(bool new_value, int duration=20, decimal|null new_card_size=null) ->commands
		execute(me,
		if(new_value != show_back, [
			set(rotate, 0),
			schedule(duration/2, set_show_back(new_value)),
			set(flip_card, 1.0),

			animate(me, {
				flip_card: 0.0,
			}, {
				duration: duration,
				name: 'flip_card',
			}),
		])
		)",

		morph_into_creature: "def(obj creature creature, int ncycles) ->commands execute(me, [
			log(['MORPH', hud_alpha, translate_img, scale_img]),
			animate(me, {
				hud_alpha: 0.0,
				translate_img: [creature.calculate_image_translate_x, creature.calculate_image_translate_y],
				scale_img: creature.calculate_image_scale,
				card_size: if(controller is obj citadel_controller, card_size*decimal(controller.tile_width)/decimal(x2 - x), card_size),
			}, {
				duration: ncycles,
			})
		])",

		tooltips: { type: "[class tooltip_area]", default: [] },

		noise_texture: { type: "null|object" },

		stack_id: { type: "null|int" },
		stack_info: { type: "null|class message.play_card_base" },
		is_on_stack_and_targetable: { type: "bool", default: false },

		being_dragged: "bool :: drag_pos != null",
		drag_pos: { type: "null|Loc" },
		choice_index: { type: "null|int" },
		choice_value: { type: "null|int" },
		is_choice: { default: false },
		allow_drag: { default: false },

		tag: { type: "null|string" },
		in_victory: { default: false },
		in_hand: { default: false },
		hand_card_off_to_side: { default: false },
		parent_creature: { type: "null|class creature" },
		in_ability: { default: false },
		mandatory_play: { default: false },
		player_index: { default: null, type: "int|null" },
		in_graveyard: { default: false },
		in_opponent_hand: { default: false },
		hand_index: { type: "null|int" },

		controller: { type: "null|obj citadel_controller_base" },

		player: { type: "null|class player", change: "set(_dirty, true)" },

		clear_widget_tooltips: "def() -> commands set(tooltips, [])",

		add_widget_tooltip: "def(widget w, int x, int y) -> commands [
			if(w.tooltip != null, add(tooltips, [construct('tooltip_area', { area: map([(int<- x) + (int<- (widget<- w).x), y + w.y, w.w, w.h], int(value*size_ratio)), tooltip: w.tooltip})])),
			map(w.children, add_widget_tooltip(value, x + w.x, y + w.y)),
		] where size_ratio = card_size/2.0",

		create_tooltip_widget: "def(class tooltip_area tip) ->object
		widget(me, {
			type: 'dialog',
			id: 'ability_tooltip',
			alpha: 175,
			clear_backround_alpha: 120,
			padding: 0,
			frame_padding: [10,10],
			zorder: 2000,
			cursor:[10, 10],
			x: tip.area[0],
			y: tip.area[1] - 40,
			background_frame: 'empty_window',
			children: [
				{
					type: 'label',
					font: lib.font.regular_font,
					alpha: 255,
					size: 16,
					color: 'light_gray',
					text: tip.tooltip,
				}
			],
		})",

		start_fizzle_animation: "def() ->commands
		execute(me,
		[
			lib.sound.play_sound(me, card_type.sound_fizzle),
			map(arrows, animate(value, {
				arrow_alpha: 0,
			}, {
				duration: 20
			})),

			spawn('fizzle_effect', {
				card: me,
				zorder: zorder+10,
				mid_x: mid_x,
				mid_y: mid_y,
			}),

			schedule(30, remove_object(me)),
		])",

		_play_resolve_launch_anim: "def() ->commands
		if(card_type.resolve_launch != null,
			schedule(0, ;
				spawn(string<- card_type.resolve_launch['type'], {
					mid_x: me.mid_x,
					mid_y: me.mid_y,
					zorder: 10000,
				} + remove_from_map(card_type.resolve_launch, 'type')
				)
			)
		)
		",

		_play_resolve_impact_anim: "def([custom_obj] targets) ->commands
		if(size(targets) > 0 and card_type.resolve_impact != null,
			schedule(int<- (card_type.resolve_impact['delay'] or 10),
				spawn(string<- card_type.resolve_impact['type'], {
					mid_x: targets[0].mid_x,
					mid_y: targets[0].mid_y,
					zorder: 1000,
					targets: targets
				} + if(card_type.resolve_impact['args'] is map, map<- card_type.resolve_impact['args'], {}))
			)
		)
		",

		show_shadow: { type: "bool", default: true },

		start_resolve_animation: "def([custom_obj] targets) ->commands
		lib.sound.play_sound(me, card_type.sound_resolve);

		if(card_type.resolve_effect = 'fire',
		   start_fire_resolve(targets),

		   card_type.creature_object != null and size(targets) = 1,
		   execute(me, [
		   		animate(me, {
					mid_x: targets[0].mid_x,
					alpha: 0,
				}, {
					easing: lib.math.linear,
					duration: lib.animation_timings.card_cast_movement_time,
					on_complete: remove_object(me),
				}),

				animate(me, {
					mid_y: targets[0].mid_y,
				}, {
					easing: lib.math.ease_in_cubic,
					duration: lib.animation_timings.card_cast_movement_time,
				}),

				map(arrows, animate(value, {
					fade_out: 1.0,
				}, {
					duration: lib.animation_timings.card_cast_movement_time,
				})),
		   ]),

		   card_type.resolve_effect = 'popup',

		   execute(me,
			[
				if(controller != null, controller.reserve_animation_time('resolve', 30 + card_type.resolve_delay + card_type.resolve_animation_delay)),
				_play_resolve_launch_anim(),
			];

			schedule(card_type.resolve_delay, ; [
		  		animate(me, {
					hud_alpha: 0.0,
					alpha: 0,
					effect_alpha: 0,
				}, {
					duration: 10,
					on_complete: remove_object(me),
				}),

				map(arrows, animate(value, {
					//fade_out: 1.0,
					arrow_alpha: 0,
				}, {
					duration: 5
				})),

				_play_resolve_impact_anim(targets),
			])

		   ),

		   card_type.resolve_effect = 'impact' or card_type.resolve_effect = 'impact_no_shake',

		   execute(me,

			[
				if(controller != null, controller.reserve_animation_time('resolve', 30 + card_type.resolve_delay)),
				_play_resolve_launch_anim(),
			];

		   
		   schedule(card_type.resolve_delay, ; [
		  		animate(me, {
					hud_alpha: 0.0,
					alpha: 0,
					effect_alpha: 0,
				}, {
					duration: 10,
				}),


				if(card_type.resolve_projectile, ;
					spawn(string<- card_type.resolve_projectile['type'], {
						mid_x: me.mid_x,
						mid_y: me.mid_y,
						zorder: 10000,
						_card: me
					} + remove_from_map(card_type.resolve_projectile, 'type')
					)
				),

				if(card_type.resolve_num_particles,
					map(range(card_type.resolve_num_particles),
						schedule(floor(t), ; spawn(card_type.resolve_particle, me.mid_x, me.mid_y, {}))
						where t = 30.0*decimal(value)/decimal(card_type.resolve_num_particles)
					)
				),

		   		animate(me, {
					mid_x: targets[0].mid_x,
					card_size: 0.65,
				}, {
					easing: lib.math.linear,
					duration: 30,
					on_complete: remove_object(me),
				}),

				animate(me, {
					mid_y: targets[0].mid_y,
				}, {
					easing: lib.math.ease_in_cubic,
					duration: 30,
				}),

				map(arrows, animate(value, {
					//fade_out: 1.0,
					arrow_alpha: 0,
				}, {
					duration: 5
				})),

				if(card_type.resolve_effect = 'impact', schedule(30, if(controller is obj citadel_controller, controller.screen_shake(20, 30, 5)))),

				schedule(30, remove_object(me)),

				_play_resolve_impact_anim(targets),
		   ])),
		
			execute(me, [
		   		map(arrows, animate(value, {
					arrow_alpha: 0,
				}, {
					duration: 30
				})),
				spawn('entropia_launch', {
					zorder: me.zorder+10,
					mid_x: me.mid_x,
					mid_y: me.mid_y,
					scale: lib.gui.dpy(0.8),
				}),
				/*
				schedule(5, [set(shader.uniform_commands.resolve_cycle, {value: 1, increment: true}), set(me.effects[1].enabled, false)]),
				schedule(5, [set(effects[0].uniform_commands.resolve_cycle, {value: 1, increment: true})]),
				set(me.effects[1].enabled, true),
				*/
				schedule(20, remove_object(me)),
				if(controller != null, controller.reserve_animation_time('resolve', 50)),
			]) asserting shader
		)",

		start_fire_resolve: "def([custom_obj] targets) ->commands execute(me, [
			if(controller != null, [
				controller.reserve_card_resolve_time(170),
				controller.reserve_animation_time('card_fire_resolve', 50),
			]),
			//removed for now, investigate crashes and wait for
			//new merge of graphics branch from Krista.
			//spawn('card_particle_effect', 0, 0, { _card: me, zorder: zorder+10 }),
			map(range(101), schedule(value, [set(height_reduction_proportion, 1.0 - value/100.0), fire_event('render'), set(y, y)])),

//			map(targets,
//				spawn('fireball_effect', mid_x, mid_y, { zorder: zorder+10, _target: value })
//				),
		])",

		show_halo: "def() ->commands if(not halo_shown, [
			set(me.effects[1].enabled, true),
			set(shader_enabled_at, cycle),
			set(me.halo_shown, true),
		])",
		hide_halo: "def() ->commands if(halo_shown, [
			set(me.effects[1].enabled, is_castable),
			set(me.halo_shown, false),
		])",

		halo_shown: { default: false, type: "bool" },

		shader_enabled_at: { default: -1 },

		translate_img: {
			type: "[decimal,decimal]",
			default: [0.0,0.0],
		},

		scale_img: {
			type: "decimal",
			default: 1.0,
		},

		hud_alpha: {
			type: "decimal",
			default: 1.0,
		},

		img_zoom: {
			type: "decimal",
			default: 0.0,
		},

		img_target: {
			type: "[decimal,decimal]|null",
		},

		shader_img_target: "if(img_target != null, img_target, card_type.portrait_focus != null, card_type.portrait_focus, [0.5,0.5])",

		is_castable: {
			type: "bool",
			default: false,
			set: "[
				set(_data, value),
				set(me.effects[1].enabled, value or halo_shown),
			]",
		},

		keep: { default: false },

		render_scale: { type: "int", default: 2, variable: true },
		card_size: { type: "decimal", default: 2.0, set: "[
			if(_data and get_native_size(render_size(_data)) != get_native_size(render_size(value)),
				set(_dirty, true),
			),
			set(_data, value)
		]" },

		//the card size we actually have displayed right now.
		card_size_rendered: { type: "decimal", default: 2.0 },


		destroy: "def() ->commands [remove_object(me)]",

		animate_from: "def(obj card start, int ncycles) ->commands [
			set(card_size, start.card_size),
			set(mid_x, start.mid_x),
			set(mid_y, start.mid_y),
			set(rotate, start.rotate),
			animate(me, {mid_x: mid_x, mid_y: mid_y, rotate: me.rotate, card_size: me.card_size}, {duration: ncycles}),
			
		]",

		//card_type property which can be a card OR an activated_ability.
		card_type: {
		  type: "class card_base",
		  get: "_data", set: "execute(me, [

				set(_data, value), 
				fire_event('init')
			  ]) asserting value != null"
		},

		_actual_cost: "int ::
		  if(player != null,
			 player.calculate_cost(card_type),
			 card_type.cost + card_type.loyalty_cost)",

		_loyalty_cost_per_school: "null|[int] ::
		  if(player = null, null, map(card_type.school_list, min(card_type.loyalty_cost, player.get_resource_level(value))))
		",
		
		_loyalty_cost: "int ::
			if(player != null,
			   player.calculate_card_loyalty_cost(card_type),
			   card_type.loyalty_cost)
		",

		_base_cost: "int ::
			if(player != null,
			   player.calculate_card_base_cost(card_type),
			   card_type.cost)
		",
		
		render_size: "def(decimal size) ->[int,int] [round_to_even(lib.hex.width_from_height(height)), round_to_even(height)]
		 where height = size*154*(screen_height/900.0)",

		_native_render_sizes: "[[int,int]] :: map(lib.citadel.native_card_sizes, render_size(value))",

		image_texture_width: { default: 128 },
		image_texture_height: { default: 128 },

		img_aspect: "decimal(image_texture_width)/decimal(image_texture_height)",

		_has_dynamic_image: "bool :: true or (card_type.animation_sequence != [])",

		animated_card_info: { type: "null|class animated_card" },
		image_texture: { type: "null|texture_object" },

		has_image_texture: "bool :: image_texture != null",

		second_image_texture: { type: "null|texture_object" },
		has_second_image_texture: "bool :: second_image_texture != null",

		cost_texture: { type: "null|texture_object" },
		has_cost_texture: "bool :: cost_texture != null",

		height_reduction_proportion: { type: "decimal", default: 1.0 },

		precache_render: "def() ->commands
		map(lib.citadel.native_card_sizes[:size(lib.citadel.native_card_sizes)-1],
		if(lib.citadel.card_animation_cache.contains(render_key) = false,
		lib.citadel.card_animation_cache.store(render_key,
			_create_anim(_render_internal(canvas(), ww, hh), ww, hh)
		)
			where ww = actual_size[0]
			where hh = actual_size[1]
		    where actual_size = get_native_size(render_dim)
	  		where render_dim = render_size(value)
		)
		    where render_key = {
			  name: card_type.name,
			  search: null,
			  card_size: value,
		    }
		)
		",

		_create_anim: "def(texture_object tex, int ww, int hh) ->frame

			create_animation(
			{
				id: 'fbo',
				image: 'fbo',			
				force_no_alpha: false,
				fbo: tex,
				x: 0, y: 0, w: ww+2, h: round_to_even((hh+2)*height_reduction_proportion),
				scale: 1,
				frames: 1,
			})
		",

		_render_card_blocking: "def(decimal requested_card_size) ->commands
		(
			let render_key = _calculate_render_key;

			let tex = texture_object|null <- null;

			if(is_placeholder,
			   set(tex, _render_placeholder(c, ww, hh)),
			   show_back,
			   set(tex, _render_back(c, ww, hh)),

//			   let future = _render_internal(c, ww, hh);
//			   sleep_until(future.finished);
//			   set(tex, future.texture)

			   set(tex, _render_internal(c, ww, hh))
			) where c = canvas();

			let anim = _create_anim(texture_object<- tex, ww, hh);

			lib.citadel.card_animation_cache.store(render_key, anim);

			if(render_key = _calculate_render_key, [
				set(card_size_rendered, native_card_size(requested_card_size)),
				set(animation, anim),
			])
		)
			where ww = actual_size[0]
			where hh = actual_size[1]
		    where actual_size = get_native_size(render_dim)
	  		where render_dim = render_size(requested_card_size)
		",

		native_card_size: "def(decimal sz) ->decimal
		find_or_die(lib.citadel.native_card_sizes, value >= sz or index+1 = size(lib.citadel.native_card_sizes))
		",

		get_native_size: "def([int,int] sz) ->[int,int]
		  find_or_die(_native_render_sizes, value.x >= sz.x and value.y >= sz.y or index = size(_native_render_sizes)-1)",

		render_card_to_file: "def(decimal size, string fname='card.png') ->commands
			set(x, 0); set(y, level.dimensions[3] - img_h); set(upside_down, 1);
			texture([me], [0,0,img_w,img_h]).save(fname)
		",

		_render_placeholder: "def(cairo_callable c, int w, int h) ->texture_object
			c.render(w+2, h+2, [
			  c.translate(1, 1),
			  c.rectangle(0, 0, w, h),
			  c.clip(),
			  c.new_path(),

			  c.save(),
			  c.scale(decimal(w)/400.0),
			  c.paint_image('images/card-placeholder.png'),
			  c.restore(),

			  c.set_line_cap(enum round),
			  c.set_line_dashes([w * 0.02, w * 0.02]),

			  c.new_path(),
			  c.translate(w*0.02, h*0.02),
			  c.scale(0.96, 0.96),
			  c.move_to(w*0.25, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.line_to(w*1.0, h*0.5),
			  c.line_to(w*0.75, h*1.0),
			  c.line_to(w*0.25, h*1.0),
			  c.line_to(w*0.0, h*0.5),
			  c.line_to(w*0.25, h*0.0),
			  c.set_source_rgba(1, 1, 1, 0.5),
			  c.set_line_width(w * 0.015),
			  c.stroke(),
			], {
				filtering: 'bilinear',
				mipmaps: 2,
			})
		",

		_render_back: "def(cairo_callable c, int w, int h) ->texture_object
			c.render(w+2, h+2, [
			  c.translate(1, 1),
			  c.rectangle(0, 0, w, h),
			  c.clip(),
			  c.new_path(),

			  c.scale(decimal(w)/400.0),
			  c.paint_image('images/card-back.png'),
			], {
				filtering: 'bilinear',
				mipmaps: 2,
			})
		",

		_render_loading: "def(cairo_callable c, int w, int h) ->texture_object
			c.render(w+2, h+2, [
			  c.translate(1, 1),
			  c.rectangle(0, 0, w, h),
			  c.set_source_rgba(1,1,1,1),
			  c.fill(),
			])
		",

		_render_internal: "def(cairo_callable c, int w, int h, bool draw_image=false) ->texture_object
		instrument('card_render_internal',
		c.render(w+2, h+2, [

			  c.translate(1, 1),

			  c.move_to(w*0.25, h*0.0),
			  c.line_to(w*0.75, h*0.0),
			  c.line_to(w*1.0, h*0.5),
			  c.line_to(w*0.75, h*1.0),
			  c.line_to(w*0.25, h*1.0),
			  c.line_to(w*0.0, h*0.5),
			  c.clip(),
			  c.new_path(),

			  c.rectangle(0, 0, w, h),
			  c.set_source_rgba(1, 1, 1, 0.01),
			  c.fill(),


			  if(card_type.portrait != null and draw_image,
			  [

				c.save(),
				//c.rectangle(w*0.3, 0, w*0.4, h),

			  	c.translate(0.15*w, 0),
				//c.clip(),
				c.scale(w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),
				c.save(),
				c.rectangle(w*0.0, 0, w*0.301, h),

				c.clip(),
				c.scale(2.0*w*0.7/800.0, w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),

				c.save(),
				c.rectangle(w*0.699, 0, w*0.301, h),

				c.clip(),
				c.translate(-w*0.4, 0),
				c.scale(2.0*w*0.7/800.0, w*0.7/800.0),
			  	c.paint_image('images/portraits/' + card_type.portrait),

			    c.restore(),

				c.save(),
				c.rectangle(w*0, h*0.7, w, h*0.3),
				c.set_source_rgba(1, 1, 1, 0.5),
				c.fill(),

				c.restore(),
			  ]),

			  [
			  [
			  c.save(),
			  c.translate(w*0.78 - name_width, h*0.6),
			  scaling,
			  c.paint_image(namefield_name),
			  c.restore(),

			  c.save(),
			  c.translate(w*0.72 - name_width, h*0.6),
			  scaling,
			  c.paint_image(namefield_left_name),
			  c.restore(),

			  if(card_type.creature_object != null and card_type.creature_object.is_land = false, [
				  c.save(),
				  c.translate(w*0.750, h*0.415),
				  scaling,
				  c.paint_image(statlabel_name),
				  c.restore(),
			  ]),

			  c.save(),
			  scaling,
			  c.paint_image(bg_name),
			  c.restore(),

			  if(alt_school_name != null, [
			  	c.save(),
//				c.rectangle(0, 0, w/2, h),
//				c.clip(),
//				c.new_path(),

				c.set_linear_pattern(0, 0, w / (decimal(w)/decimal(img_dim[0])), 0, [
					{ offset: 0.0, red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0 },
					{ offset: 0.45, red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0 },
					{ offset: 0.55, red: 1.0, green: 1.0, blue: 1.0, alpha: 0.0 },
					{ offset: 1.0, red: 1.0, green: 1.0, blue: 1.0, alpha: 0.0 },
				]),

			  	scaling,
			  	c.paint_image(alt_bg_name, null, [enum mask]),
			  	c.restore(),
				  
			  ] where alt_bg_name = sprintf('images/card/%s_bg.png', alt_school_name)
			  ),
			  ]
			  where scaling = c.scale(decimal(w)/decimal(img_dim[0]), decimal(h)/decimal(img_dim[1]))
			  where img_dim = c.image_dim(bg_name)
			  where bg_name = sprintf('images/card/%s_bg.png', school_name)
			  where namefield_name = sprintf('images/card/%s_namefield.png', school_name)
			  where namefield_left_name = sprintf('images/card/%s_namefield_left.png', school_name)
			  where statlabel_name = sprintf('images/card/%s_statlabel.png', school_name),

			  //Name of the card

				map(fragments, [
					c.save(),
			  		c.translate(w*0.850 - name_width, h*0.605),
					if(value.tag is list and 'highlight' in value.tag,
						c.set_source_rgba(1, 0, 0, 1),
						c.set_source_rgba(0, 0, 0, 1)
					),
					value.path,
					c.fill(),
					c.restore(),
				])
			  ]
				   where rightmost = max(map(fragments, value.x + value.width)) or 0.0
			       where fragments = c.markup_text(q(<font weight='55' size='18'>) + highlight_search_terms('name', card_type.name) + q(</font>), {width: w*0.84, scale: scaling}),

/* -- XXX: MANA AREA
			  c.save(),
			  c.translate(0.740*w, 0.410*h),
			  c.move_to(0.113*w, 0.022*h),
			  c.line_to(0.182*w, 0.022*h),
			  c.line_to(0.214*w, 0.090*h),
			  c.line_to(0.182*w, 0.158*h),
			  c.line_to(0.113*w, 0.158*h),
			  c.line_to(0.081*w, 0.090*h),
			  c.restore(),
*/
			  c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
			  c.fill(),

			  //cost -- cards with no loyalty cost never change their
			  //cost and can have it written into the card.
			  if(card_type.loyalty_cost = 0, [
				  c.save(),

				  c.set_source_rgba(1, 1, 1, 1),
				  c.set_font(lib.font.get(67)),

				  [

				  if(drawn_cost > _base_cost,
					  c.set_source_rgba(1,0.6,0.6,1),
					 drawn_cost < _base_cost,
					  c.set_source_rgba(0.6,0.6,1,1),
					  c.set_source_rgba(1,1,1,1)
				  ),

				  c.set_font_size(36*scaling),
				  c.translate(if(drawn_cost >= 10, 0.862, 0.894)*w, 0.534*h),
				  c.text_path(str(drawn_cost)), 
				  c.fill(),

				  ] where drawn_cost = if(player, _actual_cost, _base_cost),

				  c.restore(),
			  ]),

			  if(card_type.creature_object != null and card_type.creature_object.is_land = false, [


				c.save(),

				c.translate(w*0.770, h*0.488),
				c.set_source_rgba(0, 0, 0, 1),
				c.set_font(lib.font.bold_font),
				c.set_font_size(24*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.attack), w*0.09, ['center']),
				c.fill(),

				c.translate(0.0, h*0.07),
				c.set_source_rgba(1, 1, 1, 1),
				c.set_font_size(24*scaling),
				c.text_path_in_bounds(str(card_type.creature_object.life), w*0.09, ['center']),

				c.fill(),

				c.restore(),

			  ]),

			  //XXX - artist
			  /*
			 if(card_type is class card and card_type.artist != null, [
			 	c.save(),
			 	c.translate(w*0.28, h*0.992),
			 	c.set_font(lib.font.get(lib.font.normal)),
			 	c.set_font_size(9*scaling),
			 	c.set_source_rgba(1, 1, 1, 1),
			 	(c.text_path_in_bounds('Art:' + card_type.get_artist.name, w*0.94, ['left']) asserting card_type.get_artist != null | [card_type.name, card_type.artist]),
			 	c.fill(),

			 	c.restore(),
			 ]),
			 */

			  [
			    c.save(),
			    c.translate(0.195*w, 0.720*h),
				c.scale(scaling),
			  	map(fragments, [

					if(value.tag is list and 'highlight' in value.tag,
						c.set_source_rgba(1, 0, 0, 1),
						c.set_source_color(value.color)
					),

					if(value.tag is list and 'circle' in value.tag, [
						c.save(),
						c.translate(value.y*0.55, 0.0),
						value.path,
						c.set_source_rgba(0.2, 0.2, 0.2, 1),
						c.arc(value.width*0.56,
						      -value.ascent + value.height/2,
							  value.height*0.45, 0, 3.15*2),
						c.fill(),
						c.restore(),

						c.set_source_rgba(1, 1, 1, 1),
					],
					value.tag is list and 'attack' in value.tag, [
						c.save(),
						c.translate(value.y*0.55, 0.0),
						c.rectangle(value.x, value.y, value.x_advance, value.height),
						c.set_source_rgba(1, 1, 1, 1),
						c.fill(),
						c.restore(),
					],
					value.tag is list and 'life' in value.tag, [
						c.save(),
						c.translate(value.y*0.55, 0.0),
						c.rectangle(value.x, value.y, value.x_advance, value.height),
						c.set_source_rgba(0.50, 0.09, 0.12, 1),
						c.fill(),
						c.restore(),

						c.set_source_rgba(1, 1, 1, 1),
					]),

					c.save(),
					c.translate(value.y*0.55, 0.0),
					value.path,
					c.fill(),
					c.restore(),

				]),
				c.restore(),
			  ]

			  where fragments = c.markup_text(q(<font color='#000000' size=') + rules_font_size + q('>) + highlight_search_terms('rules', card_type.rules_text) + q(</font>), _rules_text_width*300.0, -1.0),

			  //Type of the card
			  map(type_fragments, [
			  	c.save(),
			  	c.translate(w*0.16, h*0.665),
				if(value.tag is list and 'highlight' in value.tag,
					c.set_source_rgba(1, 0, 0, 1),
					c.set_source_rgba(0, 0, 0, 1)
				),
				value.path,
				c.fill(),
			  	c.restore(),
			  ])
			  where type_fragments = c.markup_text(q(<font weight='45' size=') + str(int(calculate_type_font_size()*scaling)) + q('>) + highlight_search_terms('type', _type_text) + q(</font>), w*0.94)

			  //c.clip(),

			  ], { filtering: 'bilinear', mipmaps:1, address_mode: ['clamp', 'clamp'] }

			  
		) 
		where name_width = min(w*0.54, max(name_dim.width, w*0.25))
        where name_dim = c.text_extents(lib.font.bold_font, 18*scaling, card_type.name)
		where text_color = c.set_source_rgba(card_type.text_color[0], card_type.text_color[1], card_type.text_color[2], 1)
		  where scaling = h/373.0

		  where school_color_gradient = def(decimal begin=0.0, decimal end=1.0) ->cairo_op switch(size(school_info),
				1, c.set_source_rgba(school_info[0].color[0], school_info[0].color[1], school_info[0].color[2], 1.0),
				2, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.4, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.6, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: end, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				]),
				3, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.25, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.40, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.60, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.75, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: end, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				]),
				4, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.15, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.30, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.45, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.60, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.75, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.90, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: end, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				]),
				5, c.set_linear_pattern(0, 0, w, 0,
				[
				{offset: begin, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.1, red: school_info[0].color[0], green: school_info[0].color[1], blue: school_info[0].color[2]},
				{offset: begin + (end-begin)*0.2, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.3, red: school_info[1].color[0], green: school_info[1].color[1], blue: school_info[1].color[2]},
				{offset: begin + (end-begin)*0.4, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.6, red: school_info[2].color[0], green: school_info[2].color[1], blue: school_info[2].color[2]},
				{offset: begin + (end-begin)*0.7, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: begin + (end-begin)*0.8, red: school_info[3].color[0], green: school_info[3].color[1], blue: school_info[3].color[2]},
				{offset: begin + (end-begin)*0.9, red: school_info[4].color[0], green: school_info[4].color[1], blue: school_info[4].color[2]},
				{offset: end, red: school_info[4].color[0], green: school_info[4].color[1], blue: school_info[4].color[2]},
				]),
			  )
		  where school_name = lower(school_info[0].name)
		  where alt_school_name = if(size(school_info) > 1, lower(school_info[1].name))
		  where school_info = map(card_type.school_list, lib.citadel.school_info[value])
		  where rules_font_size = query_cache(global_cache(2048), card_type.name, calculate_font_size(card_type.rules_text_font_size))
		)
		",

		_render_cost: "def(int ww, int hh, CostKey k) ->texture_object

		c.render(ww/4, int(hh*0.6), [
			
			c.translate(-ww*0.7 - 1, 0),

			  map(card_type.school_list,
				map(range(_loyalty_cost),
				[
					c.save(),
					c.translate((0.850 - 0.035*value - 0.07*school_index)*ww, (0.34 - 0.07*value)*hh),
					c.scale(ww/400.0),
			  		c.paint_image(sprintf('images/card/%s_devotion_%s.png', lower(school_info[school_index].name), if(player and player.get_resource_level(school) <= index, 'off', 'on'))),
					c.restore(),

					
				]
				) where school = value
				  where school_index = index
			  ),

			  c.fill(),

			  //cost
			  c.save(),

			  c.set_source_rgba(1, 1, 1, 1),
			  c.set_font(lib.font.get(67)),

			  [

			  if(drawn_cost > _base_cost,
				  c.set_source_rgba(1,0.6,0.6,1),
				 drawn_cost < _base_cost,
				  c.set_source_rgba(0.6,0.6,1,1),
				  c.set_source_rgba(1,1,1,1)
			  ),

			  c.set_font_size(36*scaling),
			  c.translate(if(drawn_cost >= 10, 0.872, 0.894)*ww, 0.534*hh),
			  c.text_path(str(drawn_cost)), 
			  c.fill(),

			  ] where drawn_cost = if(player, _actual_cost, _base_cost),

			  c.restore(),
		]
		  where school_info = map(card_type.school_list, lib.citadel.school_info[value]),
		
		{ filtering: 'bilinear', mipmaps:1, address_mode: ['clamp', 'clamp'] }
		)

		where c = canvas()
		where scaling = (hh-2)/373.0

		",

		_renderable_attributes: "def() -> [{icon: string, scaling: decimal, text: string, value: int|null, center_x: decimal, center_y: decimal}]
		  map([{icon: string, scaling: decimal, text: string, value: int|null}] <- attributes, value + {
			center_x: if(index < 3, 0.825, 0.64),
			center_y: 0.725 + 0.097*(index%3),
		  })
			where attributes = if(cr = null, [],
			if(cr.range >= 1,
			[{
				text: 'RANGE',
				value: cr.range,
				icon: 'range.svg',
				scaling: 1.2,
			}], []) +
			if(cr.move > 1,
			[{
				text: 'MOVE',
				value: cr.move,
				icon: 'walking-boot.svg',
				scaling: 1.2,
			}], []) +
			if(cr.armor != 0,
			[{
				text: 'ARMOR',
				value: cr.armor,
				icon: 'armor.svg',
				scaling: 1.2,
			}], []) +
		
		[{
			text: ability.text,
			icon: ability.icon,
			scaling: ability.scaling,
		  }
		  asserting ability != null
		  where ability = lib.citadel.ability_info[a] |
		  a <- cr.abilities, a in lib.citadel.ability_info
		])
		where cr = card_type.creature_object
		",

		calculate_type_font_size: "def() ->int 14",

		_type_text: "string :: regex_replace(card_type.type_text, '--', canvas().emdash)",

		animate_shard: "def(class animation.shard_damage_hint hint) ->commands
		lib.sound.play_sound(me, 'gameplay/spell_magic_missile_release');
		if(controller is obj citadel_controller,
		;
		if(target != null,
		execute(me,
		[
			controller.reserve_animation_time('shard', 28),
			set(effects[0].enabled, false),

			animate(me, {
				mid_x: target.mid_x,
				mid_y: target.mid_y,
				card_size: 0.7,
			}, {
				duration: 20,
				name: 'shard',
				replace_existing: false,
				on_complete: ;
					controller.screen_shake(4, 30, 5);
					lib.sound.play_sound(me, 'gameplay/spell_magic_missile_impact');
					if(target is obj creature, target.get_hit_animation(2),
					   target is obj player_avatar, [
					     target.flash_hit(),
						 if(lifebar != null,
							lifebar.set_life(lifebar.current_life - hint.damage)
						 )

						 where lifebar = if(controller is obj citadel_controller, controller.avatar_life[target.player_num])
					   ])
			}),

			animate(me, {
				alpha: 0,
			}, {
				duration: 5,
				name: 'shard',
				replace_existing: false,
			}),

		])
		) where target = if(hint.target_loc, find(level.chars, value is obj creature and value.creature_object.loc = hint.target_loc), find(level.chars, value is obj player_avatar and value.player_num = hint.target_player))
		)
		",
	},

	on_game_updated: "if(card_needs_rerender, fire_event('init'))",

	on_init: "[
		fire_event('render'),
		set(animated_card_info, if(_has_dynamic_image and card_type.animation_sequence, construct('animated_card', { card: me }))),
	]",

	on_render: "[
		set(_dirty, false),

		if(tex is frame,
		[
			set(card_size_rendered, native_card_size(card_size)),
		   set(animation, tex),
		],

		[
			_render_card_blocking(card_size),
		]
		)
		where tex = lib.citadel.card_animation_cache.get(_calculate_render_key),

		if(show_back or is_placeholder or _calculate_cost_key = null,
			set(cost_texture, null),

			if(cost_tex is texture_object,
			   set(cost_texture, cost_tex),

			; (
			   [
			   	set(cost_texture, tex),
				lib.citadel.card_cost_cache.store(_calculate_cost_key, tex),
			   ]

			   where tex = _render_cost(img_w, img_h, _calculate_cost_key)
			)
			)

			where cost_tex = lib.citadel.card_cost_cache.get(_calculate_cost_key)
		),

		set(_last_cost_key, _calculate_cost_key),
		
		set(image_texture, image_tex),
		set(second_image_texture, second_image_tex),
		if(image_tex, [
			set(image_texture_width, int<- image_tex.width),
			set(image_texture_height, int<- image_tex.height),
		]),
		set(_last_render_key, _calculate_render_key),
		set(translate_img, [translate_x,translate_y]),
		set(me.scale_img, scale_img),
	]
	  where image_tex = instrument('card_image_tex', if(is_placeholder = false and show_back = false and card_type.portrait,
	       query_cache(lib.gui.image_cache, image_path, get_texture({ image: image_path, filtering: 'bilinear', mipmaps: 4, surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE'] }))
		   where image_path = 'portraits/card-size/' + card_type.portrait
	  ))

	  where second_image_tex = if(is_placeholder = false and show_back = false and card_type.second_portrait,
	       query_cache(lib.gui.image_cache, image_path, get_texture({ image: image_path, filtering: 'bilinear', mipmaps: 4, surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE'] }))
		   where image_path = 'portraits/card-size/' + card_type.second_portrait
	  )

	  where translate_x = adjustments['translate_x'] or 0.0
	  where translate_y = adjustments['translate_y'] or 0.0
	  where scale_img = adjustments['scale'] or 1.0
	  where adjustments = lib.citadel.card_adjustments[card_type.internal_id] or {}
	",

	on_being_added: "[
	]",

	on_being_removed: "[
		clear_card_tips(),
		set(arrows, []),
	]",

	shader: {
		vertex: "
        uniform mat4 u_anura_mvp_matrix;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
		uniform int resolve_cycle;
		uniform float u_property_x_fractional_shader;
		uniform float u_property_y_fractional_shader;
        varying vec2 v_texcoord;
        void main()
        {
			vec4 fractional_pos = vec4(u_property_x_fractional_shader, u_property_y_fractional_shader, 0, 0);
            v_texcoord = a_anura_texcoord;
            gl_Position = u_anura_mvp_matrix * (a_anura_vertex + fractional_pos);
			if(resolve_cycle > 0) {
				if(v_texcoord[0] > 0.05) {
					gl_Position[0] += float(resolve_cycle)/400.0;
				} else {
					gl_Position[0] -= float(resolve_cycle)/400.0;
				}

				if(v_texcoord[1] > 0.05) {
					gl_Position[1] -= float(resolve_cycle)/200.0;
				} else {
					gl_Position[1] += float(resolve_cycle)/200.0;
				}
			}
        }
		",

		fragment: """
        uniform sampler2D u_anura_tex_map;
        uniform sampler2D u_property_image_texture;
		uniform bool u_property_has_image_texture;

        uniform sampler2D u_property_cost_texture;
		uniform bool u_property_has_cost_texture;

        uniform sampler2D u_property_second_image_texture;
		uniform bool u_property_has_second_image_texture;

		uniform int u_property_rarity;

		uniform float u_property_cycle;

		uniform vec2 u_property_translate_img;
		uniform float u_property_scale_img;
		uniform float u_property_alpha;
		uniform float u_property_image_grayscale;
		uniform float u_property_img_aspect;
		varying vec2 v_texcoord;
		uniform int resolve_cycle;
		uniform vec4 u_anura_sprite_area;
		uniform float u_property_rotate;

		uniform float u_property_hud_alpha;

		uniform float u_property_img_zoom;
		uniform vec2 u_property_shader_img_target;

		uniform float u_property_hue_shift;
		uniform float u_property_hue_shift_xdelta;
		uniform float u_property_saturation_multiplier;
		uniform float u_property_luminance_multiplier;

		uniform bool u_property_stretch_image_edges;

		vec3 rgb_to_hsv(vec3 c)
		{
			vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
			vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
			vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

			float d = q.x - min(q.w, q.y);
			float e = 1.0e-10;
			return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
		}

		vec3 hsv_to_rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}


		void main()
		{
			float sprite_area_width = u_anura_sprite_area[2] - u_anura_sprite_area[0];
			float sprite_area_height = u_anura_sprite_area[3] - u_anura_sprite_area[1];

			gl_FragColor = texture2D(u_anura_tex_map, v_texcoord);

			vec2 mana_center = vec2(0.911, 0.497);

			if(u_property_rarity > 0) {
				float dist_mana = (v_texcoord.x - mana_center.x)*(v_texcoord.x - mana_center.x)*1.2 + (v_texcoord.y - mana_center.y)*(v_texcoord.y - mana_center.y);
				float mana_radius = 0.066;
				if(dist_mana < mana_radius*mana_radius) {
					if(gl_FragColor.r < 0.2 && gl_FragColor.b > gl_FragColor.g*1.05 && gl_FragColor.b < gl_FragColor.g*1.4 && gl_FragColor.g > 0.3) {

						vec3 hsv = rgb_to_hsv(gl_FragColor.rgb);

						if(u_property_rarity == 1) {
							//uncommon (silver) card
							float r = (sin(u_property_cycle*0.06 + v_texcoord.x*30.0) + 1.0)*0.5;
							hsv[1] = 0.0;
							hsv[2] += r*0.2;
						} else {
							//rare (gold) card
							float r = (sin(u_property_cycle*0.06 + v_texcoord.x*30.0) + 1.0)*0.5;
							hsv[0] = mod(hsv[0] + 0.6, 1.0);
							hsv[1] -= max(0.0, hsv[2]*0.5 + r - 1.0);
							hsv[2] += (1.0 - hsv[2])*0.7*r;
						}

						gl_FragColor.rgb = hsv_to_rgb(hsv);
					}
				}
			}

			if(u_property_has_cost_texture && v_texcoord.x > 0.7 && v_texcoord.x < 0.95 && v_texcoord.y < 0.6) {
				vec4 cost_col = texture2D(u_property_cost_texture, vec2((v_texcoord.x - 0.7)*4.0, v_texcoord.y/0.6));
				gl_FragColor.rgb = mix(gl_FragColor.rgb, cost_col.rgb, cost_col.a);
				gl_FragColor.a = max(gl_FragColor.a, cost_col.a);
			}

			gl_FragColor[3] *= u_property_hud_alpha;

			float u = v_texcoord[0] / sprite_area_width;
			float v = v_texcoord[1] / sprite_area_height;

			float h_dist_center = abs(u - 0.5);
			float v_dist_center = abs(v - 0.5);

			float left_edge = abs(v - 0.5)*0.5 + 0.01;
			float right_edge = 1.0 - left_edge;
			bool in_area = u > left_edge && u < right_edge;

			if(u_property_has_image_texture && gl_FragColor[3] < 1.0 && v_texcoord[1] >= 0.02 && v_texcoord[1] <= 0.98 && in_area) {

				vec2 img_uv = v_texcoord*u_property_scale_img + vec2(u_property_translate_img[0]*sprite_area_width, u_property_translate_img[1]*sprite_area_height);

				vec2 main_uv = mix(img_uv, u_property_shader_img_target, u_property_img_zoom);

				if(main_uv[1] > 0.995) {
					main_uv[1] = 0.995 - (main_uv[1] - 0.995)*0.5;
				}

				vec2 uv = main_uv;

				if(u_property_stretch_image_edges) {
					uv[0] = (uv[0] - 0.15) / ((234.0/268.0)*u_property_img_aspect);
					if(uv[0] < 0.2) {
						uv[0] += (0.2 - uv[0])*0.3;
					} else if(uv[0] > 0.8) {
						uv[0] -= (uv[0] - 0.8)*0.3;
					}
				}

				if(uv[0] < 0.0) {
					uv[0] = -uv[0];
				} else if(uv[0] > 1.0) {
					uv[0] = 2.0 - uv[0];
				}

				vec4 result = vec4(0, 0, 0, 0);

				if(u_property_has_second_image_texture && v_texcoord[0] + (v_texcoord[1] - 0.5)*0.2 > 0.5) {
					result = texture2D(u_property_second_image_texture, uv);
				} else {
					result = texture2D(u_property_image_texture, uv);
				}

				if(u_property_image_grayscale > 0.0) {
					float avg = (result[0] + result[1] + result[2])/3.0;
					result[0] = mix(result[0], avg, u_property_image_grayscale);
					result[1] = mix(result[1], avg, u_property_image_grayscale);
					result[2] = mix(result[2], avg, u_property_image_grayscale);
				}

				if(u_property_hue_shift > 0.0 || u_property_saturation_multiplier != 1.0 || u_property_luminance_multiplier != 1.0) {
					vec3 hsv = rgb_to_hsv(result.rgb);
					hsv[0] = mod(hsv[0] + u_property_hue_shift, 1.0);
					if(u_property_hue_shift_xdelta != 0.0) {
						hsv[0] = mod(hsv[0] + u + u_property_hue_shift_xdelta*u_property_cycle/60.0, 1.0);
					}
					hsv[1] = hsv[1]*u_property_saturation_multiplier;
					hsv[2] = hsv[2]*u_property_luminance_multiplier;
					result.rgb = hsv_to_rgb(hsv);
				}

				if(gl_FragColor[3] < 0.02) {
					gl_FragColor[3] = 0.0;
				}

            	gl_FragColor.rgb = mix(result.rgb, gl_FragColor.rgb, gl_FragColor[3]);
				gl_FragColor[3] = 1.0;
			}

			if(resolve_cycle > 0) {
				gl_FragColor[3] *= 1.0 - float(resolve_cycle)/50.0;
			}

			gl_FragColor[3] *= u_property_alpha/255.0;
		}
		""",

		create: """[
			set(uniform_commands.resolve_cycle, 0),
		]""",
	},

	effects: [
	
	{
		name: "card_shadow",
		create: "[
			set(uniform_commands.resolve_cycle, 0),
			set(enabled, parent.show_shadow),
			set(attributes, [{name: 'a_texcoord'}, {name: 'a_position'}]),
			set(draw_mode, 'triangle_strip'),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			])),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			uniform float u_alpha;
			uniform int resolve_cycle;
			varying vec2 v_texcoord;
			void main()
			{
				gl_FragColor[0] = 0.0;
				gl_FragColor[1] = 0.0;
				gl_FragColor[2] = 0.0;
				gl_FragColor[3] = 0.5 - float(resolve_cycle)/100.0;

				float u = v_texcoord[0];
				float v = v_texcoord[1];

				float left_edge = abs(v - 0.5)*0.5;
				float right_edge = 1.0 - left_edge;

				float edge = 0.1;

				if(u < left_edge + edge) {
					float ratio = max(0, (u - left_edge)/edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(u > right_edge - edge) {
					float ratio = max(0, (right_edge - u)/edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v < edge) {
					float ratio = v/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v > 1.0 - edge) {
					float ratio = (1.0 - v)/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				gl_FragColor[3] *= u_alpha;
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		draw: "[
			set(uniform_commands.u_alpha, min(parent.effect_alpha, parent.alpha/255.0)),
			set(attribute_commands.a_position, float_array(
			rotate_rect(parent.mid_x, parent.mid_y, parent.rotate,
			[
				x1, y1, x2, y1, x1, y2, x2, y2
			])))
			   where x1 = parent.mid_x - img_w*0.4
			   where x2 = parent.mid_x + img_w*0.6
			   where y1 = parent.mid_y - img_h*0.4
			   where y2 = parent.mid_y + img_h*0.6
			   where img_w = parent.img_w*parent.scale
			   where img_h = parent.img_h*parent.scale,
		]",
	},

	{
		name: "card_halo",
		create: "[
			set(enabled, false),
			set(attributes, [{name: 'a_texcoord'}, {name: 'a_position'}]),
			set(draw_mode, 'triangle_strip'),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			])),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			uniform vec4 u_fractional_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x + u_fractional_pos[0], a_position.y + u_fractional_pos[1], 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			varying vec2 v_texcoord;
			uniform vec4 u_color;
			uniform float u_edge;
			uniform float u_alpha;
			void main()
			{
				gl_FragColor = u_color;

				float u = v_texcoord[0];
				float v = v_texcoord[1];

				float left_edge = abs(v - 0.5)*0.5;
				float right_edge = 1.0 - left_edge;

				if(u < left_edge + u_edge) {
					float ratio = max(0, (u - left_edge)/u_edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(u > right_edge - u_edge) {
					float ratio = max(0, (right_edge - u)/u_edge);
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v < u_edge) {
					float ratio = v/u_edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
					} else if(v > 1.0 - u_edge) {
					float ratio = (1.0 - v)/u_edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				gl_FragColor[3] *= u_alpha;
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		//TODO: There seems to be a one-frame lag between when the
		//a_position is updated and when it takes effect. Work out
		//why this is instead of using shader_enabled_at to delay
		//drawing by a frame.
		draw: "[
			set(uniform_commands.u_fractional_pos, [parent.x_fractional_shader, parent.y_fractional_shader, 0, 0]),

			set(uniform_commands.u_alpha, min(parent.effect_alpha, parent.alpha/255.0)),
			set(uniform_commands.u_edge, if(parent.halo_shown, 0.02, 0.02)),

			set(uniform_commands.u_color,
				if(parent.card_type.shadow,
					mix([0.0, 0.0, 0.0, 1.0], [0.761, 0.098, 0.098, 1.0], sin(level.cycle*4.0)*0.5 + 0.5),
					[1.0, 1.0, 1.0, 1.0])),

			set(attribute_commands.a_position, float_array(
			rotate_rect(
			parent.mid_x, parent.mid_y, parent.rotate,
			[
			   parent_x-border_size, parent_y-border_size,
			   parent_x2+border_size, parent_y-border_size,
			   parent_x-border_size, parent_y2+border_size,
			   parent_x2+border_size, parent_y2+border_size,
			]))) where parent_x = parent.mid_x - (parent.x2 - parent.x)*0.5*parent.scale
			     where parent_y = parent.mid_y - (parent.y2 - parent.y)*0.5*parent.scale
			     where parent_x2 = parent.mid_x + (parent.x2 - parent.x)*0.5*parent.scale
			     where parent_y2 = parent.mid_y + (parent.y2 - parent.y)*0.5*parent.scale
			     where border_size = if(parent.halo_shown, parent.img_w/50.0, parent.img_w/50.0),
		]",
	},

	],
}

