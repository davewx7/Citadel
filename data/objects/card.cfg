{
	is_strict: true,
	"animation": [

		{
			"id": "main",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

		{
			"id": "big",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},

	],
	"id": "card",

	always_active: true,

	on_drag_start: "[
		swallow_mouse_event(),
		if(allow_drag, set(drag_pos, [mouse_x, mouse_y]))
	]
	 where mouse_x = int<- arg.mouse_x
	 where mouse_y = int<- arg.mouse_y",

	on_drag: "[
	  swallow_mouse_event(),
	  if(drag_pos and allow_drag, [
		set(drag_pos, [mouse_x, mouse_y]),
		add(x, dx),
		add(y, dy),
		map(draw_primitives, set(value.points,
		       [[points[0][0] + dx, points[0][1] + dy]] +
			   points[1:] where points = [[int]]<- value.points)),
	] where dx = mouse_x - drag_pos[0]
	  where dy = mouse_y - drag_pos[1])
	]
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",
	on_drag_end: "[swallow_mouse_event(), if(allow_drag, set(drag_pos, null))]",

	on_click: "[
		debug('click card: ' + hand_index),
		swallow_mouse_event(),
		if(is_choice,
	       controller.option_clicked(choice_value),
	[
	 switch(mouse_button,
	  1, controller.card_clicked(me),
	  3, controller.card_right_clicked(me))
	])
	] where mouse_button = int<- arg.mouse_button",

	//mouseover_delay: 20,
	on_mouse_enter: "controller.mouse_enter_card(me)",
	on_mouse_leave: "[
		controller.mouse_leave_card(me),
		if(me.widgets.ability_tooltip, [set(me.widgets.ability_tooltip, null)]),
	]",

	on_mouse_move: "if(in_hand and tip != null, [
		set(me.widgets.child, create_tooltip_widget(tip)),
	],
	if(me.widgets.ability_tooltip, [set(me.widgets.ability_tooltip, null)])
	)
	  where tip = class tooltip_area|null<-
	    find(tooltips, value.point_in_area(xpos, ypos))
	  where xpos = mouse_x - x
	  where ypos = mouse_y - y
	  where mouse_x = int<- arg.mouse_x
	  where mouse_y = int<- arg.mouse_y",

	on_animate_draw: "if(hand_index != null, animate_draw(hand_index*10))",

	properties: {
		tooltips: { type: "[class tooltip_area]", default: [] },

		noise_texture: { type: "null|object" },

		buttons_widget: { type: "null|obj card.keep_button" },
		do_not_remove: false, //this object is removing itself so don't remove it otherwise.

		stack_id: { type: "null|int" },

		drag_pos: { type: "null|Loc" },
		choice_value: { type: "null|int|string" },
		is_choice: false,
		sent_discard_msg: false,
		allow_drag: false,

		creature: { type: "null|obj creature" },
		
		in_hand: false,
		discarded: false,
		hand_index: { type: "null|int" },
		_keep_label: { type: "null|obj card.keep_label" },

		controller: { type: "obj citadel_controller_base" },

		player: { type: "null|class player" },

		clear_widget_tooltips: "def() -> commands set(tooltips, [])",

		add_widget_tooltip: "def(widget w, int x, int y) -> commands [
			if(w.tooltip != null, add(tooltips, [construct('tooltip_area', { area: map([(int<- x) + (int<- (widget<- w).x), y + w.y, w.w, w.h], int(value*size_ratio)), tooltip: w.tooltip})])),
			map(w.children, add_widget_tooltip(value, x + w.x, y + w.y)),
		] where size_ratio = card_size/2.0",

		create_tooltip_widget: "def(class tooltip_area tip) ->object
		widget(me, {
			type: 'dialog',
			id: 'ability_tooltip',
			alpha: 175,
			clear_backround_alpha: 120,
			padding: 0,
			frame_padding: [10,10],
			zorder: 2000,
			cursor:[10, 10],
			x: tip.area[0],
			y: tip.area[1] - 40,
			background_frame: 'empty_window',
			children: [
				{
					type: 'label',
					font: 'RobotoCondensed-Regular',
					alpha: 255,
					size: 16,
					color: 'light_gray',
					text: tip.tooltip,
				}
			],
		})",

		start_fizzle_animation: "def() ->commands set(shader.uniform_commands.fizzle_cycle, {value: 1, increment: true}) asserting shader",
		start_resolve_animation: "def() ->commands execute(me, [
			schedule(5, [set(shader.uniform_commands.resolve_cycle, {value: 1, increment: true}), set(me.effects[0].enabled, false)]),
			set(me.effects[0].enabled, true),
		]) asserting shader",

		show_halo: "def() ->commands if(not effects[0].enabled, [
			add(me.zorder, 5),
			set(me.effects[0].enabled, true),
		])",
		hide_halo: "def() ->commands if(effects[0].enabled, [
			add(me.zorder, -5),
			set(me.effects[0].enabled, false),
		])",

		show_keep_button: "def() ->commands execute(me, [hide_keep_button(),  spawn('card.keep_button', mid_x-24, int(mid_y+80*card_size), { facing: facing, parent_card: me }, [set(buttons_widget, child)])])",
		hide_keep_button: "def() ->commands [execute(me, if(buttons_widget, [remove_object(buttons_widget), set(buttons_widget, null)])), hide_halo()]",

		toggle_keep: "def() ->commands if(me._keep_label, [set(me._keep_label, null), remove_object(me._keep_label)], spawn('card.keep_label', mid_x+30, mid_y, facing, [set(me._keep_label, child)]))",

		marked_as_keep: "bool<- me._keep_label != null",

		render_scale: 2,
		card_size: 2.0,

		destroy: "def() ->commands [if(me._keep_label, remove_object(me._keep_label)), if(buttons_widget, remove_object(buttons_widget)), if(creature, creature.destroy()), set(buttons_widget, null), set(creature, null), remove_object(me)]",
		animate_draw: "def(int nstagger) ->commands execute(me, [
			set(me.x, -1000), //hack hack! Take it off screen until schedule starts
			set(me.y, -1000),
			map(range(26), schedule(nstagger + value, [
				set(me.x, x + index*(nstagger/10 - 2)),
				set(me.y, y - index*10),
				set(me.alpha, min(255, value*20)),
			] where index = 25 - value)),
		])",

		set_discarded: "def(bool val) ->commands [if(val,
		  execute(me, [set(discarded, true)]),
		  execute(me, [set(discarded, false)])),
		  debug('SET DISCARDED ' + val),
		  set(me.red, col),
		  set(me.green, col),
		  set(me.blue, col),
		] where col = if(val, 32, 255)
		  ",


		//card_type property which can be a card OR an activated_ability.
		card_type: {
		  type: "class card_base",
		  get: "_data", set: "execute(me, [
			if(creature_obj, [
					set(creature, child), 
				]
				where child = object('creature', if(creature_obj.sprite_sheet = 'creature_large', 180, 80)*render_scale, 52*render_scale, 1,
				  {
					zorder: zorder+5,
					controller: controller,
					creature_object: creature_obj
				  })
				) where creature_obj = if(value._class != 'activated_ability', value.creature_object),
				set(_data, value), 
				fire_event('init')
			  ]) asserting value != null"
		},
	},

	on_toggle_keep: "toggle_keep()",

	on_init: "[
		if(marked_as_keep, [fire_event('toggle_keep'), fire_event('toggle_keep')]),
		[
			set(render_obj.draw_primitives,
			  map(card_type.runes, {type: 'arrow', texture: 'ink.png', texture_scale: 0.2, arrow_head_width: 0.25, fade_in_length: 10, width_base: 10.0, width_head: 10.0, arrow_head_length: 40} + value + {points: if(size(p) = 2, p + [p[1]], p) where p = map([[int]]<- value.points, [value[0]*2 + 50, value[1]*1.4 + 70])})),
			set(render_obj.parent, me),
			fire_event(render_obj, 'init'),
			fire_event('render', {render_obj: render_obj}),
		]
		where render_obj = object_playable('card.render', img_w/2, img_h/2, 1),
	]",

	on_render: "[
		set(animation, {
			id: 'fbo',
			image: 'fbo',
			fbo: texture([render_obj], [0,0,145*render_scale,203*render_scale]),
			x: 0,
			y: 0,
			w: 145*render_scale,
			h: 203*render_scale,
			scale: card_size/2.0,
			frames: 1,
			duration: -1
		}),

		clear_widget_tooltips(),
		map(render_obj.widget_list, add_widget_tooltip(value, 0, 0)),
	] where render_obj = custom_obj<- arg.render_obj",

	object_type: [
	{
		id: "keep_button",
		hidden_in_game: true,

		properties: {
			parent_card: { type: "obj card" }
		},

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			frames: 1,
		},

		on_spawned: "[set(zorder, spawner.zorder+10), set(parent_card, obj card<- spawner)] where spawner = custom_obj <- arg.spawner",

		on_create: "set_widgets([{
			type: 'grid',
			columns: 2,
			children: [
			{
				type: 'button',
				resolution: 'normal',
				label: {type: 'label', text: 'Keep', font: 'RobotoCondensed-Bold', color: 'antique_white'},
				on_click: def() [if(parent_card.discarded, parent_card.controller.card_clicked(parent_card)), parent_card.toggle_keep()],
			},
			{
				type: 'button',
				resolution: 'normal',
				label: {type: 'label', text: 'Discard', font: 'RobotoCondensed-Bold', color: 'antique_white'},
				on_click: def() parent_card.controller.card_right_clicked(parent_card),
			}
			]
		}])",
	},

	{
		id: "keep_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			frames: 1,
		},

		on_spawned: "set(zorder, spawner.zorder+100)
		  where spawner = custom_obj<- arg.spawner",

		on_create: "set_widgets([{
			type: 'label',
			text: 'Keep',
			font: 'RobotoCondensed-Bold',
			align_h: 'center',
			color: 'antique_white',
			size: 42
		}])",
	},

	{
		id: "render",
		is_strict: true,
		is_human: true,

		animation: [{
			"id": "main",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 1
		},
		{
			"id": "big",
			"image": "card-silver.png",
			"rect": [0,0,145,203],
			scale: 2
		}
		],

		properties: {
			parent_card: "obj card<- parent",
			card_type: "class card_base<- parent_card.card_type",
			render_scale: "int<- parent_card.render_scale",
			left_color: [1.0,1.0,1.0,1.0],
			right_color: [1.0,1.0,1.0,1.0],
		},

		on_process: "console_output_to_screen(false)",

		on_init: "[
		[
			if(parent_card.render_scale = 2, set(animation, 'big')),
			set(left_color, school_colors[0]),
			set(right_color, school_colors[size(school_colors)-1]),
		] where school_colors = map(school, [value.red, value.green, value.blue, 1.0])
		  where school = map(card_type.school, lib.citadel.school_info[value]),
		set_widgets([{
			type: 'rich_text_label',
			width: 120*render_scale,
			x: 14*render_scale,
			y: 126*render_scale,
			claim_mouse_events: false,
			children: card_type.rules_text_widgets(render_scale) asserting card_type.rules_text_widgets | [card_type.rules_text_widgets, card_type.type, card_type],
			zorder: 11
		},
	  {
		 type: 'rich_text_label',
		 width: 132*render_scale,
		 align: 'right',
		 x: 1*render_scale,
		 y: 6*render_scale,
	     zorder: 10,
		 children:
	  map(card_type.school,
	   map(range(card_type.loyalty_cost),
	       singleton('gui_widgets').resource_image(value, 9*render_scale) + {alpha: if(parent_card.player and parent_card.player.resource_level[value] > index, 96, 255)})) +
		   [
		   	  {
				  type: 'label',
				  color: 'black',
				  size: render_scale*14,
				  font: card_type.card_font,
				  text: '' + card_type.cost,
			  }
		   ]
		
	  }] +

	  if(parent_card.creature, [{
		type: 'object',
		object: parent_card.creature,
		claim_mouse_events: false,
	  }], [])
	  
	  ),

	 if(render_scale in [1,2],

	  [textv(me, {text: card_type.name, align: 'left', color: 'black', size: if(render_scale = 1, 12, 18), rect: [12*render_scale, 9*render_scale, 120*render_scale, 20*render_scale], font:'RobotoCondensed-Light'},

		   if(creature_object != null,
				   {text: if(card_type.hero, 'Hero -- ', if(creature_object.is_construct, 'Construct -- ', 'Creature -- ')) + fold(creature_object.tags, a + ' ' + b, ''), align: 'left', color: 'black', size: if(render_scale = 1, 10, 14), rect: [15*render_scale, 115*render_scale, 180*render_scale, 130*render_scale], font:'RobotoCondensed-LightItalic'},
				   {text: if(card_type._class = 'card', 'Spell', 'Ability') + if(card_type.is_response, ' -- Response', ''), align: 'left', color: 'black', size: if(render_scale = 1, 10, 14), rect: [15*render_scale, 115*render_scale, 180*render_scale, 130*render_scale], font:'RobotoCondensed-LightItalic'},
				   ),
			if(creature_object != null,
		   {text: str(creature_object.attack) + '/' + creature_object.life, align: 'left', color: 'black', size: if(render_scale = 1, 14, 18), rect: [110*render_scale, 178*render_scale, 40*render_scale, 30*render_scale], font:'RobotoCondensed-LightItalic'}))],
	
	  //otherwise render_scale = 2
	  [textv(me, {text: card_type.name, align: 'left', color: 'black', size: 18, rect: [-48, -80, 300, 20], font:'RobotoCondensed-Regular'},
		   if(creature_object != null,
				   {text: if(card_type.hero, 'Hero -- ', if(creature_object.is_construct, 'Construct -- ', 'Creature -- ')) + fold(creature_object.tags, a + ' ' + b, ''), align: 'left', color: 'black', size: 14, rect: [-46, 128, 300, 180], font:'RobotoCondensed-Italic'},
				   {text: 'Spell' + if(card_type.is_response, ' -- Response', ''), align: 'left', color: 'black', size: 14, rect: [-46, 130, 300, 180], font:'RobotoCondensed-Italic'},
				   ),
			if(creature_object != null,
		   {text: str(creature_object.attack) + '/' + creature_object.life, align: 'left', color: 'black', size: 18, rect: [156, 262, 40, 30], font:'RobotoCondensed-Italic'}))]
	),
	] where creature_object = if(card_type._class != 'activated_ability', card_type.creature_object)",

		shader: {
			name: "card_render",
			create: "[
				set(uniform_commands.u_left_color, parent.left_color),
				set(uniform_commands.u_right_color, parent.right_color),
			]",

			draw: "[
				bind_texture(current_texture, 0),
			]",

			vertex: "
				uniform mat4 u_mvp_matrix;
				attribute vec4 a_position;
				attribute vec2 a_texcoord;
				varying vec2 v_texcoord;
				varying vec2 v_cardcoord;
				void main()
				{
					v_texcoord = a_texcoord;
					gl_Position = u_mvp_matrix * a_position;
					v_cardcoord = vec2(0.0, 0.0);
					if(a_texcoord[0] > 0.5) {
						v_cardcoord[0] = 1.0;
					}

					if(a_texcoord[1] > 0.5) {
						v_cardcoord[1] = 1.0;
					}
				}
			",

			fragment: "
				uniform sampler2D u_tex_map;
				uniform vec4 u_left_color;
				uniform vec4 u_right_color;
				varying vec2 v_texcoord;
				varying vec2 v_cardcoord;
				void main()
				{
					gl_FragColor = texture2D(u_tex_map, v_texcoord);

					vec4 color = u_left_color;
					if(v_cardcoord[0] > 0.4) {
						if(v_cardcoord[0] > 0.6) {
							color = u_right_color;
						} else {
							float ratio = (v_cardcoord[0] - 0.4)*5.0;
							color = u_right_color*ratio + u_left_color*(1.0-ratio);
						}
					}

					gl_FragColor = gl_FragColor * (color/2.0 + vec4(0.5,0.5,0.5,0.5));
				}
			",

			attributes: {
				vertex: "a_position",
				texcoord: "a_texcoord",
			},

			uniforms: {
				mvp_matrix: "u_mvp_matrix",
			},
		},
	},
	],

	shader: {
		program: "card",
		create: "[
			set(uniform_commands.u_tex_map, 0),
			set(uniform_commands.u_tex_noise, 1),
			set(uniform_commands.fizzle_cycle, 0),
			set(uniform_commands.resolve_cycle, 0),
			set(parent.noise_texture, load_texture('images/noise.png')),
		]",

		draw: "[
			set(uniform_commands.u_color, color),
			bind_texture(current_texture, 0),
			bind_texture(parent.noise_texture.id, 1),
		]",
	},

	effects: [{
		name: "card_halo",
		create: "[
			set(enabled, false),
			set(attribute_commands.a_texcoord, float_array([
			   0.0, 0.0,
			   1.0, 0.0,
			   0.0, 1.0,
			   1.0, 1.0,
			], 2)),
		]",

		vertex: "
			uniform mat4 u_mvp_matrix;
			uniform vec4 u_parent_pos;
			attribute vec2 a_position;
			attribute vec2 a_texcoord;
			varying vec2 v_texcoord;
			void main()
			{
				v_texcoord = a_texcoord;
				vec4 v = vec4(a_position.x, a_position.y, 0.0, 1.0);
				gl_Position = u_mvp_matrix * v;
			}",

		fragment: "
			varying vec2 v_texcoord;
			void main()
			{
				gl_FragColor[0] = 1.0;
				gl_FragColor[1] = 1.0;
				gl_FragColor[2] = 1.0;
				gl_FragColor[3] = 1.0;

				float edge = 0.1;

				if(v_texcoord[0] < edge) {
					float ratio = v_texcoord[0]/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v_texcoord[0] > 1.0 - edge) {
					float ratio = (1.0 - v_texcoord[0])/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}

				if(v_texcoord[1] < edge) {
					float ratio = v_texcoord[1]/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				} else if(v_texcoord[1] > 1.0 - edge) {
					float ratio = (1.0 - v_texcoord[1])/edge;
					gl_FragColor[3] = gl_FragColor[3]*ratio;
				}
			}
		",

		"uniforms": {
			"mvp_matrix": "u_mvp_matrix",
		},
		
		draw: "[
			set(attribute_commands.a_position, float_array([
			   parent.x-border_size, parent.y-border_size,
			   parent.x2+border_size, parent.y-border_size,
			   parent.x-border_size, parent.y2+border_size,
			   parent.x2+border_size, parent.y2+border_size,
			], 2)) where border_size = parent.img_w/10.0,
			draw_arrays('triangle_strip', 0, 4),
		]",
	}],
}
