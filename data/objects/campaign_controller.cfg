{
	id: "campaign_controller",
	is_human: true,
	hitpoints: 20,
	editor_info: { category: "player" },
    hidden_in_level: true,
    use_absolute_screen_coordinates: true,
	
	is_strict: true,

	types: {
		Deck: "class deck",
		DeckMap: "{string -> Deck}",
		Scenario: "{id: string, x: int, y: int, image_num: int, name: string, bot_type: string, prerequisites: [string]}",
		ScenarioMap: "{string -> Scenario}",
	},

	consts: {
		FONT: "RobotoCondensed-Regular",
		FONT_COLOR: "antique_white",
	},
	
    properties: {
		level_width: "int :: level.dimensions[2]",
		level_height: "int :: level.dimensions[3]",

		scale_x: "def(decimal x) -> decimal
		  x * ((level_width)/1024.0)",

		scale_y: "def(decimal y) -> decimal
		  y * ((level_height)/768.0)",

		doc: "ScenarioMap<- fold(map(lib.json.get_document_map('data/campaign.cfg'), {(key): (map<- value) + {id: key}}), a+b)",

		progress: { type: "map",
		            get: "_data or if(is_map(doc), doc, {}) where doc = get_document('campaign-progress.cfg', ['null_on_failure', 'user_preferences_dir'])",
					set: "[set(me._data, value),
					       write_document('campaign-progress.cfg', value)]",
					default: {},
		},

		defeated_levels: {
			type: "[string]",
			get: "progress.defeated_levels or []",
			set: "set(me.progress, me.progress + {defeated_levels: value})",
			default: [],
		},

		deck_list: "DeckMap<- get_document('user-decks.cfg', ['null_on_failure', 'user_preferences_dir']) or get_document('data/default-user-decks.cfg')",

		selected_deck: { get: "if(_data, _data, keys(deck_list)[0])", type: "class deck|null", default: null },

		encounter_dialog: { type: "dialog|null", default: null },
		encounter_dialog_config: { type: "map|null", default: null },

		next_session: 1,

		client: { type: "object", init: "tbs_client('localhost', 23456)" },

		current_level_info: { type: "null|Scenario", default: null },

		play: "def(Scenario info) ->commands execute(me, [
			add(me.next_session, 2),
			set(me.current_level_info, info),
			tbs_send(client, {
				type: 'create_game',
				game_type: 'citadel',
				users: [
				{
					user: USERNAME or 'player',
					session_id: next_session,
				},
				{
					user: info.name,
					session_id: next_session+1,
					bot: true,
					bot_type: info.bot_type,
				},
				],
			})
		])",

		show_dialog: "def(map info) ->commands [
		  set(me.widgets, [new_dialog]),
		  set(me.encounter_dialog, new_dialog),
		  set(me.encounter_dialog_config, info),
		]
		  where new_dialog = dialog<- widget(me, {
			type: 'dialog',
			id: 'encounter_dialog',
			rect: [scale_x(700), scale_y(200), scale_x(300), scale_y(300)],
			alpha: 0,
			background_alpha: 255,
			background_frame: 'empty_window',
			upscale_frame: false,
			cursor: [10, 10],
			children: [
			{
				type: 'label',
				text: info.name,
				font: FONT,
				size: scale_x(28),
				align_h: 'left',
				color: 'white',
				x: scale_x(10),
				y: scale_y(10),
			},

			{
				type: 'button',
				label: {type: 'label', font: FONT, size: 18, color: FONT_COLOR, text: 'Play!'},
				on_click: bind(play, info),

				align_h: 'left',
				x: scale_x(10),
				y: scale_y(60),
			},

			{
				type: 'button',
				label: {type: 'label', font: FONT, size: 18, color: FONT_COLOR, text: 'Deck Builder'},
				on_click: def() [
				  set(playable.exit_commands, [teleport('campaign.cfg', '', 'fade', me)]),
				  teleport('deck-builder.cfg', '', 'fade', playable)
				]
				   where playable = object_playable('deck_builder_controller', 0, 0, 0),
				align_h: 'left',
			},

			if(deck_list, make_deck_grid(deck_list)),
			],
		  })
		",

		make_deck_grid: "def(DeckMap user_decks) ->widget
		widget(me, {
			type: 'grid', 
			allow_selection: true,
			draw_selection_highlighted: true,
			id: 'deck_grid',
			columns: 1,
			column_widths: 150,
			max_height: 100,
			default_select: if(size(user_decks), 0, -1),
			children: make_deck_list(user_decks),
			on_select: def(selection) if(selection >= 0 and me.deck_list, set(me.selected_deck, me.deck_list[selection])),
		})",

		make_deck_list: "def(DeckMap user_decks) ->[widget]
		map(user_decks, widget(me, {
			type: 'grid', 
			columns: 2,
			column_alignments: ['left', 'right'],
			column_widths: 100,
			children: [{
				type:'label', 
				font: FONT, 
				size: 16, 
				color: FONT_COLOR, 
				text: value.name
			}, {
				type: 'grid',
				columns: size(value.schools),				
				children: map(value.schools, make_school_icon(value)),
			}],
		}))",

		make_school_icon: "def(int school) ->widget switch(school, 
			// Colorless -- mana only
			0, widget(me, {type: 'label', text:'Mana', font: FONT, color: FONT_COLOR, size: 14}),
			// gold
			1, widget(me, {type:'image', image:'magic-icons.png', area:[3,3,18,18]}),
			// blood
			2, widget(me, {type:'image', image:'magic-icons.png', area:[20,3,35,18]}),
			// food
			3, widget(me, {type:'image', image:'magic-icons.png', area:[37,3,52,18]}),
			// scrolls
			4, widget(me, {type:'image', image:'magic-icons.png', area:[54,3,69,18]}),
			// faith
			5, widget(me, {type:'image', image:'magic-icons.png', area:[71,3,86,18]})) 
			asserting school >= 0 and school <= 5",
    },

	on_process: "[
		if(client, tbs_process(client)),
		if(encounter_dialog and encounter_dialog.background_alpha < 250, add(encounter_dialog.alpha, 25))
	]",
	

	on_message_received: "[
		if(message.type = 'game_created', [
			teleport('level1.cfg', '', 'fade', playable)
			  where playable =
		object_playable('citadel_controller', 336, 372, 0,
		  {
			game_server_address: 'localhost',
			game_server_port: 23456,
			session_id: next_session-2,
			game_created: true,
			selected_deck: selected_deck.name,
			return_callback: (def(bool value) ->commands [
			  if(value, add(me.defeated_levels, [me.current_level_info.id])) asserting me.current_level_info,
			  teleport('campaign.cfg', '', 'fade', me),
			])
		  })
		]) asserting selected_deck
	] where message = map<- arg.message",
      
    on_start_level: "[
		set(x, 0),
		set(y, 0),

		//construct all cards so we will error if there are any problems.
		map(['blood', 'colorless', 'food', 'scrolls', 'faith', 'gold'],
		  map(keys(lib.json.get_document_map(fname)),
		    edit_and_continue(
			  construct('card', lib.json.get_document_map(fname)[value]), fname)
		     ) where fname = 'data/cards-' + value + '.cfg') and null,
		fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),

		fire_event('init')

	]",

	on_init: "[
		map(keys(doc), if((not info.prerequisites) or
		            find(info.prerequisites, value in defeated_levels) != null,
		    spawn('campaign_controller.enemy',
		                     int(scale_x(info.x)), int(scale_y(info.y)), -1, [
			set(child.time_in_animation, info.image_num),
			set(child.config, info),
			set(child.defeated, info.id in defeated_levels),
			set(child.zorder, zorder+1),
		]))
		  where info = doc[value]
		)
	]",
	
	on_window_resize: "[
		set(level.dimensions, [0,0,level_width,level_height]),
		set(custom_draw, [0,[0,0], 1,[level_width-1024,0], 2,[level_width-1024,level_height-768], 3,[0,level_height-768]])
	]",

	animation: {
		id: "normal",
		image: "campaign-map.png",
		x: 0,
		y: 0,
		w: 1024,
		h: 768,
		scale: 1,
		frames: 1,
		duration: 1000,
	},

	object_type: [
	{
		id: "enemy",
		always_active: true,
		animation: [{
			id: "normal",
			image: "citadel-mages.png",
			x: 1,
			y: 1,
			w: 35,
			h: 34,
			pad: 3,
			frames: 12,
			frames_per_row: 4,
			duration: 1
		}],

		properties: {
			config: { type: "map", default: {} },
			is_highlighted: false,
			defocus: "def() ->commands [
				set(me.is_highlighted, false),
				set(me.shader.uniform_commands.u_highlight, 0.0),
			] asserting me.shader",

			is_selected: { set: "[set(me._data, value), set(me.is_highlighted, value), if(not value, defocus())]", type: "bool", default: false },

			controller: "obj campaign_controller ::
			  find_or_die(level.chars, value is obj campaign_controller)",

			defeated: { set: "[set(me._data, value), set(shader.uniform_commands.u_defeated, if(value, 1.0, 0.0))] asserting shader", get: "_data", type: "bool", default: false },
		},

		on_create: "set(time_in_animation_delta, 0)",

		on_mouse_enter: "[
			set(me.is_highlighted, true)
		]",
		on_mouse_leave: "if(not is_selected, [
			defocus()
		])",

		on_click: "[
			controller.show_dialog(config),
			[set(enemy.is_selected, enemy = me) | enemy <- level.chars, enemy is obj campaign_controller.enemy]
		]",

		shader: {
			name: "highlight",
			create: "[
				set(uniform_commands.u_highlight, 0.0),
			]",

			draw: "[
				if(parent.is_highlighted, set(uniform_commands.u_highlight,
				   0.5 + sin(parent.cycle*4)*0.25)),
				bind_texture(current_texture, 0)
			]",
			vertex: "
				uniform mat4 u_mvp_matrix;
				uniform vec4 u_parent_pos;
				attribute vec4 a_position;
				attribute vec2 a_texcoord;
				varying vec2 v_texcoord;
				void main()
				{
					v_texcoord = a_texcoord;
					gl_Position = u_mvp_matrix * a_position;
				}",

			fragment: "
				uniform float u_defeated;
				uniform float u_highlight;
				uniform sampler2D u_tex_map;
				varying vec2 v_texcoord;
				void main()
				{
					gl_FragColor = texture2D(u_tex_map, v_texcoord);
					for(int n = 0; n != 3; ++n) {
						gl_FragColor[n] = gl_FragColor[n] + (1.0 - gl_FragColor[n])*u_highlight;
					}

					if(u_defeated > 0.0) {
						gl_FragColor[0] = gl_FragColor[1] = gl_FragColor[2] = (gl_FragColor[0] + gl_FragColor[1] + gl_FragColor[2])/3.0;
					}
				}
			",

			attributes: {
				vertex: "a_position",
				texcoord: "a_texcoord",
			},
			uniforms: {
				highlight: "u_highlight",
				mvp_matrix: "u_mvp_matrix",
			}

		}
	}]
}
