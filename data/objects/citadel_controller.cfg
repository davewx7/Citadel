{
id: "citadel_controller",
prototype: ["citadel_controller_base"],
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,
zorder: 190,

preload_objects: ["arrow", "lane_influence_effect", "creature_land_flag", "tile_cursor", "scrollbar_vertical", "devotion_banner", "devotion_token", "creature", "card", "tip_dialog", "entropia_launch", "endurance_launch", "poison_launch", "shield_flash_effect", "shield_effect"],

properties: {
	in_game: "bool :: true",

	_replay: { type: "null|map" },
	_replay_options: { type: "map", default: {} },
	is_replay: "bool :: _replay != null",

	_replay_paused: { type: "bool", default: false },

	_debug_show_animation_status_label: { type: "bool", default: false },
	_debug_label_mouse_loc: { type: "bool", default: false },
	_debug_mouse_loc: { type: "null|obj label" },
	_debug_show_mouse_loc: "def() ->commands [
		remove_object(_debug_mouse_loc),
		spawn('label', 0, 0, {
			x: 10,
			y: 10,
			zorder: 20000,
			_font_size: 16,
			_text: ['(' + str(mouse_x) + ',' + str(mouse_y) + ')']
		}, [
			set(_debug_mouse_loc, child)
		]),
	]",

	_test: { type: "[object]", default: [] },
	_theme: { type: "class theme", init: "lib.theme" },

	playmat_tex: "
	query_cache(global_cache(1), area,
	lib.citadel.get_scaled_image_uncached(canvas(), 'images/mat.png', target_w, target_h)
	    where target_w = round((area[2] - area[0])*level_width)
	    where target_h = round((area[3] - area[1])*level_height)
	)
		where area = playmat_area
		where tex_w = 2048
		where tex_h = 1609
	",

	playmat_area: "[decimal,decimal,decimal,decimal] ::
		[0.5 - width*0.5, 0.5 - height*0.5, 0.5 + width*0.5, 0.5 + height*0.5]
		 where width = (height*2048.0/1609.0)*(decimal(level_height)/decimal(level_width))
		 where height = 0.995
	",

	screen_area: "[decimal,decimal,decimal,decimal] ::
		[0.0, (SCREEN_HEIGHT - level_height)/2.0, decimal(level_width), level_height + (SCREEN_HEIGHT - level_height)/2.0]
	",

	playmat_alpha: { default: 0.0 },

	screen_shake: "def(decimal intensity, int duration, int nwaves, bool shake_h=true) ->commands
	execute(me,
	[
		map(range(duration),
		  schedule(value, set(level.dimensions,
		  [
		    level.dimensions[0] + if(shake_h, shake, 0),
			level.dimensions[1] + if(shake_h, 0, shake),
			level.dimensions[2] + if(shake_h, shake, 0),
			level.dimensions[3] + if(shake_h, 0, shake),
		  ]
		   where shake = int(sin(t*360.0*nwaves)*intensity*(1.0-t)) ))
		  where t = decimal(value)/decimal(duration)),

		schedule(duration, set(level.dimensions, level.dimensions))
	])
	",

	_storyline: { type: "obj storyline_base", init: "object('storyline_null')" },

	in_background: { default: false },

	get_mm_client_state: "def() ->class mm_client_state _mm_client_state",

	testtest: "c.render(512, 512, [
		c.set_operator('OVER'),
		c.rectangle(0, 0, 256, 512),
		c.set_source_rgba(1, 1, 1, 0.5),
		c.set_operator('OVER'),
		c.rectangle(0, 0, 256, 512),
		c.set_source_rgba(1, 1, 1, 0.5),
		c.fill(),
	]).save('test.png') where c = canvas()",

	render_card_image_to_file: "def(string card_name, decimal size, string fname='card.png') ->commands
	object('card', 0, 0, {
		x: 0, y: 0,
		card_type: lib.citadel.create_card(card_name),
		controller: me,
		card_size: size,
		show_shadow: false,
	}).render_card_to_file(size, fname)
	",

	render_card_art: "def(class card card) ->commands
	get_texture({ image: 'portraits/' + (string<- card.portrait), surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE']}).save('complete-art/' + (string<- card.portrait))
	",

	output_cards_in_set: "def(string|null set, bool name_only=false) ->commands
	map(cards, [
	 dump(['RENDER', value.name], null),
	 render_card_image_to_file(value.name, 3.0,
	  'all-cards/' +
	    if(name_only or set = null, '',
		(string<- set) + '-' +
	   (string<- if(size(value.school_list) > 1, 'multi',
	       if(value.first_school = -1, 'none',
			  SCHOOL_NAMES[value.first_school])
	   )) + '-' +
	   if(value.artist in [null,'eleazzaar'], 'incomplete', 'complete') + '-'
	   ) +
	   (string<- sum(map(value.name, if(value = ' ', '-', value = q('), '', value)), '')) + '.png'
	  ),

	  if(value.artist not in [null,'eleazzaar'],
		render_card_art(value)
	  )
	]
	)
	where cards = if(set = null, lib.citadel.get_all_card_objects(),
	                             lib.citadel.get_card_objects_in_set(set))
	",

	output_card_db: "def() ->commands

	map(cards, [
		render_card_image_to_file(value.name, 3.0,
			sprintf('card-db/%s.png', sum(map(value.name, if(value = ' ', '-', value)), ''))
		)
	])

	where cards = lib.citadel.get_card_objects_in_set('core')
	",

	get_complete_images: "def() ->[string]
		map(filter(lib.citadel.get_card_objects_in_set('core'), value.artist not in [null,'eleazzaar']), string<- value.portrait)
	",
	
	//code for making the hex board image and saving to a file. Not
	//normally used in game.
	make_hex_board_image: "def(int hex_width=114, int hex_height=85) ->commands
(c.render(1024, 512,

 fold([[c.save(), c.translate((xpos-1)*hex_width*0.75, ypos*hex_height + if(xpos%2 = 1, hex_height*0.5, 0))] + hex + [
 	c.set_source_rgba(
	(xpos%12)/11.0,
	(ypos%6)/5.0,
	1, 1),
	
	c.fill(), c.restore()] |
   xpos <- range(13),
   ypos <- range(8)
 ], a+b)

).save('test.png')

  where hex = [
  	c.line_to(hex_width*0.25, -hex_height/2),
  	c.line_to(hex_width*0.75, -hex_height/2),
  	c.line_to(hex_width*1.00, 0),
  	c.line_to(hex_width*0.75, hex_height/2),
  	c.line_to(hex_width*0.25, hex_height/2),
  	c.line_to(hex_width*0.00, 0),
  ])
  where c = canvas()
	",

	_ping_time: { type: "int", default: 0 },
	ping_game: "def(int nbytes=0) ->commands [
		execute(me, tbs_send(client, {
			type: 'ping_game',
			payload: map(range(nbytes/10), 1d10000000),
		})),
		set(_ping_time, cycle),
	]",

	pong_game: "def() ->commands [
		log(['PONG', cycle - _ping_time]),
	]",

	concede_game: "def() ->commands [
		record_stats({
			table: 'game',
			action: 'concede',
			uuid: state._uuid,
		}),

		execute(me, tbs_send(client, {
			type: 'concede',
		}))
	]",

	process_connection: "def() ->commands execute(me, [
    	tbs_process(client);

		//if we haven't heard from the server in a while it sounds like something is up and
		//we should try a new connection and request.
		if(is_online_game and cycle - max(_last_message_receive_time, _recover_connection_time) > _connection_timeout_time, [
			set(_recover_connection_time, cycle),
			set(_client, create_tbs_client());

			//if we sent an end turn request and it wasn't respected, re-send it now.
			if(_end_turn_on_state != null and _end_turn_on_state = _state_id, end_turn());

			fire_event('request_updates')
		]),
	])",

	_response_pause_counter: { type: "int", default: -1 },

	_last_state_message: { type: "map", default: {} },

	get_avatars: "def() ->[obj player_avatar] _avatars",
	_avatars: { type: "[obj player_avatar]", default: [] },
	avatar_life: { type: "[obj life_bar]", default: [] },

	avatar_crypts: { type: "[obj crypt_library_display]", default: [] },
	avatar_decks: { type: "[obj crypt_library_display]", default: [] },

	_last_message_receive_time: { type: "int", default: 0 },
	_recover_connection_time: { type: "int", default: 0 },
	_connection_timeout_time: "int :: 60*8",

	_recent_connection_errors: { type: "[int]", default: [] },
	_last_connection_error: { type: "string", default: '' },

	_heartbeat_status: { type: "[PlayerHeartbeat]", default: [] },

	_disconnected_players: { type: "{string -> int}", default: {} },
	_disconnection_dialog: { type: "obj disconnection_dialog|null" },

	suppress_disconnect_dialog: { default: false },

	process_disconnected_label: "def() ->commands
	if(_disconnection_dialog != null, set(_disconnection_dialog.disconnected_players, _disconnected_players))
	",

	state: "class game_state<- _state asserting _state",
	_state: { type: "class game_state|null" },
	end_of_turn_state: { type: "class game_state|null" },
	_end_of_turn_state_needs_release: { type: "bool", default: false },
	next_turn_state: { type: "class game_state|null" },
	_next_turn_state_needs_release: { type: "bool", default: false },

	//record of state ID's when we made moves so
	//we can easily replay from them.
	_command_send_states: { type: "[int]", default: [] },

	_sent_move_message: { type: "int|null" },

	send_move_message: "def(map msg) ->commands [
		add(_command_send_states, [_state_id]),
		tbs_send(client, msg),
		set(_sent_move_message, cycle),
	]",


	_animation_status_label_key: { type: "any" },
	_animation_status_label: { type: "obj label|null" },
	create_animation_status_label: "def(int ntime) ->commands
	if(key != _animation_status_label_key, [
		set(_animation_status_label_key, key),
		if(_animation_status_label, remove_object(_animation_status_label)),

		if(_debug_show_animation_status_label,
		spawn('label', level_width-avatar_width + 32, 48, {
			zorder: get_zorder('debug_labels'),
			_text: [if(ntime <= 0, 'no animation', 'animating ' + _animation_reason + ': ' + str(ntime)), 'state id: ' + str(_state_id) + ',' + str(_processed_state_id)],
			_halign: 'left',
			_font_size: 12,
			_bg_color: [0,0,0,1],
		}, [
			set(me._animation_status_label, child),
		])
		),
	]) where key = [max(0, ntime)]
	",

	_server_response_label: { type: "obj label|null" },

	create_server_response_label: "def(int state_id, int server_time_ms) ->commands if(_sent_move_message != null, [
		set(_sent_move_message, null),

		log('timing_message: state id = ' + str(state_id) + ' took ' + str(latency_ms) + 'ms server ' + str(server_time_ms) + 'ms'),

		if(_server_response_label != null, remove_object(_server_response_label)),
/*
		spawn('label', level_width-avatar_width + 32, 16, {
			zorder: get_zorder('debug_labels'),
			_text: ['state id = ' + str(state_id) + ' took ' + str(latency_ms) + 'ms server ' + str(server_time_ms) + 'ms'],
			_halign: 'left',
			_font_size: 12,
			_bg_color: [0,0,0,1],
		}, [
			set(me._server_response_label, child),
		]),
*/
	] where latency_ms = (cycle - _sent_move_message)*20)",

	_connection_status_display: { type: "null|obj connection_status_display", set: "if(_data != value, [remove_object(_data), set(_data, value)])" },

	_sync_text: { type: "string", default: '' },

	create_sync_label: "def(string txt) ->commands
	set(_sync_text, txt)
	",

	refresh_state_id_sync_label: "def() ->commands
	;
	if(_remote_state_id != -1,
	if(in_sync != _state_id_in_sync, [
		set(_state_id_in_sync, in_sync),
		if(in_sync = false, set(_state_id_last_sync_time, cycle)),

		if(in_sync, create_sync_label('In parity (' + str((cycle - _state_id_last_sync_time)*20) + 'ms) stateid = ' + str(_state_id))),


	], [
		if(in_sync = false,
		   create_sync_label('Out of parity (' + str((cycle - _state_id_last_sync_time)*20) + 'ms) stateid = ' + str(_state_id) + ' vs ' + str(_remote_state_id)))
	]) where in_sync = (_remote_state_id = _state_id))
			
	",

	_state_id_in_sync: { type: "bool", default: true },
	_state_id_last_sync_time: { type: "int", default: 0 },

	_remote_state_id: { type: "int", default: -1 },
	_remote_state_id_timestamp: { type: "int", default: -1 },

	_state_id_timestamp: { type: "int", default: -1 },
	_state_id: { type: "int", default: -1 },
	_processed_state_id: { type: "int", default: -1 },
	_client: { type: "object|null" },

	client: "object<- _client asserting _client",

	get_state_id: "def() ->int _state_id",

	_current_presence_targets: { type: "[Loc]", default: [] },

	//the state needed to represent presence to the other player --
	//which cards we have moused over etc.
	_presence_state: "map ::
	if(observer, {},
	{
		choice: if(_choice_object != null and state.nplayer = state.current_player_index, if(card != null, card.card_type._uuid) where card = find(level.chars, value is obj card and value.paused = false and value.is_choice and value.halo_shown)),
		hand_card_mouseover: if(_playing_card != null and _playing_card.in_hand and _playing_card.hand_index != null, _playing_card.hand_index, if(card_mouseover != null and card_mouseover.in_hand, card_mouseover.hand_index)),
		playing_card: _playing_card != null,

		targets: _current_presence_targets,

		timer: [((_clock_timer or 0)/60)*60, ((_reserve_timer or 0)/60)*60],
	})
	",

	_last_presence_state: { type: "map", default: {} },

	_process_presence_state: "def() ->commands
	if(new_presence != _last_presence_state, [

		if(is_online_game,
		tbs_send(client, {
			type: 'chat_message',
			nick: username,
			sub_type: 'presence',
			info: new_presence,
		})
		),

		set(_last_presence_state, new_presence),
	]) where new_presence = _presence_state",

	_received_presence_state: "def(map msg) ->commands
	[
		if(_choice_object and state.nplayer != state.current_player_index, _choice_object.process_presence(msg.choice)),

		set(_opponent_hand_mouseover, int|null<- msg.hand_card_mouseover),
		set(_opponent_card_playing, bool|null<- msg.playing_card),
		set(_opponent_targets, [Loc]<- (msg.targets or [])),
		bind_command(spawn_opponent_cards),

		_update_opponent_timer(msg.timer),

	]
	where opponent_cards = filter(level.chars, value is obj card and value.in_opponent_hand)
	",

	_opponent_hand_mouseover: { type: "int|null" },
	_opponent_card_playing: { type: "null|bool" },
	_opponent_targets: { type: "[Loc]", default: [] },

	force_skip_responses: { default: false },

	pending_card_discards: { type: "[obj card]", default: [] },
	_card_preview: { type: "obj card|null" },
	_card_begin_mouseover: { type: "int", default: 0 },
	_card_mouseover_float_amount: "int :: if(card_mouseover = null, 0, lib.gui.py(int(min(100, level.cycle - _card_begin_mouseover)*1.5)))",
	card_mouseover: { type: "obj card|null",
	   set: "if(value != _data, [
	   	log(['card_mouseover', _data != null, value != null]),
		lib.sound.play_sound(me, 'interface/card_hand_mouseover_' + if(value, 'in', 'out')),
	   	 set(_card_begin_mouseover, level.cycle),
	     if(_data != null, [set(_data.allow_drag, false), _end_mouseover(_data)]),
		 if(new_value != null, set(new_value.allow_drag, true)),
		 set(_data, new_value),
	   ] where new_value = if(value in pending_card_discards, null, value))"
	 },

	 _discard_card_button: { type: "obj button_controller|null", set: "if(value != _data, [remove_object(_data), set(_data, value)])" },

	_card_regions: { type: "[{left: int, right: int, top: int, card_num: int}]", default: [] },
	_card_regions_left_to_right: "[{left: int, right: int, top: int, card_num: int}] :: sort(_card_regions, a.left < b.left)",
	_hand_card_moused_over: "int ::
	 if(region = null, -1, region.card_num)
	      where region =
		     if(card_mouseover, find(card_regions_ordered,
			   (index >= mouseover_index and xpos >= value.right - reserved_region and xpos <= value.right and ypos >= value.top-_card_mouseover_float_amount) or
			   (index <= mouseover_index and xpos >= value.left and xpos <= value.left + reserved_region and ypos >= value.top-_card_mouseover_float_amount))) or
		  	 
		     //prefer the already selected card
		     //if(card_mouseover, find(card_regions_ordered, card_mouseover.hand_index = value.card_num and (card_mouseover.being_dragged or xpos >= value.left and xpos <= value.right + 0.2*(value.right - value.left) and ypos >= value.top-_card_mouseover_float_amount))) or

			 //not over an already selected card, find the first match.
		     find(card_regions_ordered, xpos >= value.left and xpos <= value.right and ypos >= value.top-_card_mouseover_float_amount)
	      where xpos = lib.gui.mouse_pos(level)[0]
	      where ypos = lib.gui.mouse_pos(level)[1]
		  where reserved_region = min(10, 200 / (size(card_regions_ordered)+1))

		  //Since card regions overlap, we want to order the card regions by
		  //their order of priority if a match is found. We prefer to match
		  //to a region closest to the already selected card, so reverse cards
		  //to the left in order while keeping cards to the right in order.
		  where card_regions_ordered = if(mouseover_index < 0, _card_regions_left_to_right, reverse(_card_regions_left_to_right[:mouseover_index]) + _card_regions_left_to_right[mouseover_index:])
		  where mouseover_index = index(_card_regions_left_to_right, find(_card_regions_left_to_right, card_mouseover != null and card_mouseover.hand_index = value.card_num))",

	//location of the tops of our cards
	_card_hand_top: { type: "decimal", default: 0.0 },

	_prev_ctrl_keys: { type: "[string]", default: [] },

	_playing_card_channeling_label: { type: "obj label|null" },
	_playing_card_channeling_controls: { type: "[obj up_down_button]", default: [] },

	_amount_channeled: { type: "int|null" },
	set_amount_channeled: "def(int amount) ->commands set(_amount_channeled, amount)",
	

	_playing_card_cast_button: { type: "null|obj button_controller",
		set: "if(_data != value, [
			remove_object(_data),
			set(_data, value),
		])"
	},

	_playing_card: { type: "null|obj card", default: null,
		set: "[
			if(value != null, map(movement_arrows, set(value.selectable, false))),
			if(value = null, _set_mana_bar_using(0)),
			set(_playing_card_cast_button, null),
			set(_current_presence_targets, []),
			set(_preview_creature, null),
			if(_data != null, [
				set(_data.arrows, []),
				_data.hide_halo(),
				if(_data.in_ability, remove_object(_data)),
			]),
			if(value != null, [
				value.show_halo(),
				animate(value, {mid_x: lib.gui.px(150), mid_y: lib.gui.py(150), rotate: 0, card_size: 1.0}, {duration: lib.animation_timings.select_card_movement_time}),
				set(value.zorder, get_zorder('card_play')),
			]),
			set(_data, value),
		]"
	},

	no_mandatory_play: "bool :: _playing_card = null or _playing_card.mandatory_play = false",

	_targets_chosen: { type: "[Loc]", default: [] },

	_animation_end_time: { type: "int", default: -1 },
	animation_time_remaining: "int :: if(_animation_end_time = -1, 0, max(0, _animation_end_time - cycle))",

	_animation_reason: { type: "string", default: "" },
	_card_resolve_time: { type: "int", default: -1 },

	_game_state_message_pending: { type: "null|map" },
	_game_state_queue: { type: "[map]", default: [] },
	_animation_queue: { type: "[class animation]", default: [] },
	_processed_animation_queue: { type: "bool", default: false },

	_update_command_queue: { type: "[{name: string, cmd: commands}]", default: [] },

	_queue_update_command: "def(string name, commands cmd) ->commands
		add(_update_command_queue, [{name: name, cmd: cmd}])
	",

	_process_command_queue: "def() ->commands
	instrument_command('process_command_queue',
	if(_update_command_queue,
		let cmd = _update_command_queue[0].cmd;
		let name = _update_command_queue[0].name;
		set(_update_command_queue, _update_command_queue[1:]);
		instrument_command(name, cmd)
	)
	)
	",

	//state.animation_hints is cleared by the server every time state.nturn is incremented. We keep track of
	//which nturn we have processed animation hints on and how many animation hints we have processed so that
	//we don't repeat any.
	_nanim_hint_processed: { type: "int", default: 0 },
	_nanim_hint_nturn: { type: "int", default: -1 },

	_animated_spell_card: { type: "null|obj card", default: null },
	_spells_on_stack: { type: "[obj card]", default: [] },

	top_of_stack: "obj card|null :: choose(filter(level.chars, value is obj card and value.stack_id != null), value.stack_id)",

	_spell_animation_time: { type: "int", default: 0 },

	_choice_object: { type: "null|obj choice_controller" },
	_choose_deck_object: { type: "null|obj choose_deck_screen_controller" },
	_title_controller: { type: "null|obj title_controller" },
	_show_deck_selection_at_start: { type: "bool", default: false },
	_mulligan_object: {
		type: "null|obj mulligan_controller",
		set: "if(_data != value, [
			set(_data, value),
			if(value = null, set(_mulligan_end_time, cycle)),
		])",
	},

	_mulligan_end_time: { type: "null|int" },
	_card_draw_end_time: { type: "int", default: 0 },

	confirm_mulligan: "def([obj card] cards) ->commands
	execute(me,
		tbs_send(me.client, {type: 'mulligan', cards: map(cards, value.card_type._uuid)})
	);
	
	if(cards, [
		reserve_animation_time('mulligan', 32),
		map(cards, schedule(index*3, [
			lib.sound.play_sound(me, 'interface/draw-cards'),
			schedule(16, set(value.zorder, deck_display.zorder-10)),
			value.flip_card_over(true, 10),
			schedule(10,
			animate(value, {
				mid_x: deck_display.mid_x,
				mid_y: deck_display.mid_y,
				card_size: 0.2,
			}, {
				duration: 20,
				on_complete: remove_object(value),
			})
			),
		])),
	]
	 where deck_display = find_or_die(level.chars, value is obj crypt_library_display and value.player_index = state.nplayer and value.is_crypt = false))",

	_end_turn_button: { type: "null|obj end_turn_button" },
	get_end_turn_button: "def() ->null|custom_obj _end_turn_button",

	font: "string:: lib.font.regular_font",
	color: "string:: 'antique_white'",
	font_color: "string:: 'antique_white'",

	_responding_to_challenge: { type: "bool", default: false },
	respond_to_challenge: { type: "null|function() ->commands" },
	return_callback: { type: "function(bool, null|class game_state) ->commands" },
	game_result: { type: "bool", default: false },

	click_challenge: "def(string username) ->commands if(respond_to_challenge != null, execute(me, [
		log('CLICK CHALLENGE CITADEL'),
		set(_responding_to_challenge, true),
		schedule(100, ; [remove_object(c) | c <- level.chars]; respond_to_challenge()),
		tbs_send(client, {
			type: 'quit'
		}),
	]))",

	quit_game: "def() ->commands execute(me, [
		record_stats({
			table: 'game',
			action: 'quit',
			uuid: state._uuid,
		}),

		schedule(100, ; [remove_object(c) | c <- level.chars]; return_callback(game_result, _state)),
		tbs_send(client, {
			type: 'quit'
		}),
	])",

	//in a campaign the message sent to the server to setup this game.
	game_setup_message: { type: "map|null" },

	campaign_location: { type: "string|null" },
	campaign_scenario: { type: "int|null" },
	campaign_sets: { type: "[string]", default: [] },
	puzzle_name: { type: "string|null" },
	victory_unlock: { type: "string|null" },
	scenario: { type: "null|Scenario" },
	campaign_node_id: "string|null :: if(scenario != null, scenario.node_id)",

	restart_game: "def() ->commands [
		spawn('pause_dialog', {
			_controller: me,
			_mm: me,
			_hidden: true,
		}, [
			set(child.alpha, 0),
			child.restart_game(),
		])
	]",

	_skip_animations: { type: "bool", default: false },
	pump_game_state_queue: "def() ->commands
	  if(cycle < _animation_end_time and not _skip_animations, null,
	    _animation_queue, [
		set(_animation_queue, _animation_queue[1:]),
		play_animation_hint(_animation_queue[0]),
	  ],

	   _update_command_queue, _process_command_queue(),

	  _game_state_queue != [] and cycle >= _animation_end_time and not _replay_paused,
	  [
	    set(_game_state_queue, _game_state_queue[1:]),
	    fire_event('update_game', {message: _game_state_queue[0], force_process: true})
	  ],
	  
	  set(_skip_animations, false)
	  )",

	get_player_status: "def() ->string if(is_online_game, if(observer, 'watching a game', 'playing multiplayer'), 'playing vs ai')",

	//if the game is an offline game let them know there is someone wanting to
	//play online.
	should_notify_multiplayer_queue: "def() ->bool is_online_game = false and respond_to_challenge != null",
	goto_multiplayer_lobby: "def() ->commands
		if(respond_to_challenge != null, respond_to_challenge())
	",

	is_online_game: "bool :: game_server_address != '' and (_replay = null)",

	_observer_perspective: { type: "int|null" },
	observer: { type: "bool", default: false },
	_observers: { type: "[string]", default: [], set: "
	if(value != _data, [
		[observer_disconnect(obs) | obs <- _data, obs not in value],
		[observer_connect(obs) | obs <- value, obs not in _data],
		set(_data, value),
		
		if(value = [], [
			remove_object(_observers_label),
			set(_observers_label, null),
		], [
			_remove_observers_tooltip(),
			remove_object(_observers_label),
			spawn('label', {
				x2: level_width - lib.gui.py(30),
				y2: level_height - lib.gui.py(320),
				_text: [str(size(value)) + ' observer' + if(size(value) > 1, 's', '')],
				_font_size: lib.gui.py(18),
				zorder: 1000,
				_color: [1,1,1,1],
				_bg_color: [0,0,0,0.2],

				mouse_enter: me._spawn_observers_tooltip,
				mouse_leave: me._remove_observers_tooltip,
			}, [
				set(me._observers_label, child)
			]),
		])
	])
	" },

	_observers_tooltip: { type: "null|custom_obj" },

	_spawn_observers_tooltip: "def()->commands
	execute(me,
	[
	_remove_observers_tooltip(),
	if(_observers_label != null,
	[
		log('spawn tip'),
		spawn('tip_dialog', {
			mid_x: level_width - lib.gui.py(300),
			mid_y: level_height - lib.gui.py(400),
			zorder: 30000,
			_title: 'Observers',
			_tip: {
				key: 'tip',
				text: fold(_observers, a + '\n' + b, ''),
				targets: [_observers_label],
			},

			_width: lib.gui.py(240),
			_height: lib.gui.py(220),
			_has_close: false,
			_delay_widgets: 20,
			alpha: 255,
		}, [
			animate(child, {alpha: 255}, {duration: 10}),
			set(_observers_tooltip, child),
		])
	]
	)
	]
	)
	",

	_remove_observers_tooltip: "def()->commands
	execute(me,
	[
		remove_object(_observers_tooltip),
		set(_observers_tooltip, null)
	])
	",


	_observers_label: { type: "null|obj label" },

	observer_connect: "def(string name) ->commands
		if(lower(name) != lower(username),
			spawn_notification(name + ' has started watching')
		)
	",

	observer_disconnect: "def(string name) ->commands
		if(lower(name) != lower(username),
			spawn_notification(name + ' is no longer watching')
		)
	",

	myturn: "bool :: observer = false and state.nplayer = state.current_player_index",

	game_created: { type: "bool", default: false },
	session_id: { type: "int", default: -1, access: 'private' },
	selected_deck_category: { type: "string", default: "" },
	selected_deck: { type: "string", default: "" },
	specified_deck: { type: "[string]|null" },
	specified_reward: { type: "CampaignRewardInfo|null" },
	game_server_address: { type: "string", default: "@eval TBS_SERVER_ADDRESS" },
	game_server_port: { type: "int", default: "@eval TBS_SERVER_PORT" },

	create_tbs_client: "def() ->object
	  if(game_server_address, tbs_client(game_server_address, game_server_port, session_id), tbs_internal_client(session_id))
	  ",

	level_width: "int :: level.dimensions[2]",
	level_height: "int :: level.dimensions[3]",

	//the left/right side of the 'usable' area -- i.e. cutting off edges
	//to make for a 4:3 display.
	gui_left_edge: "int :: (level_width - (level_height*4)/3)/2",
	gui_right_edge: "int :: level_width - gui_left_edge",

	card_keeps: "[int]<-  [card.hand_index | card <- level.chars, card is obj card, card.in_hand, card.keep, card.player_index = state.nplayer]",

	card_keep_draw_id: "[int] :: [card.card_type.draw_id | card <- level.chars, card is obj card, card.in_hand, card.keep]",

	end_turn_message: "{string -> any}<- {type: 'end_turn', player_index: state.nplayer, keep: card_keeps}",

	_end_turn_pending: { default: false },
	_end_turn_on_state: { type: "null|int" },

	end_turn: "def() ->commands
	if(_tutorial.inhibit_end_turn(me) = false,
	[
	set(locked_mana, null),

	//remove the end turn button immediately to appear responsive to
	//pressing the end turn button.
	if(_end_turn_button, [
		set(_end_turn_button.button_active, false)
	]),
	execute(me, if(animation_up_to_date, [set_widgets([]),
	                     set(_end_turn_pending, false),
						 set(me._end_turn_on_state, me._state_id),
			             set(me._playing_card, null),
						 send_move_message({
						  type: 'moves',
						  state_id: me._state_id,
						  moves: [end_turn_message]
						 })
						 ],
						 set(_end_turn_pending, true)))
	],
	
	//trying to click end turn when inhibited, flash any tips
	[
		[tip.flash_tip() | tip<- level.chars, tip is obj tip_dialog]
	])
	",

	send_move_creature_message: "def(class creature c) ->commands
	execute(me,
	[
	map(movement_arrows, value.activate_and_die()),
	send_move_message({
		type: 'moves',
		state_id: me._state_id,
		moves: [{
			type: 'move_creature',
			creature_uuid: c._uuid,
		    player_index: state.nplayer,
		}]
	})
	]
	)
	where movement_arrows = filter(movement_arrows, value.src_tile = c.loc)
	",

	get_zorder: "def(string key) ->int lib.citadel.zorder(key)",

	opponent_speak: "def(string text) ->commands [
		spawn('speech_controller', 0, 0, {
			_mm: me,
			_controller: me,
			_text: text,
			_avatar: _avatars[1],
		}),
	]",

	transient_opponent_speak: "def(string text) ->commands [
		reserve_animation_time('transient_opponent_speak', 50),
		spawn('speech_bubble', avatar.x + px(20), avatar.y + px(240), {
			_text: text,
			zorder: 25000,
			_width: px(250),
			_height: px(200),
		}, [
			schedule(200, animate(child, {
				alpha: 0,
			}, {
				duration: 50,
				on_complete: remove_object(child),
			}))
		])
	] where avatar = _avatars[1]",

	awaiting_input: "bool :: _playing_card != null",

	clear_input_state: "def() ->commands execute(me, [
		//if(me.card_mouseover, mouse_leave_card(me.card_mouseover)),
		[set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		[set(player.selectable, false) | player <- level.chars, player is obj player_avatar],
		[set(land.selectable_land, false) | land <- level.chars, land is obj creature],
	   	[set(card.is_on_stack_and_targetable, false) | card <- level.chars, card is obj card],
		set(_playing_card, null),
		set(_targets_chosen, []),
		if(_selected_creature, finish_activated_ability_cards());
		//set(me.card_mouseover, null),
		_spawn_tile_cursors();

		if(_state, spawn_movement_arrows(_state))
	])",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def() ->commands
	  if(myplayer.hand != _cur_hand, [
		clear_input_state(),
		set(_cur_hand, myplayer.hand),
	  ])
	",

	//debug function to execute FFL on the server.
	server_exec: "def(string code) ->commands
	[
	set(_used_cheats, true),
	execute(me, tbs_send(client, {
		type: 'moves',
		state_id: _state_id,
		force: true,
		moves: [{
			type: 'debug',
			exe: code
		}]
	}))
	]
	",

	rewind: "def(int n=1) ->commands
	if(_command_send_states != [],
		execute(me, tbs_send(client, {
			type: 'restore_state',
			state_id: _command_send_states[index],
		}))
		where index = max(0, size(_command_send_states)-n)
	)
	",

	download_state: "def(string id) ->commands
		execute(me, tbs_send(client, {
			type: 'download_state',
			id: id,
		}))
	",

	upload_state: "def(string id) ->commands
		execute(me, tbs_send(client, {
			type: 'upload_state',
			id: id,
		}))
	",

	save_state: "def() ->commands
		execute(me, tbs_send(client, {
			type: 'save_state',
		}))
	",

	load_state: "def() ->commands
		execute(me, tbs_send(client, {
			type: 'load_state',
		}))
	",

	_anim_stats: { type: "{string -> int}", default: {} },

	_used_cheats: { type: "bool", default: false },

	send_chat: "def(string msg) ->commands
		execute(me, tbs_send(client, {
			type: 'chat_message',
			sub_type: 'text',
			text: msg,
			nick: username,
		}))
	",

	debug_draw: "def(int ncards) ->commands [
		record_stats({
			table: 'game',
			action: 'cheat',
			uuid: state._uuid,
		}),
		server_exec('players[current_player].draw_cards(me, ' + ncards + ')')
	]",

	debug_mana: "def(int nmana) ->commands [
		record_stats({
			table: 'game',
			action: 'cheat',
			uuid: state._uuid,
		}),
		server_exec('[add(players[current_player].base_income, increase), add(players[current_player].resources, increase)] where increase = ' + nmana)
	]",
	debug_mana_enemy: "def(int nmana) ->commands server_exec('[add(players[next_player_index].base_income, increase), add(players[next_player_index].resources, increase)] where increase = ' + nmana)",
	debug_card: "def(string name, int ncopies=1) ->commands
	if(card_name != null,
	   [
		  record_stats({
			table: 'game',
			action: 'cheat',
			uuid: state._uuid,
		  }),
	      server_exec(sprintf('map(range(%d), add(players[current_player].hand, [lib.citadel.create_card(q(%s))]))', ncopies, card_name)),
	   ],
	   log('No card called ' + name)
	)
	where card_name = lib.citadel.get_fuzzy_card_name(name, '')",
	debug_card_enemy: "def(string name) ->commands server_exec('add(players[next_player_index].hand, [lib.citadel.create_card(q(' + name + '))])')",

	debug_enemy_hand: "[string]<- map(state.opponent_obj.hand, value.name)",
	see_enemy_hand: "def() ->commands
		server_exec('set(players[0].can_see_enemy_hand,1)')",
	
	animation_up_to_date: "bool<- _processed_state_id = _state_id and animation_time_remaining <= 0 and _animation_queue = [] and _update_command_queue = []",

	time_to_resolve_card: "int :: max(0, _card_resolve_time - cycle)",
	reserve_card_resolve_time: "def(int ncycles) ->commands if(end_time > _card_resolve_time, set(me._card_resolve_time, end_time)) where end_time = cycle + ncycles",

	cancel_reserved_animation: "def() ->commands
		if(_animation_end_time > cycle, set(_animation_end_time, cycle+1))
	",
	reserve_animation_time: "def(string reason, int ncycles) ->commands ;
	  if(_replay and (' ' in level.player.ctrl_keys),
		null,
	   end_time > _animation_end_time, [
		set(me._animation_end_time, end_time),
		set(me._animation_reason, reason),
		log(['RESERVE_ANIM', reason, ncycles])
	  ]) where end_time = cycle + ncycles
	",
	myplayer: "class player<- _state.players[_state.nplayer] asserting _state",
	_cur_hand: { type: "[class card_base]", default: [] },
	myteam: "[class player] :: get_player_team(myplayer)",
	enemy_player: "class player<- _state.players[(_state.nplayer+1)%2] asserting _state",
	get_player_team: "def(class player player) ->[class player] sort(state.team(player), if(a.player_index = state.nplayer, true, if(b.player_index = state.nplayer, false, a.player_index < b.player_index)))",

	remove_preview_card: "def(any card) ->commands if(_card_preview and card = null, [remove_object(_card_preview), set(_card_preview, null)])",

	_opponent_preview_card: { set: "[if(_data and _data != value, remove_object(_data)), set(_data, value)]", type: "obj card|null" },
	_opponent_card_mouseover: { type: "obj card|null" },

	mouse_enter_opponent_card: "def(obj card card) ->commands if(card.show_back = false, [
		spawn('card', 0, 0, {
			 card_type: card.card_type,
			 controller: me,
			 in_hand: false,
			 allow_drag: false,
			 card_size: 2.0,
			 zorder: get_zorder('card_stack_base') + 100,
		}, [
			set(_opponent_preview_card, child),
			set(child.mid_x, mouse_x),
			set(child.y, mouse_y + py(32)),
		]),

		set(_opponent_card_mouseover, card),
		log(['ENTER OPPONENT', card.card_type.name]),
	])",

	mouse_leave_opponent_card: "def(obj card card) ->commands if(_opponent_card_mouseover = card, [
		set(_opponent_preview_card, null),
		set(_opponent_card_mouseover, null),
		log(['LEAVE OPPONENT', card.card_type.name]),
	])",

	_float_card_easing: "def(decimal t) -> decimal
		let s = 1.70158;
		let t = t-1; 
		t^2*((s+1)*t + s) + 1",

	float_card: "def(obj card card) ->commands
		animate(card, {
			mid_y_decimal: decimal(card.mid_y - lib.gui.py(14)),
		}, {
			duration: 300,
			name: 'card_move',
			replace_existing: true,
			easing: lib.math.ease_out_back,
		})
	",

	enter_targetable_card: "def(obj card card) ->commands
	if(_playing_card != null and card.stack_id != null and card.is_on_stack_and_targetable,
		set_playing_card_arrows(_targets_chosen + [[-2, card.stack_id]])
	)
	",
	leave_targetable_card: "def(obj card card) ->commands
		set_playing_card_arrows(_targets_chosen)
	",

	mouse_enter_card: "def(obj card card) ->commands
	if(_awarding_cards = false and _card_dragging = null and (card not in pending_card_discards), [
	 [creature.hand_card_entered() | creature <- level.chars, creature is obj creature],

	 if(card.in_hand and (card.card_type in _current_hand) and card.hand_index < size(_current_hand) and _card_drag_play = null, [
		set(card.zorder, get_zorder('card_highlight')),
		if(card != _playing_card, [
			animate(card, {
				mid_x: pos.mid_x,
				mid_y: pos.mid_y - py(190),
				rotate: 0.0,
				card_size: 2.5,
			}, {
				duration: 10,
				name: 'card_move',
				replace_existing: true,
				easing: lib.math.linear,
				on_complete: ; me.float_card(card),
			}),

			set(_discard_card_button, null),

			if(state.nteam = state.current_player_index and observer = false and (card not in pending_card_discards) and _tutorial.inhibit_card_right_click(me, card) = false and state.in_response_phase = false and card.parent_creature = null, [
				spawn('button_controller', {
					x: pos.mid_x - py(60),
					y: level_height - py(32),
					text: 'Discard',
					_font_size: px(24),
					on_click: (def() ->commands me.card_discard(card)),
					button_width: px(120),
					button_height: px(30),
					zorder: get_zorder('card_highlight') + 100,
				}, [
					set(me._discard_card_button, child),
				])
			]),

		]) where pos = cards_in_hand_positions(_my_hand_size, hand_left_side, hand_area)[card.hand_index],
		set(me.card_mouseover, card),
		_set_mana_bar_using(if(card.is_castable, state.players[state.nplayer].calculate_cost(card.card_type), 0)),
	 ]),
	 (if(me._playing_card = null, if(me.card_mouseover = card, null,
	  if(me.card_mouseover != null, [
			mouse_leave_card(me.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.in_hand,

	  [

	  schedule(50, bind_command(me.show_card_tips, card)),

	  if(can_afford and possible_targets != [],
	  [
	 	card.show_halo(),
	    set(me.card_mouseover, card),
	  ]),

	  ]
	  where is_usable = card.card_type.is_usable(state, _casting_creature)
	  where can_afford =  if(possible_targets = [], false,
		                      possible_targets != null, true,
		                      local_player.can_afford(card.card_type)
						   )
	  )
	  where possible_targets = if(possible_targets_unpriced != null,
		                            filter(possible_targets_unpriced, myplayer.can_afford_with_target(state, card.card_type, value))
								 )
 	  where possible_targets_unpriced = if(card.card_type is class card, card.card_type.possible_targets(state, _casting_creature, []), [])
	  )))

	  )])
	  where local_player = myplayer",
	
	show_card_tips: "def(obj card card) -> commands
	if(card = card_mouseover, card.show_card_tips())",
	
	_end_mouseover: "def(obj card card) -> commands
	  if(card.in_hand and find(level.chars, value = card) and find(_current_hand, value = card.card_type) != null and card.hand_index >= 0 and card.hand_index < _my_hand_size,
	    [
		if(_playing_card != card, [
			card.hide_halo(),
			if('card_discard' not in card.animated_movements,
				animate(card, {
					mid_x: pos.mid_x,
					mid_y: pos.mid_y,
					rotate: pos.rotate,
					card_size: pos.card_size,
				}, {
					duration: 10,
					name: 'card_move',
					replace_existing: true,
				})
			),
		]),
		set(card.zorder, pos.zorder),
	    ] where pos = cards_in_hand_positions(_my_hand_size, hand_left_side, hand_area)[card.hand_index]
	  )
	",

	mouse_leave_card: "def(obj card card) ->commands [
	  
	  card.clear_card_tips(),

	  set(me.card_mouseover, null),
	  remove_object(_discard_card_button),
	  set(_discard_card_button, null),

	  if(_playing_card,
		_set_mana_bar_using(state.players[state.nplayer].calculate_cost(_playing_card.card_type) + (_amount_channeled or 0)),
		_set_mana_bar_using(0)
	  )
	]",

	mouse_drag_card_start: "def(obj card card) ->commands
		if(card = card_mouseover,
		[
			set(_card_dragging, card),
	        remove_object(_discard_card_button),
	        set(_discard_card_button, null),
	  	    card.clear_card_tips(),
			set(card.card_size, 1.0),
			set(card.mid_x, mouse_x),
			set(card.mid_y, mouse_y),
			//choose_targets_for_card(card, []),

			//set up possible targets for the card.
			if(state.nteam = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false and card not in pending_card_discards and possible_targets != [] and possible_targets != null and can_afford and is_usable,
			[
			  if(_playing_card,
			  [
			  	set(_playing_card, null),
				clear_input_state(),
				bind_command(spawn_cards_in_hand),
			  ]),

			  [set(player.selectable, [-1, player.player_num] in possible_targets) | player <- level.chars, player is obj player_avatar],
	   		  [set(card.is_on_stack_and_targetable, [-2, card.stack_id] in possible_targets) | card <- level.chars, card is obj card, card.stack_id != null],
			   map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
			   [set(c.selectable_land, c.creature_object.loc in possible_targets) | c <- level.chars, c is obj creature, c.creature_object.is_land],
			   _spawn_tile_cursors(),

			  set(_card_drag_play, card),
			  set(_tile_drag_onto, null),

			]
			)
	    where is_usable = card_instance.is_usable(state, _casting_creature)
		where can_afford = if(possible_targets = [], false,
		                      possible_targets != null, true,
		                      myplayer.can_afford(card_instance)
						   )

		where possible_targets = if(possible_targets_unpriced != null,
		                            filter(possible_targets_unpriced, myplayer.can_afford_with_target(state, card_instance, value))
								 )
		where possible_targets_unpriced = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, _casting_creature, []))
		where card_instance = class card_base<- card.card_type
		]
		)
	",

	_card_dragging: { type: "obj card|null" },
	_card_drag_play: { type: "obj card|null" },
	_tile_drag_onto: {
	  type: "obj tile|obj player_avatar|obj card|null",
	  set: "if(_data != value, [
	  	set(_data, value),
		if(_data is obj tile, [set(_data.mouseover, false), set(_data.highlight, false)]),
		if(value is obj tile, [set(value.mouseover, true), set(value.highlight, true)]),
	  ])",
	},

	_mycrypt: "null|obj crypt_library_display :: if(state.nplayer >= 0 and state.nplayer < size(avatar_crypts), avatar_crypts[state.nplayer])",
	_theircrypt: "null|obj crypt_library_display :: if(state.nplayer >= 0 and state.nplayer < size(avatar_crypts), avatar_crypts[(state.nplayer+1)%2])",

	_mydeck: "null|obj crypt_library_display :: if(state.nplayer >= 0 and state.nplayer < size(avatar_decks), avatar_decks[state.nplayer])",
	_theirdeck: "null|obj crypt_library_display :: if(state.nplayer >= 0 and state.nplayer < size(avatar_decks), avatar_decks[(state.nplayer+1)%2])",

	_card_overlaps_crypt: "def(obj card card) ->bool
	  if(_mycrypt != null,
		card.x < _mycrypt.x2 and card.y < _mycrypt.y2 and
		card.x2 > _mycrypt.x and card.y2 > _mycrypt.y, false)
	",

	_card_overlaps_tile: "def(obj card card) ->obj tile|null
		find(filter(level.chars, value is obj tile and value.selectable), value.mid_x > card.x and value.mid_x < card.x2 and value.mid_y > card.y and value.mid_y < card.y2)
	",

	_card_overlaps_avatar: "def(obj card card) ->obj player_avatar|null
		find(filter(level.chars, value is obj player_avatar and value.selectable), value.mid_x > card.x and value.mid_x < card.x2 and value.mid_y > card.y and value.mid_y < card.y2)
	",

	_card_overlaps_target_card: "def(obj card card) ->obj card|null
		find(level.chars, value is obj card and value.is_on_stack_and_targetable and card.mid_x >= value.x and card.mid_y >= value.y and card.mid_x <= value.x2 and card.mid_y <= value.y2)
	",

	mouse_drag_card: "def(obj card card) ->commands
	if(card.allow_drag,
	[
	if(card = _card_drag_play, [
	  set(card.card_size, 1.0 - fade_ratio*0.25),
	  set(_tile_drag_onto, _card_overlaps_target_card(card) or _card_overlaps_tile(card) or _card_overlaps_avatar(card)),
	] where fade_ratio = if(mouse_y > top_player_area, 0.0, min(1.0, decimal(top_player_area + px(50) - mouse_y)/px(100)))
	),

	if(_mycrypt != null, set(_mycrypt.highlight, _card_overlaps_crypt(card))),

	card.clear_card_tips(),
	if(card.in_hand and card.hand_index != null,
	[
		if(pos != -1, [
		   set(card.keep, mouse_x >= right_edge_display_areas and (obj_replacing.keep or mouse_x > _card_regions_left_to_right[size(_card_regions_left_to_right)-1].right)),

		   set_card_hand_position(card.hand_index, pos),
	   	   bind_command(spawn_cards_in_hand)
		  ]
		  where obj_replacing = find_or_die(level.chars, value is obj card and value.player_index = state.nplayer and value.hand_index = _card_regions_left_to_right[pos].card_num)) 
		  where pos = index(_card_regions_left_to_right, find(_card_regions_left_to_right,
		     mouse_y > value.top and (
		     (mouse_x > (value.left + value.right)/2 and mouse_x < value.right) or
			 (index = 0 and mouse_x < value.left and mouse_x > value.left - (value.right - value.left)) or
			 (index = size(_card_regions_left_to_right)-1 and mouse_x > (value.right))))),
	])])",

	mouse_drag_card_end: "def(obj card card) ->commands
	
	set(_amount_channeled, null); [
		set(_card_dragging, null),
	    set(_card_drag_play, null),
	    set(_tile_drag_onto, null),

		if(_mycrypt != null, set(_mycrypt.highlight, false)),

		if(card = card_mouseover,
			[
				mouse_leave_card(card),
			]
		),

		if(_mycrypt != null and _mycrypt.highlight,
			card_discard(card),

			_card_drag_play != null and _tile_drag_onto is obj tile,
			choose_targets_for_card(obj card<- _card_drag_play, _get_auto_targets_for_card(obj card<- _card_drag_play, [], _tile_drag_onto.loc asserting _tile_drag_onto is obj tile)),

			_card_drag_play != null and _tile_drag_onto is obj card,
			choose_targets_for_card(obj card<- _card_drag_play, [[-2, (int<- _tile_drag_onto.stack_id) asserting _tile_drag_onto is obj card]]),

			_card_drag_play != null and _tile_drag_onto is obj player_avatar,
			choose_targets_for_card(obj card<- _card_drag_play, [[-1, _tile_drag_onto.player_num asserting _tile_drag_onto is obj player_avatar]]),

		   mouse_y < top_player_area - 80, [
			card_clicked(card)
		])
	]",

	_crypt_library_dialog: { type: "obj crypt_library_display_dialog|null" },

	mouse_enter_crypt_library_display: "def(obj crypt_library_display display) ->commands [
		set(display.highlight, true),

		remove_object(_crypt_library_dialog),
		set(_crypt_library_dialog, null),

		if(size(display.items) > 0 and (display.is_crypt or display.player_index = state.nplayer),
		spawn('crypt_library_display_dialog', 0, 0, {
			items: if(display.is_crypt = false, sort(display.item_objects, a.card_type.name < b.card_type.name), display.item_objects),
			parent_display: display,
			zorder: 10500,
			controller: me,
		}, [
			set(me._crypt_library_dialog, child),
		])),
	]",

	mouse_leave_crypt_library_display: "def(obj crypt_library_display display) ->commands [
		log('LEAVE CRYPT LIBRARY'),
		set(display.highlight, false),
		if(_crypt_library_dialog, remove_object(_crypt_library_dialog)),
		set(_crypt_library_dialog, null),
	]",

	mouse_x: "int<- lib.gui.mouse_pos(level)[0]",
	mouse_y: "int<- lib.gui.mouse_pos(level)[1]",

	_prev_mouse_pos: { type: "[int,int]", default: [0,0] },

	_last_mouse_move: { type: "int", default: 0 },

	mouse_enter_discard: "def(int nplayer) ->commands execute(me, [

	])",

	mouse_click_discard: "def(int nplayer) ->commands []",

	mouse_leave_discard: "def(int nplayer) -> commands execute(me, [
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(obj tile tile) ->commands [
		if(_card_drag_play = null, set(tile.mouseover, true)),
		//log(['mouse enter tile', tile.loc]),
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen + if(tile.selectable, _get_auto_targets_for_card(_playing_card, _targets_chosen, tile.loc), [])),
		]),

	if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
	   ]) where card = lib.json.get_document_map('data/cards.cfg')[creature.name])
	      where creature = state.creature_at_loc(tile.loc)
	]",
	mouse_leave_tile: "def(object tile) ->commands [
		if(_card_drag_play = null, set(tile.mouseover, false)),
		remove_preview_card(tile.loc)
	]",

	mouse_enter_log: "def(int index) ->commands null",

	_tutorial: { type: "class client_tutorial", init: "construct('client_tutorial')" },
	_tutorial_init: { type: "bool", default: false },
	client_tutorial_args: { type: "map", default: {} },

	get_tutorial: "class client_tutorial :: _tutorial",
	
	card_clicked: "def(obj card card) ->commands
	if(_playing_card != null and card.stack_id != null and card.is_on_stack_and_targetable,
	choose_targets_for_card(
	  _playing_card, _targets_chosen + [[-2, card.stack_id]]),
	   
	   not myplayer.mulligan,

	set(_amount_channeled, null);
	if(no_mandatory_play,
	[
	if(state.nteam = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false and card not in pending_card_discards,
	  if(_playing_card,
	  [
	  	set(_playing_card, null),
		clear_input_state(),
		bind_command(spawn_cards_in_hand),
	    _spawn_tile_cursors(),
	  ]);

	  [
	   //tile_clicked(null),

	   if(_current_tip != null and _current_tip.tip.key = 'tutorial_play_card' and _current_tip.tip.targets = [card],
			_create_tip_dialog({
				key: 'play_card_pos_tutorial',
				text: 'Click on the tile closest to you to summon your Disciple there.',
				targets: [find_or_die(level.chars, value is obj tile and value.loc = [0,0])],
			})
	   ),

	   if(_current_tip != null and _current_tip.tip.key = 'play_creature' and _current_tip.tip.targets = [card],
	   
	   if(possible_targets != null,
	   [
	   	   _create_tip_dialog({
			  key: 'play_card_pos',
			  text: if(village_targets, 'Click on a tile to summon your creature in that tile. If you summon it in front of a village it will be able to capture the village, gaining you mana each turn.', 'Choose where to summon your creature.'),
			  targets: tile_targets,
		   })
	   ]
	    where tile_targets = filter(level.chars, value is obj tile and value.loc in loc_targets)
		where loc_targets = if(village_targets, village_targets, possible_targets)
	    where village_targets = filter(possible_targets, find(state.lands, value.loc[0] = loc[0] and value.name = 'Village' and value.controller = -1) where loc = Loc :: value)
		)
		where possible_targets = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, if(_selected_creature, _selected_creature.creature_object, myplayer.creature_avatar), []))
		where card_instance = class card<- card.card_type
	   ),

	   bind_command(spawn_cards_in_hand),

	   set(me.card_mouseover, null),
	   remove_object(_discard_card_button),
	   set(_discard_card_button, null),

	   //log(['BBB: CHOOSE TARGETS FOR CARD', card.card_type.name]),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])
	])
	])
	)",

	card_discard: "def(obj card card) ->commands execute(me, [
		if(state.nteam = state.current_player and observer = false and _tutorial.inhibit_card_click(me, card) = false and card.in_hand and card not in pending_card_discards and state.in_response_phase = false and no_mandatory_play,
			if(n >= 0, 
		[
		 if(_mycrypt, _mycrypt.activate_animation()),
		 add(me.pending_card_discards, [card]),
		 set(card.in_hand, false),
		 if(size(avatar_crypts) > state.nplayer,
		 animate(card, {
			mid_x: avatar_crypts[state.nplayer].x - lib.gui.py(20),
			mid_y: avatar_crypts[state.nplayer].y + lib.gui.py(60),
			rotate: 0,
			card_size: 1.0,
		   }, {
			duration: 40,
			name: 'card_discard',
			
			on_complete: remove_object(card); set(pending_card_discards, filter(pending_card_discards, value != card)),
		   })
		 ),
	     set(me.card_mouseover, null),
	     remove_object(_discard_card_button),
	     set(_discard_card_button, null),
	     set(me._playing_card, null),
		 clear_input_state(),
	 	 bind_command(spawn_cards_in_hand),
		 record_stats({
			table: 'discard_card',
			game_uuid: state._uuid,
			card: card.card_type.name,
		 }),
		 send_move_message({
		   type: 'moves',
		   state_id: _processed_state_id,
		   moves: [{
				  type: 'discard_card',
				  player_index: state.nplayer,
				  index: n,
		   }]
		 })
		 ]
		) where n = index(_current_hand, card.card_type)
		)
	])",

	undo_discard: "def() ->commands
	if(state.nplayer = state.current_player_index and myplayer.undoable_discards > 0,
	[
		log('CRYPT UNDO DISCARD'),
		send_move_message({
			type: 'moves',
		   state_id: _processed_state_id,
		   moves: [{
				  type: 'undo_discard',
				  player_index: state.nplayer,
		   }],
		})
	]
	)
	",

	option_clicked: "def(int choice_index, null|int|string choice_value) ->commands
	if(_mulligan_object,
	_mulligan_object.card_clicked(choice_index),
			
	state.nplayer = state.current_player_index,
	execute(me, [
		log('OPTION CLICKED: ', choice_value),
		if(_choice_object and state.current_choice != null,
			if(find(_choice_object.choices_made, value.index = choice_index) != null,
			[
				if(card_obj != null,
					animate(card_obj, {
						mid_y: level_height/2,
					}, {
						duration: 5,
						name: 'choice',
						replace_existing: true,
					})
				),
				set(_choice_object.choices_made, filter(_choice_object.choices_made, value.index != choice_index)),
			],

			add(_choice_object.choices_made, [{
				choice: choice_value,
				index: choice_index
			}]);
			if(size(_choice_object.choices_made) >= state.current_choice.num_choices,
			[
				send_move_message({
					type: 'moves',
					state_id: _processed_state_id,
					moves: [{
						type: 'make_choice',
						choices: _choice_object.choices_made,
					}],
				}),
				_choice_object.exit_dialog(),
				set(_choice_object, null),
			],
			if(card_obj != null,
				animate(card_obj, {
					mid_y: level_height/2 - lib.gui.py(60),
				}, {
					duration: 5,
					name: 'choice',
					replace_existing: true,
				})
			)
			)
			)
			where card_obj = find(level.chars, value is obj card and value.is_choice and value.choice_index = choice_index)
		),
	])
	)",

	mouse_enter_avatar: "def(obj player_avatar item) ->commands [
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen + if(item.selectable, [[-1, item.player_num]], [])),
		]),
	]",

	mouse_leave_avatar: "def(obj player_avatar item) ->commands [
		if(_playing_card != null, [
			set_playing_card_arrows(_targets_chosen),
		]),
	]",

	avatar_clicked: "def(obj player_avatar item) ->commands [
		if(_playing_card != null and item.selectable,
			choose_targets_for_card(
			  _playing_card, _targets_chosen + [[-1, item.player_num]])
		)
	]",

	mana_display_clicked: "def(obj mana_display item) ->commands [
		if(_playing_card != null and item.selectable,
			choose_targets_for_card(
			  _playing_card, _targets_chosen + [[-1, item.player_num]])
		)
	]",
	      
	tile_clicked: "def(obj tile|null tile) ->commands
	if((not state.current_choice) and (no_mandatory_play or tile and tile.selectable), [
	   [set(player.selectable, false) | player <- level.chars, player is obj player_avatar],
	   [set(card.is_on_stack_and_targetable, false) | card <- level.chars, card is obj card],
	   execute(me, 	map(level.chars, if(value is obj tile,
	                                    set(value.selectable, false)))),
	   execute(me, 	map(level.chars, if(value is obj creature,
	                                    set(value.selectable_land, false)))),
	   if(tile and _playing_card != null and tile.selectable,
		 if(_tutorial.inhibit_target(me, _playing_card, _targets_chosen + [tile.loc]),
		  //trying to play something inhibited, flash the tips
		  [tip.flash_tip() | tip<- level.chars, tip is obj tip_dialog],

		  //not inhibited, play the card.
		  choose_targets_for_card(_playing_card,
			_targets_chosen + (_get_auto_targets_for_card(_playing_card, _targets_chosen, tile.loc)))
		 ),

		if(no_mandatory_play,
		[
		clear_input_state(),
		bind_command(spawn_cards_in_hand)
		])

	   ),
	   _spawn_tile_cursors(),
	 ])
	 ",

	tile_right_clicked: "def(obj tile|null tile) ->commands
		tile_clicked(null)
	",

	_get_auto_targets_for_card: "def(obj card card, [Loc] current_targets, Loc additional_target) ->[Loc]
	if(card_instance = null or card_instance.auto_target = false, [additional_target],

		if(possible_targets != null and
		   size(possible_targets) = 1 and
		   card_instance.is_play_likely_misclick(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar), [additional_target, possible_targets[0]]) = false,
		   [additional_target, possible_targets[0]],
		   [additional_target]
		)

		where possible_targets = if(possible_targets_unpriced != null,
		                            filter(possible_targets_unpriced, myplayer.can_afford_with_target(state, card_instance, value))
								 )
		where possible_targets_unpriced = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar), current_targets + [additional_target]))
	)
	 where card_instance = null|class card_base <- if(card.card_type is class card_base, card.card_type, null)
	",
	
	choose_targets_for_card: "def(obj card card, [Loc] current_targets) ->commands
	execute(me,
	if(card_instance and state.in_response_phase and (not card_instance.is_response) and (not card.mandatory_play),

			spawn('label', {
						mid_x: level_width/2,
						mid_y: int(level_height*0.4),
						_text: ['Can only cast response spells during response phase'],
						_font_size: lib.gui.py(46),
						zorder: 10000,
						_color: [1,0,0,1],
					}, [
						schedule(40, animate(child, {
							alpha: 0,
						}, {
							duration: 20,
							on_complete: remove_object(child),
						}))
					]),
			
		_amount_channeled = null and card.card_type.is_channeled and max_channel >= 0,
		spawn('channeling_dialog', 0, 0, {
			_mm: me,
			_controller: me,
			_on_complete: bind_command(_choose_targets_for_card_after_channeling, card, current_targets),
			_max_channel: max_channel,
			_base_cost: card_cost,
			card: card,
		}),

		_choose_targets_for_card_after_channeling(card, current_targets)
	)
	  where max_channel = (state.players[state.nplayer].resources - card_cost)
	  where card_cost = state.players[state.nplayer].calculate_cost(card.card_type)

	 where card_instance = null|class card_base <- if(card.card_type is class card_base, card.card_type, null)
	)
	",

	_last_terrible_play: { type: "null|{card: string, targets: [Loc], turn: int}" },

	_record_terrible_play_attempt: "def(class card_base card, [Loc] targets) ->commands
		set(_last_terrible_play, { card: card.name, targets: targets, turn: state.nturn })
	",

	_seems_a_terrible_play: "def(class card_base card, [Loc] targets) ->null|Tip
	if(lib.citadel.get_preference_bool('protect_from_bad_moves', true) = false or _last_terrible_play = { card: card.name, targets: targets, turn: state.nturn }, null,

	(AI_CARD_NEVER_TARGET_FRIENDS in card.ai_flags) and target_creature and target_creature.controller = state.nplayer,
	{
		key: 'bad_play',
		text: q(Do you really want to cast this card on your own creature? It's harmful and usually used on enemies. (Do it again to cast it anyway).),
		title: 'Careful there!',
		max_shows: null,
		has_protect_me: true,
	}
	)
	where target_creature = if(size(targets) > 0, state.creature_at_loc(targets[0]))
	",

	_choose_targets_for_card_after_channeling: "def(obj card card, [Loc] current_targets, bool cast_now=false) ->commands
	[
	set(_playing_card_cast_button, null),
	execute(me,
	[
	   if(card_instance and (
			   (card.hand_index != null and card.parent_creature = null) or
			   (card.parent_creature and
				  (
			        card.mandatory_play or

					(
			          ((creature != null and find(creature.activated_abilities, value._uuid = card.card_type._uuid) != null) where creature = find(state.permanents, value.summon_id = card.parent_creature.summon_id)) and
			          card.parent_creature.controller = state.current_player and card.parent_creature.summon_id != null
					)
				  )
			   )
			  ) and
		  state.nteam = state.current_player and
		  observer = false,
	       [
		    if(can_afford and is_usable and possible_targets != [] and not unique_violation,
		      if((possible_targets = null or cast_now) and _seems_a_terrible_play(card.card_type, current_targets),
				[
					_record_terrible_play_attempt(card.card_type, current_targets),
					_create_tip_dialog(_seems_a_terrible_play(card.card_type, current_targets)),
					clear_input_state();
					spawn_cards_in_hand(),
				],
				 possible_targets = null or cast_now,
				([
				 set(locked_mana, null),

				 set(_amount_channeled, null),

				//log('send cast'),
				 send_move_message({
				   type: 'moves',
				   state_id: _processed_state_id,
				   moves: [play_card_message],
				  }) asserting _client,

				 record_stats({
					table: 'play_card',
					game_uuid: state._uuid,
					card: card.card_type.name,
					turn: state.nturn,
					targets: current_targets,
				 }),

				 //make the card animate to the playing position if it's
				 //not there already. Then clear out the input state so
				 //we don't send multiple messages before receiving a reply.
				 set(me._playing_card, card); set(me._playing_card, null),
				 clear_input_state(),
				 if(card.mandatory_play, [
					set(_selected_creature, null),
					remove_object(card),
				 ]),

				 //simulate the card playing immediately so we see something happening
				 ; 
				 handle_errors([
				 	state.play_card(construct('message.play_card', play_card_message))
				 ], [
				 	cancel(),
				 ]);
				 spawn_cards_in_hand();
				 if(state.stack,
					 play_animation_hint(construct('animation.play_card_hint', {
						type: 'play_card_hint',
						card: card.card_type,
						player: state.nplayer,
						targets: if(card.parent_creature, [card.parent_creature.loc], []) + current_targets,
						info: back(state.stack),
						stack_id: back_or_die(state.stack).stack_id,
					 }))
				 )
				] asserting card_instance.targets_valid(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar), current_targets)
				  where play_card_message = {
					type: 'play_card',
					index: if(card.parent_creature, -1, card.hand_index),
					player_index: state.nplayer,
					targets: current_targets,
					channel: if(card.card_type.is_channeled and _amount_channeled != null, _amount_channeled, 0),

					creature: if(card.parent_creature, card.parent_creature.summon_id, -1),
					ability: if(card.parent_creature, card.card_type.name, ''),
					ability_uuid: if(card.parent_creature, card.card_type._uuid, ''),
					free_ability: card.mandatory_play,
				  }
				),

				//one possible card target; auto-select it.
				possible_targets != null and size(possible_targets) = 1 and possible_targets[0][0] = -2,
				add(_targets_chosen, [Loc]<- possible_targets); choose_targets_for_card(card, _targets_chosen),

			    [
				 [set(player.selectable, [-1, player.player_num] in possible_targets) | player <- level.chars, player is obj player_avatar],
	   			 [set(card.is_on_stack_and_targetable, [-2, card.stack_id] in possible_targets) | card <- level.chars, card is obj card, card.stack_id != null],
				 map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
			     [set(c.selectable_land, c.creature_object.loc in possible_targets) | c <- level.chars, c is obj creature, c.creature_object.is_land],

				 _spawn_tile_cursors(),
				 set(me._playing_card, card),
				 set(_targets_chosen, current_targets),
				set_playing_card_arrows(current_targets),

				 if(card.card_type.min_targets is int and size(current_targets) >= card.card_type.min_targets,
					spawn('button_controller', {
						mid_x: lib.gui.py(166),
						y: lib.gui.py(250),
						button_width: lib.gui.py(80),
						button_height: lib.gui.py(30),
						zorder: get_zorder('hud'),
						text: 'Cast',
						on_click: bind(me._choose_targets_for_card_after_channeling, card, current_targets, true),
					}, [
						set(_playing_card_cast_button, child),
					]),
				 )
				]
				),
				
				//card not castable, try to come up with a message why not
				if(reason,
					lib.sound.play_sound(me, 'interface/ui_error');
					spawn('label', {
						mid_x: level_width/2,
						mid_y: int(level_height*0.4),
						_text: [reason],
						_font_size: lib.gui.py(46),
						zorder: 10000,
						_color: [1,0,0,1],
					}, [
						schedule(40, animate(child, {
							alpha: 0,
						}, {
							duration: 20,
							on_complete: remove_object(child),
						}))
					])
				)
				where reason = if(reason_custom, reason_custom,
				                  card_instance.uses_attack and _casting_creature != null and not _casting_creature.has_action,
								  'Creature has already attacked this turn',
								  card_instance.uses_movement and _casting_creature != null and _casting_creature.spaces_moved_this_turn >= _casting_creature.move,
								  'Creature has already moved this turn',
				                  card_instance.is_on_cooldown,
								  'Can only use this ability once per turn',
								  possible_targets_unpriced = [] and unique_violation,
								  'Cannot play multiple copies of a hero',
								  possible_targets_unpriced = [], 'No valid targets',
								  'Not enough mana')
				where reason_custom = card_instance.custom_reason_cannot_cast(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar))


			  )]
		where unique_violation = card_instance.hero and card_instance.creature and find(state.creatures, value.name = card_instance.name and value.controller = state.nplayer)

	    where is_usable = card_instance.is_usable(state, _casting_creature) and
		                  (card_instance.uses_movement = false or _casting_creature != null and _casting_creature.spaces_moved_this_turn < _casting_creature.move) and
						  (card_instance.uses_attack = false or _casting_creature != null and _casting_creature.has_action)
		where can_afford = (card.parent_creature = null or card_instance.is_on_cooldown = false) and
		                   if(possible_targets = [], false,
		                      possible_targets != null or current_targets, true,
		                      myplayer.can_afford(card_instance)
						   )
		where possible_targets = if(possible_targets_unpriced != null,
		                            filter(possible_targets_unpriced, myplayer.can_afford_with_target(state, card_instance, value))
								 )
		where possible_targets_unpriced = _tutorial.filter_targets(me, card_instance, card_instance.possible_targets(state, if(card.parent_creature, card.parent_creature, myplayer.creature_avatar), current_targets)))
	 ])] where card_instance = null|class card_base <- if(card.card_type is class card_base, card.card_type, null)",

	_spawn_tile_cursors: "def() ->commands bind_command(_spawn_tile_cursors_internal)",

	_spawn_tile_cursors_internal: "def() ->commands
	[
	if(find(level.chars, value is obj tile and value.selectable or value is obj player_avatar and value.selectable) = null,
	   [ remove_object(cursor) | cursor <- level.chars, cursor is obj tile_cursor], [
		[remove_object(cursor) | cursor <- level.chars, cursor is obj tile_cursor, find(level.chars, value = cursor.tile) = null or cursor.tile.selectable = false],

		[fire_event(cursor, 'create') | cursor <- level.chars, cursor is obj tile_cursor, find(level.chars, value = cursor.tile) != null],

		[spawn('tile_cursor', 0, 0, {hex_height: tile_height, tile: tile}) | tile <- level.chars, tile is obj tile, find(level.chars, value is obj tile_cursor and value.tile = tile) = null]

	]),

	]",
	
	creature_clicked: "def(obj creature creature, int mouse_button) ->commands execute(me, [
		if(mouse_button = 3 and MODULE_OPTIONS.devtools,
			spawn('context_menu', {
				x: lib.gui.mouse_pos(level).x,
				y: lib.gui.mouse_pos(level).y,
				color_scheme: lib.citadel.library_color_scheme,
				items: [{
					text: '(devtool) Card Adjustment',
					on_select: def()->commands _devtool_card_adjust(creature),
				}],
			})
		)
	])",

	_devtool_card_adjust: "def(obj creature creature) ->commands
	execute(me, [
		[set(c.paused, false) | c <- level.chars, c != me];
		[add(c.y, 100000) | c <- level.chars];
		set(in_background, true);

		spawn('card_adjustment_controller', {
			_mm_client_state: _mm_client_state,
			_return_fn: me._return_from_devtools,
			cards: [creature.creature_object.name],
		})
	])
	",

	_return_from_devtools: "def() ->commands
		[remove_object(c) | c <- level.chars, c.y < 50000];
		[set(c.paused, false) | c <- level.chars, c != me];
		set(in_background, false);
		[add(c.y, -100000) | c <- level.chars, c.y > 50000]
	",
	
	can_use_ability: "def(class creature creature, string ability_name) ->bool
	 state.nteam = state.current_player and observer = false and
	 state.nplayer = creature.controller and
	 ((not state.in_response_phase) or ability.is_response) and
	 (not ability.is_on_cooldown) and
	 (ability.uses_attack = false or creature.has_action) and
	 (ability.uses_movement = false or creature.spaces_moved_this_turn < creature.move) and
	 can_afford and
	 creature.summoned and
	 ability.is_usable(state, creature) and
	 ability.possible_targets(state, creature, []) != []
	  
	  where can_afford = if(possible_targets = [], false, possible_targets != null, true, myplayer.can_afford(ability))
	  where possible_targets = if(possible_targets_unpriced != null,
		                            filter(possible_targets_unpriced, myplayer.can_afford_with_target(state, ability, value))
								 )
	  where possible_targets_unpriced = ability.possible_targets(state, creature, [])
	  where ability = find_or_die(creature.activated_abilities, value.name = ability_name)",
	 
	set_status_label: "def(string msg, string color) -> commands [
	]",
	
	_preview_creature: {
		type: "null|custom_obj",
		set: "[
			remove_object(_data),
			set(_data, value),
		]"
	},
	
	set_playing_card_arrows: "def([Loc] targets) ->commands [
		set(_preview_creature, null),

		if(_playing_card != null and targets != [],
		[
			if(target_creature != null and creature_obj != null and target_creature.modify_card_cost_targeted_at(_playing_card.card_type, state.nplayer) > 0, [
				show_invalid_target_tip(sprintf('This creature has <i>Magic Resistance</i>. Targeting it with a spell will cost %d additional mana', target_creature.modify_card_cost_targeted_at(_playing_card.card_type, state.nplayer)), creature_obj, 'Magic Resistant Target'),
				set(_tooltip_locked_by, creature_obj),
				set(creature_obj.has_mouseover, true),
			]),
		] 
		  where creature_obj = if(target_creature, find(level.chars, value is obj creature and value.creature_object = target_creature))
		  where land_obj = if(target_land, find(level.chars, value is obj creature and value.creature_object = target_land))
		  where target_creature = state.creature_at_loc(target_loc)
		  where target_land = state.land_at_loc(target_loc)
		  where target_loc = back_or_die(targets)
		),

		set(_current_presence_targets, targets),

		if(_playing_card != null and targets != [] and _playing_card.card_type is class card and _playing_card.card_type.creature_object != null and _playing_card.card_type.creature_object.is_land = false and _playing_card.card_type.targets_valid(state, myplayer.creature_avatar, targets), [

		if(creature != null,
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: creature,
				  game_state: outcome,
				  controller: me,
				  hex_height: tile_height,
				  _is_preview: true,
				},
				[
					set(me._preview_creature, child),
				]),
		  if(target_tile != null,
			spawn('game_icon', target_tile.mid_x, target_tile.mid_y - py(16), {
			  size: 48,
			  zorder: get_zorder('status_icon'),
			  icon: 'death-icon.svg',
			  user_info: 'creature_preview'
			}, [
				set(me._preview_creature, child)
			]
		    )) where target_tile = find(level.chars, value is obj tile and value.loc = targets[0])
		  ),

		  //obj represents the existing object representing this creature.
			
		] where creature = outcome.creature_at_loc(targets[0]) or find(outcome.creatures, value.name = _playing_card.card_type.creature_object.name and find(state.creatures, value.summon_id = context.value.summon_id) = null)
		  where outcome = _calculate_play_card(state, _playing_card.card_type, targets)
		),

		if(_playing_card, _set_arrows_for_card(_playing_card, targets)),

	]",

	_find_target_object: "def(Loc target) ->null|custom_obj
		find(level.chars, value is obj tile and value.loc = target or value is obj player_avatar and target = [-1, value.player_num] or value is obj card and value.stack_id != null and target = [-2, value.stack_id])
	",

	_set_arrows_for_card: "def(obj card card, [Loc] targets) ->commands
	set(card.arrows,
	map(targets,
		object('arrow', {
			zorder: card.zorder+1,
			mid_x: 0,
			mid_y: 0,
			arrow_texture: if(not card.show_back, card.card_type.arrow_texture),
			start_point: [if(card.in_opponent_hand, card.x, card.x2), card.mid_y + 40*(index+1)/(size(targets)+1)],
			end_point: [target_tile.mid_x, target_tile.mid_y],
		})

		 where target_tile = _find_target_object(value) or card
	) +

	if(card.card_type is class activated_ability and _selected_creature != null,
	[
		object('arrow', {
			zorder: card.zorder+1,
			mid_x: 0,
			mid_y: 0,
			arrow_texture: if(not card.show_back, card.card_type.arrow_texture),
			start_point: [_selected_creature.mid_x, _selected_creature.mid_y],
			end_point: [card.mid_x, card.y2],
		})
	],
	[]
	)
	)
	",
	
	card_on_stack: "def(object card) ->class message.play_card_base|null
	   find(state.stack, value.stack_id = card.stack_id)
	     asserting _state",
	
	play_animation_hint: "def(class animation hint) ->commands
	;
	[
	map(hint.sounds, lib.sound.play_sound(me, value)),
	if(hint is class animation.fizzle_hint, play_fizzle_hint(hint),
	   hint is class animation.resolve_hint, play_resolve_hint(hint),
	   hint is class animation.creature_attack_hint, play_creature_attack_hint(hint),
	   hint is class animation.creature_die_hint, play_creature_die_hint(hint),
	   hint is class animation.creature_particle_hint, play_creature_particle_hint(hint),
	   hint is class animation.play_card_hint, play_card_hint(hint),
	   hint is class animation.move_hint, play_move_hint(hint),
	   hint is class animation.gain_mana_hint, play_gain_mana_hint(hint),
	   hint is class animation.creature_shatter_seal_hint, play_creature_shatter_seal_hint(hint),
	   hint is class animation.player_damage_hint, play_player_damage_hint(hint),
	   hint is class animation.shadow_damage_hint, play_shadow_damage_hint(hint),
	   hint is class animation.shard_damage_hint, play_shard_damage_hint(hint),
	   hint is class animation.creature_effect_hint, play_creature_effect_hint(hint),
	   hint is class animation.summon_creature_hint, play_summon_creature_hint(hint),
	   hint is class animation.redirect_target_hint, play_redirect_target_hint(hint),
	   hint is class animation.discard_card_hint, play_discard_card_hint(hint),
	   hint is class animation.creature_voice_hint, creature_voice_hint(hint),
	   hint is class animation.delay_hint, delay_hint(hint)
	),
	]
	",

	play_fizzle_hint: "def(class animation.fizzle_hint hint) ->commands

	  if(fizzling_card, fizzling_card.start_fizzle_animation())
		where fizzling_card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	",

	play_resolve_hint: "def(class animation.resolve_hint hint) ->commands
	if(card != null,
		[
			card.start_resolve_animation(targets),
		]
		where targets = filter(level.chars, value is obj tile and value.loc in stack_item.targets) + filter(level.chars, value is obj player_avatar and [-1,value.player_num] in stack_item.targets)
		where stack_item = class message.play_card_base<- card.stack_info
	)
	where card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	",

	play_creature_attack_hint: "def(class animation.creature_attack_hint hint) ->commands
	if(creature_obj, [
		if(engagement_icon,
			animate(engagement_icon, {
				alpha: 0,
				scale: 2.0,
		    }, {
				duration: 10,
				on_complete: remove_object(engagement_icon),
		   })
		)
		where engagement_icon = find(level.chars, value is obj game_icon and value.user_info is list and value.user_info[0] = 'status_icon' and value.user_info[1] = attack_hint.attacker.summon_id),
		creature_obj.play_attack_animation(attack_hint),

		//reorder animations so that fights between creatures and then deaths occur before other fights.
		if(retaliation != null or death != null,
			set(_animation_queue, if(retaliation, [retaliation], []) + if(death, [death], []) + filter(_animation_queue, value not in [retaliation, death, attack_hint]))
		)
	])
		//reorder things here so that given the first strike status
		//is the same, the creature whose turn it is strikes first.
		where creature_obj = find(level.chars, value is obj creature and value.creature_object._uuid = attack_hint.attacker._uuid)
		where attack_hint = if(retaliation = retaliation_obj, hint, class animation.creature_attack_hint<- retaliation_obj)
		where retaliation = if(retaliation_obj != null, if(retaliation_obj.first_strike = hint.first_strike and retaliation_obj.attacker.controller = state.current_player_turn_index, hint, retaliation_obj))
		where retaliation_obj = find(_animation_queue, value is class animation.creature_attack_hint and value.defender = hint.attacker and value.attacker = hint.defender)
		where death = find(combat_animation_queue, value is class animation.creature_die_hint and value.creature = hint.defender)

		//the portion of the animation queue where combat is happening. Don't count anything after any move event.
		where combat_animation_queue = if(move_hint, _animation_queue[:index(_animation_queue, move_hint)], _animation_queue)
		where move_hint = find(_animation_queue, value is class animation.move_hint)
	",

	play_creature_effect_hint: "def(class animation.creature_effect_hint hint) ->commands
	if(creature_obj, [
		reserve_animation_time('creature_effect', hint.delay),
		creature_obj.add_creature_effect(hint.effect),
	])
		where creature_obj = find(level.chars, value is obj creature and value.creature_object._uuid = hint.creature._uuid)
	",

	play_creature_die_hint: "def(class animation.creature_die_hint hint) ->commands
	if(creature_obj, [
		creature_obj.play_death_animation(hint),

		if(creature_obj.creature_object.hero, play_hero_death_music(), play_creature_death_music()),
	])
		where creature_obj = find(level.chars, value is obj creature and value.creature_object._uuid = hint.creature._uuid) or
		find(level.chars, value is obj creature and value.creature_object.summon_id = hint.creature.summon_id)
	",

	play_creature_particle_hint: "def(class animation.creature_particle_hint hint) ->commands
	if(creature_obj, [
		if(hint.delay > 0, reserve_animation_time('particle_effect', hint.delay)),
		creature_obj.play_particle_hint(hint),
	])
		where creature_obj = find(level.chars, value is obj creature and value.creature_object._uuid = hint.creature._uuid)
	",

	play_card_hint: "def(class animation.play_card_hint hint) ->commands
	
	if(find(level.chars, value is obj card and value.stack_id != null and value.card_type._uuid = hint.card._uuid) = null,
	  ([
		reserve_animation_time('play_card', if(item.player_index = state.nplayer and observer = false, lib.animation_timings.play_card_on_stack_time + _card_hover_on_stack_time, if(lib.citadel.preferences.fast_opponent_plays != true, 30, 30)) where item = hint.info),

		// TODO 'target_particles' yet not enabled to use 'hidden_in_opponent_client' and 'hidden_in_player_client'.
		map(hint.card.target_particles,
			map(hint.targets,
				if (target_index = target_particle_index or not effect.assign_to_one_target,
				schedule(int((effect.delay_start or 0.0)*60),
					spawn('target_particle_effect', {
						zorder: 1000 + if(effect.zorder = null, context.index, effect.zorder),
						_type: effect.effect,
						controller: me,
						_starting_state_id: get_state_id(),
						_stack_id: hint.info.stack_id,

						mid_x: pos.x + lib.gui.py(effect_pos.x),
						mid_y: pos.y + lib.gui.py(effect_pos.y),

						_delay_end: int((effect.delay_end or 0.0)*60),
						_fade_time: int((effect.fade_time or 0.4)*60),

						end_anim: effect.end_anim,

					//	_path_endpoint: pos,
					}, [
						if(effect.start_anim, child.play_anim(effect.start_anim)),
					]) where pos = get_tile_pos(value)
				))
				where target_index = index
				where target = value
			)
			where target_particle_index = index
			where target_particle = value

			where effect_pos = effect.pos or [0,0]
			where effect = value
		),

		//   'x_locs_ct' and 'y_locs_ct' seem good future candidates to
		// parametrization.
		//   TODO fork *_locs_ct in several cases depending on the
		// screen ratio, 4:3 ratios (some tablets?) maybe could benefit
		// from a different particle centers structure than (nowadays
		// more typical) widescreen devices.
		map(hint.card.wide_particles,
			// TODO probably wanting to use team_index instead of player_index
			if (hint.player = state.current_player_index and not effect.hidden_in_opponent_client or  // TODO Why is a reverse logic that what is working here as intended?
			                                                                                          //      It should be 'not effect.hidden_in_player_client' instead.
					hint.player != state.current_player_index and not effect.hidden_in_player_client  // TODO Why is a reverse logic that what is working here as intended?
					                                                                                  //      It should be 'not effect.hidden_in_opponent_client' instead.
					,
			//   Outer loop iterating y, inner loop iterating x.
			map(range(y_locs_ct),
			map(range(x_locs_ct),
				schedule(
					int((effect.delay_start or 0.0) * 60),
					spawn('target_particle_effect', {
						zorder: 1000 + if (
							effect.zorder = null, 0,
							effect.zorder),
						_type: effect.effect,
						controller: me,
						_starting_state_id: get_state_id(),
						_stack_id: hint.info.stack_id,
						mid_x:
//							lib.gui.py(
								floor(x_offset)
//							)
							,
						mid_y:
//							lib.gui.py(
								floor(y_offset)
//							)
							,
						_delay_end: int((effect.delay_end or 0.0) * 60),
						_fade_time: int((effect.fade_time or 0.4) * 60),
						end_anim: effect.end_anim,
					}, [
						if (effect.start_anim,
							child.play_anim(
							effect.start_anim)),
					])
				) where x_offset = x_interval_len + value * x_interval_len
			) where y_offset = y_interval_len + value * y_interval_len
			)
			) where effect = value
		)
		where x_interval_len = 1.0 * max_x / x_intervals_ct
		where y_interval_len = 1.0 * max_y / y_intervals_ct
		where x_intervals_ct = x_locs_ct + 1
		where y_intervals_ct = y_locs_ct + 1
		where x_locs_ct = 4
		where y_locs_ct = 3
		where min_x = dim[0]
		where min_y = dim[1]
		where max_x = dim[2]
		where max_y = dim[3]
		where dim = level.dimensions
		,

		set(_spell_animation_time, 0),

		spawn('card', xloc, px(260 + 40*size(state.stack)),
		  {
			 card_type: hint.card,
			 controller: me,
			 in_hand: false,
			 allow_drag: true,
			 stack_id: hint.stack_id,
			 stack_info: hint.info,
			 card_size: 2.0,
			 alpha: if(prev_card, prev_card.alpha, 0),
			 zorder: get_zorder('card_stack_base') + hint.stack_id,
		  },
			   [
			    if(_animated_spell_card, [
		   		    add(_spells_on_stack, [_animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(_animated_spell_card, child),
				[
				  //if(windup_sound, sound_loop(windup_sound, lib.sound.sound_volume(windup_sound), 0.5)),
				  if(windup_sound, lib.sound.play_sound(me, windup_sound)),
				] where windup_sound = hint.card.windup_sound,
				schedule(20, set(child.arrows, filter(map(hint.targets, if(target_tile,

			object('arrow', {
				zorder: child.zorder+1,
				mid_x: 0,
				mid_y: 0,
				arrow_texture: hint.card.arrow_texture,
				start_point: if(is_casting_creature, target_point, card_point),
				end_point: if(is_casting_creature, card_point, target_point),
			})

			where card_point = [int(xloc + if(target_tile.mid_x < xloc, -40, 40)),
					            284 + 40*(index+1)/(size(hint.targets)+1)]
			where target_point = [target_tile.mid_x, target_tile.mid_y]
			where is_casting_creature = (hint.card is class activated_ability and index = 0)

		   ) where target_tile = find(level.chars, value is obj tile and value.loc = context.value or context.value[0] = -1 and value is obj player_avatar and value.player_num = context.value[1] or context.value[0] = -2 and value is obj card and value.stack_id = context.value[1])), value != null))),

				  if(prev_card != null, child.animate_from(prev_card, lib.animation_timings.play_card_on_stack_time)),
				  remove_object(prev_card),
				]) where prev_card = find(level.chars, value is obj card and value.card_type._uuid = hint.card._uuid)

]
	  where xloc = if(hint.player = state.nplayer, level_width*0.15, level_width*0.85)
	  ),

	  log(['QUEUE_STATE COULD NOT FIND CARD', find(state.stack, value.stack_id = hint.stack_id) != null, find(level.chars, value is obj card and value.stack_id != null and value.card_type = hint.card) = null])
	)
	",

	play_move_hint: "def(class animation.move_hint hint) ->commands
	[
		log('MOVE HINT'),
		reserve_animation_time('move_creature', lib.animation_timings.creature_move_time),
		map(hint.moves, if(creature, [
			if(movement_arrow, movement_arrow.activate_and_die()),
			creature.animate_movement(value.dest, value.type),
			if(state.is_loc_on_board(value.dest) and state.is_loc_in_endzone([value.dest[0], value.dest[1] + if(creature.creature_object.controller = 0, 1, -1)], creature.creature_object.controller),
				play_danger_music()
			),
		]) where movement_arrow = find(movement_arrows, value.src_tile = context.value.source and value.dst_tile = context.value.dest)
		   where creature = find(level.chars, value is obj creature and value.creature_object._uuid = context.value.creature._uuid)),
	]
	",

	play_gain_mana_hint: "def(class animation.gain_mana_hint hint) ->commands
		log('HINT :: GAIN MANA HINT')
	",

	play_creature_shatter_seal_hint: "def(class animation.creature_shatter_seal_hint hint) ->commands
	if(seal != null and creature != null, [
		creature.play_shatter_seal_animation(seal),
		_remove_trophy_label(seal),
	])
	where seal = find(_trophy_labels, value.lane_num = hint.target_lane and value.player_num = hint.target_player)
	where creature = find(level.chars, value is obj creature and value.creature_object._uuid = hint.creature._uuid)
	",

	play_player_damage_hint: "def(class animation.player_damage_hint hint) ->commands if(src and hint.target_player < size(avatar_life), [

		if(state.players[hint.target_player].life - hint.intensity < 20, play_climax_music(hint.target_player = state.nplayer)),

		add(_animation_end_time, lib.animation_timings.creature_attack_player_total_time),
		src.play_endzone_animation(hint.amount, hint.intensity, hint.target_player, hint.anim_type)
	]
	  where lifebar = if(hint.target_player >= 0 and hint.target_player < size(avatar_life), avatar_life[hint.target_player])
	) where src = find(level.chars, value is obj creature and value.creature_object._uuid = hint.source._uuid)",

	play_shadow_damage_hint: "def(class animation.shadow_damage_hint hint) ->commands
		if(hint.target_player < size(_avatars) and source != null, [
			spawn('particle_controller', {
				_type: 'bloodcord',
				mid_xy: source.mid_xy,
				_path_endpoint: avatar.mid_xy,
				zorder: 10000,
			}, [
			]),

			schedule(24, avatar.flash_hit()),
		]
		where avatar = _avatars[hint.target_player]
		)
		where source = find(level.chars, value is obj card and value.card_type._uuid = hint.source._uuid)
	",

	play_shard_damage_hint: "def(class animation.shard_damage_hint hint) ->commands
	if(card != null, card.animate_shard(hint))
	where card = find(level.chars, value is obj card and value.card_type._uuid = hint.card._uuid)
	",

	play_summon_creature_hint: "def(class animation.summon_creature_hint hint) ->commands
	if(existing = null and _state != null,
		spawn('creature', {
		  creature_object: hint.creature,
		  game_state: state,
		  controller: me,
		  hex_height: tile_height,
		}, [
			child.play_summon_animation(hint),
		])
	)
	where existing = find(level.chars, value is obj creature and value.creature_object._uuid = hint.creature._uuid)
	",

	play_redirect_target_hint: "def(class animation.redirect_target_hint hint) ->commands
	if(card != null, [
		if(card.stack_info != null, set(card.stack_info.targets, hint.new_targets)),
		map(card.arrows,
		if(new_target,
			animate(value, {
				end_point: [new_target.mid_x, new_target.mid_y],
			}, {
				duration: 10,
				on_process: value.update(),
			})
		)
			where new_target = if(size(hint.new_targets) > index, _find_target_object(hint.new_targets[index]))
		)
	])

	where card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	",

	play_discard_card_hint: "def(class animation.discard_card_hint hint) ->commands
	if(hint.player != state.nplayer, if(card_obj != null, [
		reserve_animation_time('discard_card', 60),

		if(_theircrypt, _theircrypt.activate_animation()),

		schedule(20, ;
		spawn('label', {
			_text: ['Discard'],
			_font_size: lib.gui.py(46),
			mid_x: level_width/2,
			mid_y: int(level_height*0.6),
			zorder: 20000,
		}, [
			schedule(30, remove_object(child)),
		])
		),

		card_obj.flip_card_over(false, 20, 2.0),

		animate(card_obj, {
			mid_x: level_width/2,
			mid_y: int(level_height*0.4),
			card_size: 2.0,
		}, {
			duration: 20,
			name: 'discard',
			replace_existing: false,
		}),

		animate(card_obj, {
			mid_x: level_width/2,
		}, {
			duration: 20,
			name: 'discard',
			replace_existing: false,
		}),

		animate(card_obj, {
			mid_x: hand_left_side*level_width - py(260),
			mid_y: py(0),
			card_size: 1.0,
			alpha: 0,
		}, {
			duration: 20,
			name: 'discard',
			replace_existing: false,
		}),

	])

		where card_obj = find(level.chars, value is obj card and value.card_type._uuid = hint.card._uuid and value.in_opponent_hand)
	)
	",

	creature_voice_hint: "def(class animation.creature_voice_hint hint) ->commands
	if(creature_obj != null,
		creature_obj.play_voice_hint(hint)
	)
		where creature_obj = find(level.chars, value is obj creature and value.creature_object._uuid = hint.creature._uuid)
	",

	delay_hint: "def(class animation.delay_hint hint) ->commands
		reserve_animation_time('delay', int(hint.time_seconds*60.0))
	",

	//Amount of time the card 'hovers' still waiting to play.
	_card_hover_on_stack_time: 20,

	set_widgets_for_message: "def(class game_state game) ->commands
	[
	  if(_end_turn_button, remove_object(_end_turn_button)),
	  set(_end_turn_button, null),

	  spawn('end_turn_button', {
			x: level_width - lib.gui.py(210),
			y: level_height - lib.gui.py(100),
			button_active: game.nteam = game.current_player and observer = false and _end_turn_pending = false and game.players[game.nplayer].has_ended_turn = false and (game.free_ability = null or not game.free_ability.mandatory) and game.in_mulligan = false and not _auto_send_end_turn(game),
			_width: lib.gui.py(194),
			_height: py(80),
			_controller: me,
			_text: if(
				game.free_ability, 'Cancel',
				game.in_response_phase, if(game.has_unresolved_combat = false and game.stack = [], 'Last Pass', 'Pass'),
				game.has_unspent_moves, 'Move All',
				game.has_unresolved_combat, 'Combat',
				'End Turn'),
			_turn: if(observer,
			lib.chat.nick_display(game.players[game.current_player_turn_index].name) + q('s Turn),
			game.nteam = game.current_player_turn_index, 'Your Turn', q(Opponent's Turn)),
			_phase: if(game.free_ability, 'Triggered Ability', game.in_response_phase, if(game.stack != [], 'Response Phase', if(game.has_unresolved_combat, 'Combat Response Phase', 'Last Chance Response Phase')), 'Play Phase'),
			zorder: get_zorder('hud'),
			highlight: game.in_response_phase or (not game.players[game.current_player].has_possible_play(game)) and (game.players[game.current_player].resources < 3 or not has_mulligan)
			  where has_mulligan = (game.nturn <= 1 and find(game.players[game.current_player].hand, value.original_hand_card) != null)
		}, [
			set(_end_turn_button, child),
		]),

	    set_widgets([])
	]",
	
	set_schedule_for_message: "def(class game_state game) ->commands [

	]",

	_board_dim_override: { type: "null|[int,int]" },
	_board_center_override: { type: "null|[int,int]" },

	board_ypos: "int :: if(_board_center_override, _board_center_override.y - board_height/2, lib.gui.py(if(_state and _state.rows = 1, 140, 100)))",

	board_width: "int :: if(_board_dim_override, _board_dim_override.x, py(834))",
	board_height: "int :: if(_board_dim_override, _board_dim_override.y, py(if(_state and _state.rows = 1, 540, 648)))",

	board_center: "[int,int] :: _board_center_override or [level_width/2, board_ypos + board_height/2]",

	tile_width: "int :: round_to_even(lib.hex.width_from_height(tile_height))",
	tile_height: "int :: tile_y_spacing",
	tile_x_spacing: "int :: board_width/state.rows",
	tile_y_spacing: "int :: board_height/state.columns",

	px: "def(int pixels) ->int lib.gui.py(pixels)",
	py: "def(int pixels) ->int lib.gui.py(pixels)",


	_trophy_labels: { type: "[obj seal]", default: [] },

	_remove_trophy_label: "def(obj seal seal) ->commands [
		set(_trophy_labels, filter(_trophy_labels, value != seal)),
	]
	",

	spawn_trophies: "def(class game_state game) ->commands [
		map(_trophy_labels, [
		  if(game.trophies[value.player_num][value.lane_num] = 0, [
			_remove_trophy_label(value),
			remove_object(value),
		  ]),
		]),

		map(game.trophies, map(value,
		 if(value > 0 and existing != null,
			set(existing.threatened, threatened),

		  value > 0,
		 spawn('seal', pos[0], pos[1] + (if(nplayer = state.nplayer, tile_height + seal_size/2, -tile_height - seal_size/2)*55)/100, {
			controller: me,

			zorder: get_zorder('seals'),

			width: int(seal_scaling*tile_width/2),
			height: int(seal_scaling*tile_width/3),

			player_num: context.index,
			lane_num: index,

			seal_damage: value,

			threatened: threatened,
		 }, [
		 	add(_trophy_labels, [child]),
			set(child.mid_x, pos[0]),

		 ])) where existing = find(_trophy_labels, value.player_num = context.context.index and value.lane_num = context.index)
		 where threatened = (next_turn_state != null and next_turn_state.trophies[context.index][index] = 0)
		 where seal_size = int(seal_scaling*tile_height/2)
		 where seal_scaling = if(game.rows = 1, 0.9, 1.0)
		 where pos = get_tile_pos([nlane, if(nplayer = 0, game.lanes[nlane].begin, game.lanes[nlane].begin + game.lanes[nlane].length-1)])
		 where nlane = index)
		 where nplayer = index)
	]",
	
	spawn_tiles: "def(class game_state game) ->commands execute(me, [
		 if(find(level.chars, value is obj tile) = null, 
		   map(locs,
		     spawn('tile', 0, 0, {
				mid_x: get_tile_pos([row,col])[0],
				mid_y: get_tile_pos([row,col])[1],
				_controller: me,
				game_state:game,
				loc: [row,col],
				hex_height: tile_height,
				_theme: _theme,
			})
			  where row = value[0]
			  where col = value[1])
		   
		   where locs = [[row,col] | row<-range(game.rows), col<-range(game.columns), game.is_loc_on_board([row,col])],
		   [ [set(tile.game_state, game)] | tile <- level.chars, tile is obj tile]
		  )
	])
	",

	_cards_sorted_by_hand_position: { default: [], type: "[class card_base]" },
	_card_hand_positions: { default: [], type: "[int]", set: "[set(_cards_sorted_by_hand_position, map(sort(map(hand, {card: value, score: if(index < size(context.value), context.value[index], index)}), a.score < b.score), value.card)), set(_data, value)] where hand = _current_hand" },

	card_hand_position: "def(int hand_index) ->int if(hand_index < size(_card_hand_positions), _card_hand_positions[hand_index], hand_index)",
	position_to_hand_index: "def(int pos, int n=0) ->int if(card_hand_position(n) = pos, n, position_to_hand_index(pos, n+1))",

	set_card_hand_position: "def(int hand_index, int new_position) ->commands
	[
		set(me._card_hand_positions, remapped_positions),
	] where remapped_positions =
	   map(range(max(hand_index+1, size(_card_hand_positions), new_position+1)),
	       if(index = hand_index, new_position,
			  pos + if(pos < current_position and pos >= new_position, 1,
			           if(pos > current_position and pos <= new_position, -1, 0))
			 )
			 where pos = card_hand_position(index)
		  )
	  where current_position = card_hand_position(hand_index)
	",

	ally_hand_left_side: "0.56",
	ally_hand_area: "0.18",

	enemy_hand_left_side: "decimal :: hand_left_side",
	enemy_hand_area: "decimal :: hand_area",

	hand_left_side: "decimal :: decimal(gui_left_edge+lib.gui.py(303))/level_width",
	
	hand_area: "decimal :: decimal(lib.gui.py(570))/level_width",
	hand_right_side: "hand_left_side + hand_area",
	hand_card_size: "1.0",

	//metrics for the crypt/discard/etc display areas.
	left_edge_display_areas: "(hand_left_side-0.03)*level_width",
	right_edge_display_areas: "(hand_right_side+0.07)*level_width",
	display_area_width: "py(170)",

	cards_in_hand_positions: "def(int hand_size, decimal left_side, decimal area, bool enemy_hand=false) ->[{zorder: int, mid_x: int, mid_y: int, rotate: decimal, card_size: decimal}]
	  map(range(hand_size),
	   {
		 mid_x: int(px(20) + level.dimensions[2] * (left_side + ratio*area)),
		 mid_y: int(level_height - py(40)),
		 rotate: int(-5 + ratio*10.0),
		 card_size: me.hand_card_size,
		 zorder: get_zorder('card_in_hand_base') - card_hand_position(index)
	   }
		 where ratio = (if(enemy_hand, index, card_hand_position(index)) + 0.5)/hand_size
	  )
	",

	find_card_obj: "def(class card_base card) ->null|obj card find(level.chars, (value is obj card) and value.card_type = card and value.stack_id = null)",

	update_schedule_objects: "def() -> commands [
	]",
	
	spawn_cards_in_graveyard: "def() ->commands [
	]",

	_selected_creature_avatar: { set: "[if(_data, animate(_data, {alpha: 0}, {duration: 25, on_complete: remove_object(_data)})), set(_data, value)]", type: "null|obj player_avatar" },
	_selected_creature: { set: "[if(value = null, set(_selected_creature_avatar, null)), set(_data, value)]", type: "null|obj creature" },
	get_selected_creature: "def() ->null|obj creature _selected_creature",

	_casting_creature: "class creature :: if(_selected_creature != null, _selected_creature.creature_object, myplayer.creature_avatar)",

	_current_hand: "[class card_base] :: if(_selected_creature, _selected_creature.creature_object.activated_abilities, state.players[state.nplayer].hand)",

	_my_hand_size: "int :: if(_selected_creature != null and _selected_creature.creature_object.activated_abilities,
	    size(_selected_creature.creature_object.activated_abilities),
		max(size(_current_hand), state.players[state.nplayer].calculate_card_draw(state))
	)",

	spawn_activated_ability_cards: "def(obj creature creature) ->commands
	if(_selected_creature = creature, finish_activated_ability_cards(); spawn_cards_in_hand(),

	execute(me, [
		[[animate(c, {mid_y: level_height - py(20), mid_x: int(hand_right_side*level_width + px(120))}, {duration: 20}), set(c.in_hand, false), set(c.hand_card_off_to_side, true)] | c <- level.chars, c is obj card, c.in_hand],

		set(_card_regions, []),

		set(_selected_creature, creature);

		spawn_cards_in_hand(),

		[
			add_object(avatar),
			add(avatar.zorder, 1),
			set(avatar.alpha, 0),
			animate(avatar, {
				alpha: 255,
			}, {
				duration: 25,
			}),
			set(_selected_creature_avatar, avatar),
		] where avatar = create_player_avatar(state, myplayer, creature.creature_object),
	]
	)
	)
	",

	finish_activated_ability_cards: "def() ->commands [
		[remove_object(c) | c <- level.chars, c is obj card, c.in_hand, c.player_index = myplayer.player_index],
		set(_selected_creature, null),
	]",

	spawn_cards_in_hand: "def() ->commands

	[
	   set(_card_hand_positions, map(hand, index(hand_sorted, value))),
	   bind_command(_spawn_cards_in_hand_internal),
	]
	    
		where hand_sorted = [class card_base] ::
		if (sort_type and sort_type='by_cost',
		  sort(hand, by_cost(a,b)),
		  sort_type and sort_type='by_school_by_cost',
		  sort(hand, by_school_by_cost(a,b)),
		  // Fall back to default sort
		  sort(hand, by_default(a,b)))

		where hand = _current_hand
		where by_cost = function(class card_base, class card_base) -> bool ::		by_value_or(keep_fn, by_value_or(cost_fn, by_index))
		where by_school_by_cost = function(class card_base, class card_base) -> bool ::	by_value_or(keep_fn, by_value_or(school_fn, by_value_or(cost_fn, by_index)))
		where by_default = function(class card_base, class card_base) -> bool ::		by_value_or(keep_fn, by_value_or(new_fn, by_index))
		// higher order function to simplify the iterated fallback logic
		where by_value_or = def(function(class card_base) -> any val, function(class card_base, class card_base) -> bool fallback) //-> (function(class card a, class card b) -> bool)
			(def(class card_base a, class card_base b)->bool
			if (val_a != val_b,
				val_a < val_b,
				fallback(a,b))
			where val_a = val(a)
			where val_b = val(b))

		where keep_fn = def(class card_base c) -> bool
		(obj_c != null and obj_c.keep where obj_c = find_card_obj(c))
		where new_fn = def(class card_base c) -> bool (index_fn(c) != -1)
		where by_index = def(class card_base a, class card_base b) -> bool index_fn(a) < index_fn(b)
		where index_fn = def(class card_base c) -> int index(_cards_sorted_by_hand_position, c)
		where cost_fn = def(class card_base c) -> int state.players[state.nplayer].calculate_cost(c)
		where school_fn = def(class card_base c) -> int fold(c.school, max(a,b), 0)		
		where sort_type = string|null <- lib.citadel.preferences['sort_type']
	",

	_spawn_cards_in_hand_internal: "def() ->commands
	map(myteam,
		_spawn_cards_in_player_hand_internal(value, if(value = myplayer, _current_hand, value.hand),
		     if(not is_ally, hand_left_side, ally_hand_left_side),
		     if(not is_ally, hand_area, ally_hand_area),
			 is_ally
		)

		where is_ally = (value.player_index != state.nplayer)
	)
	",

	debug_redraw: "def() ->commands [
		[remove_object(c) | c <- level.chars, c is obj card, c.in_hand];
		_spawn_cards_in_hand_internal()

	]",

	_spawn_cards_in_player_hand_internal: "def(class player player, [class card_base] hand, decimal left_side, decimal area, bool is_ally) ->commands
	[
	  if(is_ally = false, set(_card_regions, [])),
	  [
	  map(hand,
	    
	   [
	   if(card_obj != null,
	     [
		   //if we have a crypt dialog up we may be moving the card from
		   //the crypt dialog to our hand. In this case make sure we
		   //remove it from the crypt dialog properly so the crypt dialog
		   //doesn't try to remove it when it goes away.
		   if(crypt_dialog != null and card_obj in crypt_dialog.items,
			; set(crypt_dialog.items, filter(crypt_dialog.items, value != card_obj))
		   ),

		   set(card_obj.hand_index, index),
		   set(card_obj.in_hand, true),
		   set(card_obj.hand_card_off_to_side, false),
		   set(card_obj.highlight, highlight_card),
		   set(card_obj.player_index, player.player_index),
		   set(card_obj.player, player),

		   set(card_obj.is_castable, is_castable),

		   if(card_obj != card_mouseover and card_obj != _playing_card and card_obj not in pending_card_discards and player.mulligan = false, [
			log(['DRAW END TIME', _card_draw_end_time, cycle]),
			   schedule(if(_card_draw_end_time > cycle, _card_draw_end_time - cycle, 0),
				   animate(card_obj, {
					  mid_x: pos.mid_x,
					  mid_y: pos.mid_y,
					  rotate: positions[index].rotate,
					  card_size: pos.card_size,
					}, {
					  duration: if(_mulligan_end_time is int and cycle < _mulligan_end_time + 5, 30, 10),
					  name: 'card_move',
					  replace_existing: true,
					})
			   ),

			   set(card_obj.zorder, pos.zorder),
		   ]),
		 ] where crypt_dialog = find(level.chars, value is obj crypt_library_display_dialog),

	     spawn('card', pos.mid_x, int(card_top),
		 {
			facing: 1,
			controller: me,
			in_hand: true,
			player_index: player.player_index,
			hand_index: index,
			card_size: if(_selected_creature, 0.5, 0.3),
			player: player,
			card_type: value,
			parent_creature: if(_selected_creature, _selected_creature.creature_object),
			show_back: true,
			mid_x: if(_selected_creature, _selected_creature.mid_x, _mydeck, _mydeck.mid_x, gui_left_edge+py(140)),
			mid_y: if(_selected_creature, _selected_creature.mid_y, _mydeck, _mydeck.mid_y, level_height-py(120)),
			alpha: 255,
			effect_alpha: 0.0,
			zorder: if(_selected_creature, _selected_creature.zorder-1, get_zorder('avatars') - 1),
		 }, 
		 [
		 	if(_mydeck, schedule(90, ; _mydeck.activate_animation())),
			//fake animation to mark the card as being in process
			//of being drawn.
		    animate(child, {
				alpha: 255,
			}, {
		 		duration: card_draw_index*10 + turn_banner_delay,
				name: 'animate_draw',
			}),

			set(_card_draw_end_time, max(_card_draw_end_time, cycle + card_draw_index*10 + turn_banner_delay + 120)),

		    reserve_animation_time('draw_cards', card_draw_index*10 + turn_banner_delay + 120),

		 	schedule(card_draw_index*10 + turn_banner_delay, [
				lib.sound.play_sound(me, 'interface/draw-cards'),

				if(_selected_creature != null, [
					set(child.mid_xy, _selected_creature.mid_xy),
					schedule(10, child.flip_card_over(false, 15)),

				 	animate(child, {
						mid_x: pos.mid_x,
						mid_y: pos.mid_y,
						rotate: pos.rotate,
						card_size: 1.0,
					}, {
						duration: 30,
						name: 'animate_draw',
					}),

					schedule(20,
						animate(child, {
							effect_alpha: 1.0,
						}, {
							duration: 5,
						})
					),

					schedule(25, set(child.zorder, pos.zorder)),

				], [

					schedule(30, [child.flip_card_over(false, 15)]),

					schedule(25, set(child.zorder, pos.zorder)),

					animate(child, {
						alpha: 255,
					}, {
						duration: 15,
						name: 'alpha_fade',
					}),

					schedule(15, animate(child, {
						card_size: 2.0,
					}, {
						duration: 15,
					})),

					schedule(45, animate(child, {
						card_size: 1.5,
					}, {
						duration: 4,
					})),

					animate(child, {
						mid_x: card_draw_left + card_draw_index*card_draw_spacing,
					}, {
						duration: 30,
						name: 'animate_draw',
						easing: lib.math.ease_in_out_cubic,
					}),

					animate(child, {
						mid_y: level_height/2,
					}, {
						duration: 30,
					}),

					if(player.mulligan = false,
					[
						animate(child, {
							mid_x: card_draw_left + card_draw_index*card_draw_spacing,
							mid_y: level_height/2,
							effect_alpha: 1.0,
						}, {
							duration: num_card_draws*10 + 40 - card_draw_index*10,
							name: 'animate_draw',
						}),

					 	animate(child, {
							mid_x: pos.mid_x,
							mid_y: pos.mid_y,
							rotate: pos.rotate,
							card_size: 1.0,
						}, {
							duration: 30,
							name: 'animate_draw',
						}),

					]),
				]),

			]),

			set(child.highlight, highlight_card),
			set(child.is_castable, is_castable),
		  ])

		   //see how many cards we're drawing before this one.
		   where card_draw_index = int :: count(hand[:index], find_card_obj(class card_base :: value) = null)
		),
		if(is_ally = false, add(_card_regions, [{left: int(pos.mid_x - card_width/2), right: int(pos.mid_x + card_width/2), top: int(card_top), card_num: index}] where card_width = 160))
		]

		 where turn_banner_delay = _card_spawn_delay + if(turn_banner, turn_banner.time_to_live, 0)
		 where turn_banner = find(level.chars, value is obj turn_banner)

		 where is_castable = (player.mulligan = false and state.nteam = state.current_player_index and can_afford and card_instance.is_usable(state, _casting_creature) and (state.in_response_phase = false or value.is_response) and possible_targets != [])
	     where can_afford =  if(possible_targets = [], false,
		                      possible_targets != null, true,
		                      myplayer.can_afford(value)
						   )
	     where possible_targets = if(possible_targets_unpriced != null,
		                            filter(possible_targets_unpriced, myplayer.can_afford_with_target(state, context.value, value))
								 )
		 where possible_targets_unpriced =  _tutorial.filter_targets(me, value, value.possible_targets(state, myplayer.creature_avatar, []))
		 
		 where card_obj = null|obj card :: find_card_obj(card_instance)
		 where pos = positions[index]
		 where highlight_card = bool :: (state.nteam = state.current_player_index) and state.in_response_phase and card_instance.is_response and player.can_afford(card_instance)
		 where card_instance = class card_base :: value
	   ),

	   map(_placeholder_cards,
	   	if(index >= num_placeholders,
		   animate(value, {
			 alpha: 0,
		   }, {
			 duration: 10,
			 on_complete: remove_object(value),
		   }),
		   animate(value, {
			mid_x: pos.mid_x,
			mid_y: pos.mid_y,
			rotate: pos.rotate,
		   }, {
			duration: 10,
		   })
		   where pos = positions[pos_index]
		   where pos_index = size(hand) + index)
	   ),
	   if(size(_placeholder_cards) > num_placeholders, set(_placeholder_cards, _placeholder_cards[:num_placeholders])),

	   if(num_placeholders > size(_placeholder_cards),
		 map(range(num_placeholders - size(_placeholder_cards)),
		 	spawn('card', {
				facing: 1,
				controller: me,
				in_hand: true,
				in_opponent_hand: false,
				is_placeholder: true,
				player_index: player.player_index,
				hand_index: size(hand) + index,
				card_size: pos.card_size,
				player: player,
				card_type: lib.citadel.create_card('Acolyte'),
				parent_creature: null,
				show_back: false,
				mid_x: pos.mid_x,
				mid_y: pos.mid_y,
				rotate: pos.rotate,
				alpha: 255,
				effect_alpha: 0.0,
				zorder: get_zorder('avatars') - 1,
			}, [
				add(_placeholder_cards, [child]),
			])

			where pos = positions[pos_index]
			where pos_index = size(hand) + size(_placeholder_cards) + index
		 )
	   ),
	   ]
	     where num_placeholders = if(_selected_creature != null, 0, max(0, size(positions) - size(hand)))
	     where positions = cards_in_hand_positions(hand_size, left_side, area)
	     where card_draw_left = (level_width - (num_card_draws-1)*card_draw_spacing)/2
	     where card_draw_spacing = min(lib.gui.py(400), if(num_card_draws > 1, (gui_right_edge - gui_left_edge - lib.gui.py(200)) / (num_card_draws - 1), 0))
	     where num_card_draws = count(hand, find_card_obj(class card_base :: value) = null),

	   set(me._card_hand_top, card_top),

	   update_archive_count(),
	]
  where card_top = decimal :: top_player_area
  where hand_size = int :: if(_selected_creature != null, size(hand), max(size(hand), player.calculate_card_draw(state)))
	",

	_placeholder_cards: { type: "[obj card]", default: [] },

	_card_spawn_delay: { type: "int", default: 0 },
	
	create_player_avatar: "def(class game_state state, class player player, null|class creature creature=null) ->obj player_avatar
		
		object('player_avatar', {
			player_num: index,
			is_enemy: index != state.nplayer,
			nick_alpha: 1.0,
			_avatar: if(creature, creature.calculate_portrait, player.avatar),
			zorder: get_zorder('avatars'),
			_top: if(same_team, level_height - py(246), py(56)),
			_width: round_to_even(py(186)),
			_height: round_to_even(py(186)),
			_edge: if(same_team, gui_left_edge - py(36), gui_right_edge + px(34)),
			_available_space: avatar_width,
			_nick: if(creature, creature.name, player.name),
			face_right: same_team,
			highlight: state.current_player_index = index,
			current_desaturation: if(prev_avatar, prev_avatar.current_desaturation, if(state.current_player_index = index, 0.0, 1.0)),
			target_desaturation: if(state.current_player_index = state.team_index(index) and player.has_ended_turn = false, 0.0, 1.0),

			mouse_enter_handler: me.mouse_enter_avatar,
			mouse_leave_handler: me.mouse_leave_avatar,
			click_handler: me.avatar_clicked,
		}
		)
		   where same_team = (state.team_index(index) = state.team_index(state.nplayer))
		   where team = get_player_team(player)
		   where prev_avatar = if(index < size(_avatars), _avatars[index])
		   where index = player.player_index
	",

	update_devotion_banners: "def() ->commands
	let our_connector_y = -1;
	let their_connector_y = -1;
	map(_player_devotion_banners,
	[
	(; [
		if(same_team and (our_connector_y = -1 or target_y < our_connector_y),
			set(our_connector_y, target_y)
		),
		if(same_team = false and (their_connector_y = -1 or target_y > their_connector_y),
			set(their_connector_y, target_y)
		),
	]),
	if(banner.mid_y != target_y,
		animate(banner, {
			mid_y: target_y,
		}, {
			duration: 40
		})
	),
	set(banner.num_tokens, num_tokens),
	set(banner.active_tokens, active_tokens),

	if(num_tokens > banner.num_tokens,
		if(creature != null, [
			schedule(delay_anim, ; creature.devotion_launch_animation(banner.school)),
			banner.animate_token_entry(delay_anim+16),
		])
	
	where creature = find(level.chars, value is obj creature and value.pending_devotion_animation and value.creature_object.controller = banner.player_index and (banner.school in value.creature_object.school))
	),
	]
		where delay_anim = if(banner.mid_y != target_y, 40, 0)
	    where num_tokens = state.players[banner.player_index].get_resource_level(banner.school)
	    where active_tokens =  state.players[banner.player_index].get_active_resource_level(banner.school)
		where target_y = if(same_team, level_height - lib.gui.py(302) - lib.gui.py(54)*pos, lib.gui.py(300) + lib.gui.py(48)*pos)
		where same_team = (state.team_index(banner.player_index) = state.team_index(state.nplayer))
		where pos = count(_player_devotion_banners, value.player_index = banner.player_index and value.school < banner.school)
		where banner = value
	);

	[set(c.pending_devotion_animation, false) | c <- level.chars, c is obj creature, c.pending_devotion_animation];

	if(our_connector_y != -1,
		(
		if(our_connector = null,
			spawn('devotion_connector', {
				x: gui_left_edge - py(80),
				y: level_height - py(220),
				height: 4,
				enemy: false,
			}, [
				add(_player_devotion_connectors, [child]),
			]),
		);

		animate(conn, {
			x: gui_left_edge - py(80),
			y: round_to_even(our_connector_y),
			height: (level_height - py(220)) - our_connector_y,
		}, {
			duration: 50,
		})

		where conn = find_or_die(_player_devotion_connectors, value.enemy = false)
		),
	//else our_connector_y = -1
		[
		remove_object(our_connector),
		set(_player_devotion_connectors, filter(_player_devotion_connectors, value != our_connector)),
		]

	) where our_connector = find(_player_devotion_connectors, value.enemy = false);

	if(their_connector_y != -1,
		(
		if(their_connector = null,
			spawn('devotion_connector', {
				x2: gui_right_edge + py(82),
				y2: py(200),
				height: 4,
				enemy: true,
			}, [
				add(_player_devotion_connectors, [child]),
			]),
		);

		animate(conn, {
			x2: gui_right_edge + py(82),
			y2: round_to_even(their_connector_y),
			height: their_connector_y - py(230),
		}, {
			duration: 50,
		})

		where conn = find_or_die(_player_devotion_connectors, value.enemy = true)
		),
	//else their_connector_y = -1
		[
		remove_object(their_connector),
		set(_player_devotion_connectors, filter(_player_devotion_connectors, value != their_connector)),
		]

	) where their_connector = find(_player_devotion_connectors, value.enemy = true)

	",

	update_avatars: "def() ->commands [
		[[
			set(avatar.target_desaturation, if(state.current_player_index = state.team_index(player.player_index) and player.has_ended_turn = false, 0.0, 1.0)),
			set(avatar.highlight, state.current_player_index = avatar.player_num),

			avatar.set_particle_effects(player.creature_avatar.particle_effects),
		] where player = state.players[avatar.player_num]
		 | avatar <- _avatars],

		
		map(avatar_life, value.set_life(player.life) where player = state.players[index]),

		map(_player_mana_bars, value.update_mana(player.resources, player.calculate_income(state)) where player = state.players[value.player_num]),
		map(_player_mana_display, value.update_mana(player.resources, player.calculate_income(state)) where player = state.players[value.player_num]),

		map(avatar_decks,
		 if(player.deck != value.items,
		 [
		 	set(value.items, player.deck),
		 ]; fire_event(value, 'create')
		 )
		  where player = state.players[value.player_index]),

		map(avatar_crypts,
		 if(player.deck != value.items,
		 [
		 	set(value.items, player.discard_pile),
		 ]; fire_event(value, 'create')
		 )
		  where player = state.players[value.player_index]),
	
		
		map(state.players,
			map(range(5),
			if(lvl > 0,
				if(banner = null,
					_queue_update_command('spawn_devotion',
						spawn('devotion_banner', {
							x: if(same_team, gui_left_edge - py(72), gui_right_edge - py(46)),
							y: if(same_team, level_height - py(206), py(190)),
							_width: lib.gui.py(116),
							_height: lib.gui.py(36),
							_face_right: same_team,
							school: school,
							player_index: player_index,
							is_enemy: player_index != state.nplayer,
						}, [
							add(me._player_devotion_banners, [child])
						])
					)
				)
		   where same_team = (state.team_index(player_index) = state.team_index(state.nplayer))
			where banner = find(_player_devotion_banners, value.school = school and value.player_index = player_index)
			)
			where lvl = player.get_resource_level(school)
			where school = index+1)
			where player_index = index
			where player = value
		); _queue_update_command('update_devotion_banners', ; update_devotion_banners())
	]",

	crypt_clicked: "def(int nplayer) ->commands
	execute(me,
	[
	log(['CRYPT CLICKED', nplayer, state.nplayer, myturn]),
	if(nplayer = state.nplayer and myturn,
		undo_discard()
	)
	])
	",

	create_avatars: "def() ->commands if((not _avatars) or (not avatar_life), [
		set(playmat_alpha, 1.0),
		set(_playing_start_anim, false),

		if(not _playing_start_anim, map(_avatars, remove_object(value))),
		set(_avatars, []),

		map(avatar_life, remove_object(value)),
		set(avatar_life, []),

		map(avatar_crypts, remove_object(value)),
		set(avatar_crypts, []),

		map(avatar_decks, remove_object(value)),
		set(avatar_decks, []),

		map(_player_mana_bars, remove_object(value)),
		set(_player_mana_bars, []),

		map(_player_devotion_banners, remove_object(value)),
		set(_player_devotion_banners, []),

		map(_player_mana_display, remove_object(value)),
		set(_player_mana_display, []),

		map(state.players, [
			add(_avatars, [new_avatar]),
			add_object(new_avatar);
			create_mana_bar(new_avatar),

		] where new_avatar = create_player_avatar(state, value)),

		//[log(['HAVE PLAYER DAMAGE: ', hint.source.loc])  | hint <- state.animation_hints, hint is class animation.player_damage_hint],

		map(state.players[:state.num_teams], spawn('life_bar', 0, 0, {
			mid_x: if(index = state.nplayer, gui_left_edge + py(108), gui_right_edge - py(108)),
			mid_y: if(index = state.nplayer, level_height - py(245), py(246)),
			_width: py(116),
			_height: py(116),
			zorder: get_zorder('avatars')+10,
			max_life: 40,
			current_life: player.life,
			is_enemy: index != state.nplayer,
			_prev_current_life: if(size(avatar_life) > index, avatar_life[index].current_life),
		}, [
			add(me.avatar_life, [child]),
		])
		  where player = value
		),

		map(state.players, spawn('crypt_library_display', {
			_text: 'Crypt',
			items: player.discard_pile,
			item_objects: if(size(avatar_crypts) > index, avatar_crypts[index].item_objects, []),
			_width: py(80),
			_height: py(80),
			x: if(index = state.nplayer, hand_right_side*level_width + py(210), hand_left_side*level_width - py(270)),
			y: if(index = state.nplayer, level_height-py(76), -py(6)),
			zorder: 1000,
			is_crypt: true,
			player_index: player.player_index,
			controller: me,
			_left_align: if(index = state.nplayer, false, true),
			_delay: 2 + index,
		}, [
			add(me.avatar_crypts, [child]),
		])
		  where team = get_player_team(player)
		  where player = value
		),

		map(state.players, spawn('crypt_library_display', 0, 0, {
			_text: 'Library',
			items: player.deck,
			item_objects: if(size(avatar_decks) > index, avatar_decks[index].item_objects, []),
			_width: py(80),
			_height: py(80),
			x: if(index = state.nplayer, gui_left_edge+py(66), gui_right_edge-py(146)),
			y: if(index = state.nplayer, level_height-py(88), py(10)),
			_left_align: if(index = state.nplayer, true, false),
			zorder: get_zorder('avatars')+11,
			is_crypt: false,
			player_index: player.player_index,
			controller: me,
			_delay: 2 + index,
		}, [
			add(me.avatar_decks, [child]),
		])
		  where team = get_player_team(player)
		  where player = value
		),

		set(_mana_display_adjustment, 0),

		[remove_object(c) | c <- level.chars, c is obj creature_in_citadel],

	])",

	_do_preloading: "def() ->commands
		object('devotion_icon', { _school: 1, is_enemy: true }).preload()
	",

	_played_start: { type: "bool", init: "MODULE_OPTIONS.test = true or MODULE_OPTIONS.startgame != false" },
	_playing_start_anim: { type: "bool", init: "MODULE_OPTIONS.startgame != false" },
	game_start_animation: "def(class game_state game_state) ->commands
	if(MODULE_OPTIONS.test, load_state(),
	   _played_start = false, [
		set(_played_start, true),
		set(_playing_start_anim, true),
		reserve_animation_time('game_start', 72),

		schedule(70, ; _do_preloading()),

		map(_avatars, remove_object(value)),
		set(_avatars, avatars),
		map(avatars, add_object(value)),
		map(avatars, [
			set(value.nick_alpha, 0.0),
			add(value.zorder, 10000),
			set(value.alpha, 0),
			set(value.current_desaturation, 0.0),
			set(value.target_desaturation, 0.0),
			[
			set(value.preview_height, avi_height),
			set(value.preview_width, avi_width),
			set(value.preview_x, if(index = game_state.nplayer, -offscreen, level_width+offscreen) where offscreen = max(0, avi_width*2 - level_width)/2),
			set(value.preview_y, 0),
			] where avi_height = max(level_height, (avi_width*996)/800)
			  where avi_width = max(level_width/2, (level_height*800)/996),
			set(value.preview_ratio, 0.0),

			schedule(if(value.player_num = game_state.nplayer, 0, 40), animate(value, {
				alpha: 255,
			}, {
				duration: 30,
			})),

			animate(value, {
				preview_ratio: 0.0,
			}, {
				name: 'begin',
				replace_existing: false,
				duration: 120,
				on_complete: if(index = 0, lib.sound.play_sound(me, 'interface/initial_card_shuffle')),
			}),
			animate(value, {
				preview_ratio: 1.0,
				nick_alpha: 0.0,
			}, {
				name: 'begin',
				replace_existing: false,
				duration: 60,
				on_complete: remove_object(value),
			})
		]),

		schedule(20,
		spawn('label', {
			_text: [game_state.players[game_state.nplayer].name],
			_font_size: lib.gui.py(86),
			mid_x: level_width/4,
			mid_y: level_height/2,
			zorder: 20000,
		}, [
			schedule(100, remove_object(child)),
		])
		),

		schedule(40,
		spawn('label', {
			_text: ['VS'],
			_font_size: lib.gui.py(86),
			mid_x: level_width/2,
			mid_y: level_height/2,
			zorder: 20000,
		}, [
			schedule(80, remove_object(child)),
		])
		),

		schedule(60,
		spawn('label', {
			_text: [game_state.players[(game_state.nplayer+1)%2].name],
			_font_size: lib.gui.py(86),
			mid_x: level_width/2 + level_width/4,
			mid_y: level_height/2,
			zorder: 20000,
		}, [
			schedule(60, remove_object(child)),
		])
		),

//open chat at the start.
		schedule(120, ; spawn_chat_widgets()),
		
	] where avatars = map(game_state.players, create_player_avatar(game_state, value)))
	",

	_mana_display_adjustment: { default: 0 },

	adjust_mana: "def(int delta) ->commands [
		add(_mana_display_adjustment, delta),
		bind_command(_schedule_display_mana),
	]",

	_last_mana_adjust: { type: "null|int" },
	_schedule_display_mana: "def() ->commands [
		if(_last_mana_adjust = null or _last_mana_adjust <= cycle, [
			//TODO: adjust mana in here.
			set(_last_mana_adjust, cycle + 5),
		]),
	]",

	_set_mana_bar_using: "def(int amount) ->commands 
		if(mana_bar, [
			set(mana_bar.using_mana, amount)
		])
	",

	mana_bar: { type: "obj mana_bar|null" },

	_player_mana_bars: { type: "[obj mana_bar]", default: [] },
	_player_mana_display: { type: "[obj mana_numeric_display]", default: [] },
	_player_devotion_banners: { type: "[obj devotion_banner]", default: [] },
	_player_devotion_connectors: { type: "[obj devotion_connector]", default: [] },

	locked_mana: { type: "int|null" },

	create_mana_bar: "def(obj player_avatar avatar) ->commands
	instrument_command('create_mana_bar',
	[
		spawn('mana_bar', {
			mid_x: avatar.mid_x,
			mid_y: avatar.mid_y,
			_width: py(245),
			_height: py(245),
			zorder: get_zorder('avatars') - 1,
			max_mana: player.calculate_income(state),
			current_mana: player.resources,
			rotation: if(is_opponent, -98.0, 82.0),

			_controller: me,
			_is_player: avatar.player_num = state.nplayer and observer = false,
			player_num: avatar.player_num,
		}, [
			if(player = myplayer, set(me.mana_bar, child)),
			add(me._player_mana_bars, [child]),
		]) where is_opponent = (avatar.player_num != state.nplayer),

		spawn('mana_numeric_display', {
			mid_x: avatar.mid_x + lib.gui.py(if(is_opponent, 88, -86)),
			mid_y: avatar.mid_y + lib.gui.py(if(is_opponent, 76, -72)),
			_width: py(88),
			_height: py(88),
			zorder: get_zorder('avatars') + 11,
			max_mana: player.calculate_income(state),
			current_mana: player.resources,

			_controller: me,
			_is_player: avatar.player_num = state.nplayer and observer = false,
			player_num: avatar.player_num,
		}, [
			add(me._player_mana_display, [child]),
		]) where is_opponent = (avatar.player_num != state.nplayer)
	]) where player = state.players[avatar.player_num]",

	_chat_area: { type: "null|obj chat_widget" },
	_last_chat_area_interact: { default: 0 },

	spawn_chat_widgets: "def() ->commands
	[
		set(_last_chat_area_interact, cycle),
		if(_chat_area = null,
		  spawn('chat_widget', {
			x: level_width - lib.gui.py(250),
			y: level_height - (lib.gui.py(884) - chat_widget_y),
			_width: lib.gui.py(240),
			_height: lib.gui.py(884) - chat_widget_y - lib.gui.py(120),
			zorder: 500,
			surrender_focus_on_enter: true,
		  } where chat_widget_y = lib.gui.py(1080 - 572),
		  [
			  set(me._chat_area, child),
			  if(_state != null and is_online_game,
			  	schedule(5, ; child.join_channel('@' + state.players[(state.nplayer+1)%2].name, [enum force_focus]))
			  )
		  ]),
				
		 [
		 if(find(level.chars, value = _chat_area) = null, add_object(_chat_area)),
		 ]),
	]",

	spawn_opponent_cards: "def() ->commands
	
	if(state.players[(state.nplayer+1)%2].mulligan = false,
	[
	  log(['POSITIONS', pos]),
	  //get rid of existing opponent cards that should no longer be there.
	  [ if(card.card_type.orphaned_by_update,
	  	   animate(card, {
			mid_x: 60,
			mid_y: 204,
			rotate: 180,
		   }, {
			duration: 15,
			on_complete: remove_object(card),
		   }),
		   remove_object(card))

	   | card <- level.chars, card is obj card, card.in_opponent_hand, find(hand, value = card.card_type) = null],

	  //create new card objects and update existing ones.
	  map(reverse(pos), if(obj = null, [
	    spawn('card', {
			 zorder: value.zorder,
			 show_back: show_card_back,
			 in_opponent_hand: true,
			 card_type: hand[index],
			 controller: me,
			 card_size: 1.0,
			 mid_x: if(index = _opponent_hand_mouseover and _opponent_card_playing, level_width - px(160), value.mid_x),
			 mid_y: if(index = _opponent_hand_mouseover and _opponent_card_playing, py(160),
				          level_height - value.mid_y - py(70) + if(index = _opponent_hand_mouseover, py(20), 0)),
			 rotate: 180 + if(index = _opponent_hand_mouseover, 0, -value.rotate),
		},
		[
		 	if(_theirdeck, schedule(0, ; _theirdeck.activate_animation())),

			if(index = _opponent_hand_mouseover, child.show_halo(), child.hide_halo()),
			if(suppress_animations = false and _theirdeck != null, [
				set(child.mid_x, _theirdeck.mid_x),
				set(child.mid_y, _theirdeck.mid_y),
				set(child.zorder, _theirdeck.zorder-1),
				set(child.rotate, 180),
				set(child.card_size, 0.3),
				schedule(10*card_draw_index,
					animate(child, {
						mid_x: child.mid_x,
						mid_y: child.mid_y,
						rotate: child.rotate,
						zorder: value.zorder,
						card_size: 1.0,
					}, {
						duration: 25,
					}),
				),
			]),
		])
		] where card_draw_index = int :: count(hand[:index], find_card_obj(class card_base :: value) = null),

		[
			set(obj.arrows, []),
			if(index = _opponent_hand_mouseover and _opponent_card_playing,
				_set_arrows_for_card(obj, _opponent_targets)
			),

			if(index = _opponent_hand_mouseover, obj.show_halo(), obj.hide_halo()),
			if(obj.show_back != show_card_back, [
				obj.flip_card_over(show_card_back),
			]),
			animate(obj, {	
				mid_x: if(index = _opponent_hand_mouseover and _opponent_card_playing, level_width - px(160), value.mid_x),
				mid_y: if(index = _opponent_hand_mouseover and _opponent_card_playing, py(160),
				          level_height - value.mid_y - py(70) + if(index = _opponent_hand_mouseover, py(20), 0)),
				rotate: 180 + if(index = _opponent_hand_mouseover, 0, -value.rotate),
				card_size: 1.0,
			}, {
				name: 'flip_card',
				duration: 10,
				replace_existing: false,
			}),
			set(obj.zorder, value.zorder),
		]

		)
	  where show_card_back = (observer = false and myplayer.can_see_enemy_hand <= 0)
	  where obj = find_card_obj(hand[index])
	 ),

	 map(reverse(placeholder_pos), if(index >= size(_opponent_placeholder_cards), [
	 	spawn('card', {
			 zorder: value.zorder,
			 show_back: false,
			 in_opponent_hand: false,
			 card_type: lib.citadel.create_card('Acolyte'),
			 controller: me,
			 card_size: 1.0,
			 is_placeholder: true,
			 hand_index: size(hand) + index,
			 mid_x: value.mid_x,
			 mid_y: level_height - value.mid_y - py(70),
			 rotate: 180 + if(index = _opponent_hand_mouseover, 0, -value.rotate),
		}, [
			add(_opponent_placeholder_cards, [child]),
		]),
	 ], [
	 	animate(obj, {
			 mid_x: value.mid_x,
			 mid_y: level_height - value.mid_y - py(70),
			 rotate: 180 - value.rotate,
		}, {
			 duration: 10,
		}),
	 ] where obj = _opponent_placeholder_cards[index]
	 )),

	 if(size(placeholder_pos) < size(_opponent_placeholder_cards), [
		map(_opponent_placeholder_cards[size(placeholder_pos):], remove_object(value)),
		set(_opponent_placeholder_cards, _opponent_placeholder_cards[:size(placeholder_pos)]),
	 ])
	])
	  where placeholder_pos = all_pos[size(pos):]
      where pos = cards_in_hand_positions(hand_size, enemy_hand_left_side, enemy_hand_area, true)[:size(hand)]
      where all_pos = cards_in_hand_positions(hand_size, enemy_hand_left_side, enemy_hand_area, true)
  	  where hand_size = int :: max(size(hand), enemy_player.calculate_card_draw(state))
	  where hand = enemy_player.hand
	  where enemy_player = state.players[(state.nplayer+1)%2]
	",

	_opponent_placeholder_cards: { type: "[obj card]", default: [] },

	_calculate_play_card: "def(class game_state state, class card card, [Loc] targets) ->class game_state
		get_modified_object(state, def(class game_state g) ->commands g.resolve_card(construct('message.play_card', {type: 'play_card', player_index: g.nplayer, targets: targets, card: card })))
	",

	_calculate_end_of_turn_state_internal: "def(class game_state state) ->commands
	state.end_turn();
	if(state.current_choice != null or
	   (not state.in_response_phase) and
	   state.has_unresolved_combat = false,
	   null,
	   _calculate_end_of_turn_state_internal(state)
	)
	",

	_calculate_end_of_turn_state: "def(class game_state state) ->class game_state
		if(state.current_choice != null or
		   (not state.in_response_phase) and
		   state.has_unresolved_combat = false,
		   state, get_modified_object(state, me._calculate_end_of_turn_state_internal)
		)
	",

	_calculate_next_turn_state_internal: "def(int nturn, class game_state g) ->commands
		g.end_turn();
		if(g.current_choice != null or g.nturn > nturn and g.has_unspent_moves = false, null, _calculate_next_turn_state_internal(nturn, g))
	",

	_calculate_next_turn_state: "def(class game_state state, int nturn) ->class game_state
	    if(state.current_choice != null or
		   state.nturn > nturn and state.has_unspent_moves = false,
		   state,
		   get_modified_object(state, bind(me._calculate_next_turn_state_internal, nturn))
		)
	",

	movement_arrows: { type: "[obj move_arrow]", default: [] },

	spawn_movement_arrows: "def(class game_state state) ->commands ; ([
		[a.fade_away_and_die() | a <- movement_arrows, [a.src_tile, a.dst_tile] not in loc_pairs],
		set(movement_arrows, [a | a <- movement_arrows, [a.src_tile, a.dst_tile] in loc_pairs]),
		map(loc_pairs,
			if(existing_arrow != null, [
				set(existing_arrow.selectable, is_selectable),
				set(existing_arrow.creature, state.creature_at_loc_or_die(src_tile)),
				set(existing_arrow.is_leap, is_leap),
				set(existing_arrow.zorder, get_zorder('movement_arrows') + if(is_leap, 5, 0)),
				if(is_leap, remove_object(existing_arrow)),
			],
				spawn('move_arrow', {
					_ctrl: me,
					src_tile: src_tile,
					dst_tile: dst_tile,
					zorder: get_zorder('movement_arrows') + if(is_leap, 5, 0),
					selectable: is_selectable,
					creature: state.creature_at_loc_or_die(src_tile),
					is_leap: is_leap,
				}, [
					add(movement_arrows, [child]),
					if(is_leap, remove_object(child)),
				])
			)

			where is_selectable = ((not observer) and state.creature_at_loc_or_die(src_tile).controller = state.nplayer and not state.stack)
			where existing_arrow = find(movement_arrows, [src_tile,dst_tile] = [value.src_tile,value.dst_tile])
			where is_leap = (abs(src_tile.y - dst_tile.y) > 1 and find(loc_pairs, value.x != src_tile and value.y = dst_tile) != null)
			where src_tile = (Loc<- value.x)
			where dst_tile = (Loc<- value.y)
		),
	]
	where loc_pairs = filter(map(state.creatures, [value.loc, value.expected_move_loc(state)]), value[1] != null)
	)",

	spawn_game_icons: "def(class game_state state) ->commands [
	log(['spawn game icons calc', size(filter(state.creatures, value.is_engaged(state)))]),
		[remove_object(icon) | icon <- level.chars, icon is obj game_icon, icon.user_info = 'status_icon' or icon.user_info is list and icon.user_info[0] = 'status_icon'],
		[
		[
		log('spawn game icon'),
		spawn('game_icon', pos[0]+70, pos[1] + if(state.nplayer != c.controller, 100, 0), {
			mid_x: pos[0],
			mid_y: pos[1] + tile_height*0.5*if(state.nteam = c.controller, -1, 1),
			size: 48,
			zorder: get_zorder('status_icon'),
			icon: 'melee-icon.svg',
			user_info: ['status_icon', c.summon_id],
		})] where pos = get_tile_pos(c.loc) | c <- state.creatures, c.is_engaged(state)],

		[spawn('game_icon', pos[0]+50, pos[1] + 40, {size: 48, zorder: get_zorder('status_icon'), icon: 'ranged-icon.svg', user_info: 'status_icon'}) where pos = get_tile_pos(c.loc) | c <- state.creatures, c.has_action, c.is_engaged(state) = false, c.is_ranged, size(c.targets_attacking(state)) > 0],

		[map(filter(map(c.status_effects, icon_info[value]), value != null),
		     spawn('game_icon', pos[0]+90 - index*4 - index*index*2, pos[1] + 50 - 20*index,
			   {size: 24, user_info: 'status_icon', zorder: get_zorder('status_icon')} + value))
		  where pos = get_tile_pos(c.loc) | c <- state.creatures]
		     where icon_info = {string -> map} <-
			     get_document('data/status_effect_icons.cfg'),

	]",
	
	get_tile_pos: "def(Loc pos) ->Loc [
		int(board_center.x + (pos[0] - (state.rows-1)/2.0)*tile_x_spacing),
		board_ypos +
		  if(state.nteam = 0,
		     (state.columns-1) - pos[1],
			 pos[1]+1)*tile_y_spacing +
		  if(pos[0]%2 = 1, 0, if(state.nteam = 0, 1, -1)*tile_y_spacing/2) +
		
		//even length middle row which is the longest row, add half a width height
		if(state.rows%2 = 1 and mid_length%2 = 0 and mid_length < 6 and find(state.lanes, value.length > mid_length) = null
		   where mid_length = state.lanes[state.rows/2].length,
			tile_y_spacing/2, 0
		),
	]",

	_sent_game_result: { default: false },

	_resource_y_pos: "def(bool is_local, int nresource, int max_resource) ->int
	   if(is_local, level_height - 380 - nresource*54,
			        260 + nresource*54)",

	_xp_objects: { type: "[custom_obj]", default: [] },

	_mana_x_pos: "def(int nmana, int max_mana) ->int
	   40 + nmana*spacing where spacing =  int(min(40, (level_width*0.2)/max_mana))",
	
	display_player_mana: "def(class game_state state) ->commands [

	]",

	count_cards_in_archive: "int :: count(level.chars, value is obj card and value.keep)",
	update_archive_count: "def() ->commands
		null",
	
	_day_night: { type: "null|obj day_night_controller" },

	display_game_status: "def(class game_state state) ->commands [
	/*
		if(_day_night != null,
		   set(_day_night.is_day, state.is_day),

		   spawn('day_night_controller', {
			is_day: state.is_day,
			mid_x: level_width - lib.gui.py(80),
			mid_y: lib.gui.py(80),
		   }, [
		   	set(_day_night, child),
		   ]),
		)
	*/
	]",

	display_free_ability: "def(class game_state state) ->commands
	if(state.free_ability != null and state.free_ability.nplayer = state.nplayer,
	if(possible_targets != [],
	[
	if(_playing_card != null, [
		remove_object(_playing_card),
		set(_playing_card, null),
	]),

	spawn('card', level_width/2, level_height/2, {
		card_type: state.free_ability.ability,
		mandatory_play: true,
		in_hand: false,
		allow_drag: false,
		controller: me,
		parent_creature: creature,
	}, [
		set(me._playing_card, child)
	]);

	choose_targets_for_card(obj card<- me._playing_card, [])

	])
 	  where possible_targets = state.free_ability.ability.possible_targets(state, creature, [])
	  where creature = state.free_ability.creature
	
	
	)",
	
	display_choice: "def(class game_state state) ->commands [
	  if(myplayer.mulligan = false and _mulligan_object, [
		remove_object(_mulligan_object),
		set(_mulligan_object, null),
	  ]),

	  if(myplayer.mulligan,
	  if(_mulligan_object, _mulligan_object.update(state),
	    spawn('mulligan_controller', {
			_mm: me,
			_controller: me,
			game: state,
		}, [
			set(_mulligan_object, child)
		])
	  ),
			  
	   _choice_object, [_choice_object.exit_dialog(), set(_choice_object, null)]),
	  if(state.current_choice, // and state.current_choice.player_index = state.nplayer,
	  [
	    reserve_animation_time('choice', 120),
	  	schedule(30, spawn('choice_controller', 0, 0,
		{
			_mm: me,
			_controller: me,
			game: state,
		}, [
			set(_choice_object, child),
			//log('spawned choice'),
		 ]))
	   ])
    ]",

	_log_controller: { type: "null|obj log_controller" },

	_current_game_log: { type: "[string]", default: [] },

	update_log: "def(class game_state game) ->commands
	[
	 if(_current_game_log = game.log[:size(_current_game_log)] and _chat_area != null,
		map(game.log[size(_current_game_log):], _chat_area.game_message(value))
	 ),
	 set(_current_game_log, game.log),
	 if(_log_controller, _log_controller.process_game_state(game)),
	]",

	_submit_deck_time: { type: "int|null" },

	top_player_area: "int :: level_height - py(120)",

	bot_opponent_area: "int :: px(50)",
	avatar_width: "int :: w + if(w%2 = 1, 1, 0) where w = int(level_width*0.19)",
	avatar_padding: "int :: avatar_width/10",

	avatar_stats_left: "def(int nplayer) ->int
	  if(state.team_index(nplayer) = state.nteam, 8, level_width - avatar_stats_width - 8)",
	
	avatar_stats_width: "int :: avatar_width - 16",

	_awarding_cards: "bool :: find(level.chars, value is obj card and value.in_victory) != null",

	award_packs: "def(int npacks) ->commands if(_title_controller != null, [
		_title_controller.award_packs('core', npacks),
		spawn('fizzle_effect', {
			mid_x: level_width/2,
			mid_y: level_height/2,
			zorder: 12000,
			scale: lib.gui.dpy(0.5),
		}, [
			child.play_in_reverse(),
			schedule(30, remove_object(child)),
		]),

		spawn('pack', {
			mid_x: level_width/2,
			mid_y: level_height/2,
			zorder: 12010,
			alpha: 0,
			scale: lib.gui.dpy(1.0),
		}, [
			schedule(20, animate(child, { alpha: 255 }, { duration: 8 })),
		]),
		spawn('hint_label', {
			mid_x: level_width/2,
			mid_y: int(level_height*0.2),
			zorder: 20000,
			_text: [if(npacks = 1, 'You have won a pack of cards!', sprintf('You have won %d packs of cards!', npacks))],
			_delay: 20,
			_fade_duration: 50,
			_font_size: 48,
		}, [
		]),
	])
	",

	award_cards: "def([string] card_names, int gold) ->commands [
	//TODO: work out a way to show cards that aren't known to the client yet.
	map(filter(card_names, lib.citadel.is_known_card(value)),
	schedule(150 + index*20,
		spawn('card', level_width/2, level_height/2,
		  {
			 card_type: lib.citadel.create_card(value),
			 controller: me,
			 in_hand: false,
			 allow_drag: false,
			 in_victory: true,
			 card_size: 0.6,
			 alpha: 0,
			 zorder: 20000,
		  },
		  [

		  	animate(child, {
				card_size: 1.0,
				alpha: 255,
				mid_x: level_width/2 + xy_target[0]*3,
				mid_y: level_height/2 + xy_target[1]*3,
			}, {
				name: 'present',
				duration: 100,
			}),

		  	animate(child, {
				alpha: 255,
			}, {
				name: 'present',
				duration: 150,
			}),
		  ]
		)
		where xy_target = [
		  [0,-level_height/10], [0,level_height/10], [level_width/12,level_height/12],
		  [-level_width/12,-level_height/12], [-level_width/12,level_height/12], [level_width/12,-level_height/12]][index%6]
	)
	),

	if(card_names,
		spawn('hint_label', level_width/2, level_height/2, {
			zorder: 20000,
			_text: ['You have won new cards!'],
			_delay: 100,
			_fade_duration: 50,
			_font_size: 48,
		}, [
		])
	),

	award_gold(gold),
	]",

	award_gold: "def(int reward_gold) ->commands execute(me, [
	if(reward_gold > 0,
		if(_game_result_banner_shown = null,
		  schedule(80, bind_command(me.award_gold, reward_gold)),
	      schedule(80 - (cycle - _game_result_banner_shown),
			spawn('turn_banner', {
				mid_x: level_width/2,
				mid_y: board_center[1] + lib.gui.py(80),
				_text: ' Reward:\n+' + str(reward_gold) + ' Gold',
				_vertical_adjust: lib.gui.py(26),
				zorder: 10000,
				permanent: true,
			})
		  )
		)
	)
	])",

	_award_gold_label: { type: "null|custom_obj", set: "[remove_object(_data), set(_data, value)]" },

	generate_tips: "def(class game_state game) ->[Tip|null]
	if(find(game.players, value.deck_submitted = false) != null or game.in_mulligan or observer,
	   [],
	   _tutorial.override_tips, _tutorial.generate_tips(me, game),
	   game.nplayer = game.current_player_index and game.current_choice = null,
	     lib.tips.generate_tips(me, game), [
	])
	",

	_tooltip_locked_by: { type: "null|custom_obj" },
	_tooltip: { type: "[custom_obj]", default: [],
		set: "if(value != _data, [
			if(value, [
				lib.sound.play_sound(me, 'interface/tooltip_on'),
			], _data, [
				lib.sound.play_sound(me, 'interface/tooltip_off'),
			]),
			set(_data, value),
		])"
	},

	_current_tip: { type: "null|obj tip_dialog" },
	_current_tip_key: { type: "null|string" },

	_shown_tips: { type: "{string -> bool}", default: {} },

	_create_tip_dialog: "def(Tip|null best_tip) ->commands [
		if(_current_tip, [remove_object(_current_tip), set(_current_tip, null)]),
		set(me._current_tip_key, null),
		if(best_tip != null, [
			set(_shown_tips[best_tip.key], true),

			if(best_tip.clear_key is string,
				add(_shown_tips, {(best_tip.clear_key): false}),
			),

			if(best_tip.key = 'card_anatomy',
				schedule(60, spawn('inspect_card_dialog', 0, 0, { _mm: me, _controller: me, _card: obj card<- best_tip.targets[0], _display_help: true, })) asserting best_tip.targets != null,
			   best_tip.is_modal,
				[
					schedule(5, spawn('modal_tip_dialog', 0, 0, { _mm: me, _controller: me, _tip: best_tip }))
				],

			  schedule(best_tip.delay or 0,
				spawn('tip_dialog', {
					zorder: 10000,
					_tip: best_tip,
					_width: lib.gui.py(300),
					_height: lib.gui.py(200),
					alpha: 0,
					_has_close: if(strstr(best_tip.key, 'tutorial'), false, true),
				}, [
					set(me._current_tip, child),
					set(me._current_tip_key, best_tip.key),
					set(child.x, if(state.rows = 1, level_width/2 + lib.gui.py(280), level_width - lib.gui.py(240))),
					set(child.y2, (bot_opponent_area + top_player_area)/2 + lib.gui.py(180)),
					child.calculate_entry_point(),

				])
			  )
			)
		]),
	]",

	spawn_tip_object: "def(class game_state game) ->commands
	[
	if(best_tip != null and best_tip.key = _current_tip_key,
	null, //no-op, keep the current tip showing.
	[
		_create_tip_dialog(best_tip), //show the new tip dialog
		if(best_tip != null, _tutorial.on_show_tip(best_tip.key)),
	])
	]
	where best_tip = find(tips, value != null and (_shown_tips[value.key] != true or value.key = _current_tip_key) and (lib.citadel.num_times_tip_shown(value.key) < if(value.max_shows = null, 1, value.max_shows) or _tutorial.override_tips))
	where tips = generate_tips(game)",

	show_invalid_target_tip: "def(string text, custom_obj target, string title='Invalid Target') ->commands
	spawn('tip_dialog', {
		mid_x: target.mid_x + lib.gui.py(220),
		mid_y: target.mid_y,
		zorder: lib.citadel.zorder('card_tips'),
		_title: title,
		_tip: {
			key: 'tip',
			text: text,
			targets: [target],
		},

		_width: lib.gui.py(240),
		_height: lib.gui.py(220),
		_has_close: false,
		_delay_widgets: 20,
		alpha: 0,
	}, [
		me.set_tooltip(child),
		animate(child, {
			alpha: 255,
		}, {
			duration: 20
		})
	])
	",
	
	show_tooltip: "def() ->commands [
		if(obj != null and card_mouseover = null,
			//see about showing a tip as to why we can't target
			//this creature with the current spell being cast.
			if(invalid_target_reason != null,
				show_invalid_target_tip(invalid_target_reason, obj),

				//show regular tooltip for the creature.
				fire_event(obj, 'show_tooltip', {controller: me})
			)

			where invalid_target_reason = if(_playing_card != null and obj is obj creature, _playing_card.card_type.calculate_invalid_target_reason(state, if(_playing_card.parent_creature, _playing_card.parent_creature, myplayer.creature_avatar), _targets_chosen, obj.creature_object))

		)
		where obj = choose(filter(level.chars, (value is obj creature and value.has_mouseover or value is obj seal or value is obj creature_land_flag and value.has_mouseover) and mouse_x > value.x and mouse_x < value.x2 and mouse_y > value.y and mouse_y < value.y2), value.zorder)
		
	]",

	set_tooltip: "def(custom_obj obj, null|custom_obj tooltip_parent=null) ->commands [
		map(_tooltip, remove_object(value)),
		set(_tooltip, [obj]),
		set(_tooltip_locked_by, tooltip_parent),
	]",

	append_tooltip: "def(custom_obj obj) ->commands [
		add(_tooltip, [obj]),
	]",

	clear_tooltips: "def() ->commands [
	 map(_tooltip, remove_object(value)),
	 set(_tooltip, []),
	 set(_tooltip_locked_by, null),
	]",

	show_intro_sequence: "def(string sequence_type) ->commands [
		schedule(140, spawn('intro_animation_controller', 0, 0, {
			sequence_type: sequence_type,
		})),
	]",

	suppress_animations: { default: false },

	_allow_deltas: { default: false },

	get_game_state_from_delta: "def(int delta_basis, any delta) ->class game_state|null
	if(base_state != null, class game_state<- apply_delta(base_state, delta))

	where base_state = class game_state|null ::
	if(_replay != null,
		if(_game_state_queue, class game_state<- _game_state_queue[size(_game_state_queue)-1].state, _state),
	     if(_processed_state_id = delta_basis,
		    _state,
	        if(msg, class game_state<- msg.state)
			    where msg = find(_game_state_queue, value.state_id = delta_basis)
		 )
	)
	",

	check_quiet_front_music: "def() -> commands
	if(cycle%120 = 0,
	if(time_since_last_mood > 120*60,
		if(s != null,
			_play_mood_sound(s)
		)
		where s = lib.sound.choose_sound('gameplay/music_cue_quiet_front')
	)
	)
	",

	time_since_last_mood: "int :: cycle - (_current_mood_sound_start or 0)",

	play_turning_tides_music: "def() -> commands _play_mood_sound('gameplay/music_cue_turning_tides.wav')",
	play_hero_death_music: "def() -> commands _play_mood_sound('gameplay/music_cue_hero_death.wav')",
	play_creature_death_music: "def() -> commands
	if(time_since_last_mood > 10*60,
		_play_mood_sound(sprintf('gameplay/music_cue_lose_creature_0%d.wav', 1d3))
	)",
	play_danger_music: "def() -> commands
	if(time_since_last_mood > 10*60,
		_play_mood_sound('gameplay/music_cue_danger')
	)
	",

	play_climax_music: "def(bool us_threatened) -> commands _play_mood_sound(sprintf('gameplay/music_cue_%s.wav', if(us_threatened, 'threatened', 'closing_victory')))",

	_music_theme: { type: "string", init: "choose(['materia','sapienza','gaea','aether','entropia'])" },
	_ambient_sound: { type: "string", default: "ambient/amb_breakthrough_puzzle.wav" },

	_current_mood_sound: { type: "string|null" },
	_current_mood_sound_start: { type: "int|null" },
	_mood_sound_played: { type: "{string -> int}", default: {} },
	_stop_mood_sound: "def() ->commands
		if(_current_mood_sound != null, [
			stop_sound(_current_mood_sound, 0.2),
		])
	",
	_play_mood_sound: "def(string name) ->commands execute(me, if(name not in _mood_sound_played, [
		set(_mood_sound_played[name], cycle),
		_stop_mood_sound(),
		lib.sound.play_sound(me, name),
		set(_current_mood_sound, name),
		set(_current_mood_sound_start, cycle),
	]))",



	in_combat_animation: { type: "bool", default: false },
	in_play_card_animation: { type: "bool", default: false },

	_reserve_timer: { type: "int", init: "int :: 60*60" },
	_reserve_timer_display: { type: "int|null" },
	_reserve_label: { type: "obj label|null" },

	_clock_timer: { type: "null|int" },
	_clock_label: { type: "obj label|null" },

	_last_clock_active: { type: "null|bool" },

	_update_timer: "def() ->commands
	if(show_timer,
	[
		if(clock_active and _clock_timer%60 = 0 or clock_active != _last_clock_active,
		[
			set(_last_clock_active, clock_active),

			remove_object(_clock_label),
			spawn('label', {
				_font_size: lib.gui.py(22),
				_text: [str((_clock_timer or 0)/60)],
				x: lib.gui.py(50),
				y: lib.gui.py(840),
				zorder: get_zorder('seals'),
				_color: if(not clock_active, [0.4, 0.4, 0.4, 1], _clock_timer < 600, [1,0,0,1], [1,1,1,1]),
			}, [
				set(me._clock_label, child),
			]),

			if(_reserve_timer/60 != _reserve_timer_display,
			[
				remove_object(_reserve_label),
				spawn('label', {
					_font_size: lib.gui.py(22),
					_text: [str(_reserve_timer/60)],
					x: lib.gui.py(10),
					y: lib.gui.py(840),
					zorder: get_zorder('seals'),
					_color: if((_clock_timer or 0) > 0 or not clock_active, [0.4, 0.4, 0.4, 1], _reserve_timer < 600, [1,0,0,1], [1,1,1,1]),
				}, [
					set(me._reserve_label, child)
				]),

				set(_reserve_timer_display, _reserve_timer/60),
			])
		]
		),

		if(_clock_timer > 0 and cycle > _animation_end_time and clock_active, add(_clock_timer, -1)),
		if(_clock_timer <= 0 and _reserve_timer > 0 and cycle > _animation_end_time and clock_active, add(_reserve_timer, -1)),
	]
	where clock_active = myturn and _clock_timer != null and _end_turn_button != null,

	_clock_label != null,
	[
		remove_object(_clock_label),
		set(_clock_label, null),
	]
	)
	where show_timer = _state != null and _clock_timer != null and is_online_game and not observer
	",

	_opponent_reserve_label: { type: "obj label|null" },
	_opponent_clock_label: { type: "obj label|null" },

	_opponent_timer_info: { type: "any" },

	_update_opponent_timer: "def(any info) ->commands
	if(info != _opponent_timer_info, [
		if(info is [int|null, int], [
			remove_object(_opponent_reserve_label),
			remove_object(_opponent_clock_label),

			spawn('label', {
				_font_size: lib.gui.py(22),
				_text: [str((info.x or 0)/60)],
				x: lib.gui.py(1540),
				y: lib.gui.py(0),
				zorder: get_zorder('seals'),
				_color: [1,1,1,1],
			}, [
				set(_opponent_clock_label, child),
			]),

			spawn('label', {
				_font_size: lib.gui.py(22),
				_text: [str((info.y or 0)/60)],
				x: lib.gui.py(1500),
				y: lib.gui.py(0),
				zorder: get_zorder('seals'),
				_color: [1,1,1,1],
			}, [
				set(_opponent_reserve_label, child),
			]),
		]),

		set(_opponent_timer_info, info),
	]
	)
	",

	_past_eval_scores: { type: "[int]", default: [] },

	_cards_preloaded: { type: "null|string" },

	_preload_card: "def(class card card) ->commands [
		map(card.preload_objects, anura_objects().preload(value)),

		object('card', 0, 0, {
			card_type: card,
			controller: me,
			card_size: 1.0,
			show_shadow: false,
		}).precache_render(),

		//preload the image used on the creature
		if(card.creature_object != null,
		   c.precache_image(sprintf('images/portraits/card-size/%s', card.creature_object.portrait or card.portrait)) where c = canvas()
		)
	]
	",

	_preload_cards: "def(class game_state state) ->commands
	instrument_command('preload_cards',
	[
		set(_cards_preloaded, state._uuid),

		map(state.players, [
			map(value.deck, _preload_card(value)),
			map(value.hand, _preload_card(value)),
		])
	])
	",


	_do_update_game: "def(map message, int state_id) ->commands
     let game_state = class game_state<- message.state;
	 let is_new_turn = (_state != null and _state._uuid = game_state._uuid and game_state.in_mulligan = false and (game_state.nturn != _state.nturn or _state.in_mulligan and not game_state.in_mulligan));
	 let is_your_turn = (game_state.nteam = game_state.current_player_index);
	 let new_force_skip_responses = force_skip_responses and not (is_new_turn and is_your_turn);
	instrument_command('_do_update_game',
	[
	    if(_state != null and _state._uuid = game_state._uuid,
		   [instrument_command('update_object', update_object(_state, game_state))],

		   if(_state = null and _chat_area != null and is_online_game,
			  	_chat_area.join_channel('@' + game_state.players[(game_state.nplayer+1)%2].name, [enum force_focus])
		   );

		   set(_state, game_state); set(_past_eval_scores, [])
		);

		if(_state and _cards_preloaded != _state._uuid and find(_state.players, not value.deck_submitted) = null,
			_preload_cards(_state)
		);

	    set(me._processed_state_id, state_id),

		//a dramatic score swing.
		if(_state != null, add(_past_eval_scores, [lib.bot_eval.eval_game_state(_state)]));
		if(size(_past_eval_scores) >= 3 and abs(scores[0] - scores[2]) > 200 and sign(scores[0]) != sign(scores[1]),
			play_turning_tides_music()
		) where scores = reverse(_past_eval_scores);

		if(_state != null and _observer_perspective != null, set(_state.nplayer, _observer_perspective))
	];

	_queue_update_command('calculate_future', ;
		[
			instrument_command( 'release_future', [
			if(_end_of_turn_state_needs_release, release_object(end_of_turn_state)),
			if(_next_turn_state_needs_release, release_object(next_turn_state)),
			]),
			set(end_of_turn_state, state_end_turn),
			set(_end_of_turn_state_needs_release, game_state != state_end_turn),
			set(next_turn_state, state_next_turn),
			set(_next_turn_state_needs_release, state_end_turn != state_next_turn),
		] where state_next_turn = _calculate_next_turn_state(state_end_turn, game_state.nturn)
		  where state_end_turn = _calculate_end_of_turn_state(game_state)
	);

	_queue_update_command('process_game_update', ;
	 [

		if(_state != null and (is_new_turn and is_your_turn) and not observer,
		[
			if(_clock_timer != null, [
				add(_reserve_timer, _clock_timer/2),
				if(_clock_label != null, [
					animate(_clock_label, {
						mid_x: _clock_label.mid_x - lib.gui.py(80),
						alpha: 0,
					}, {
						on_complete: remove_object(_clock_label),
						duration: 30,
					}),
					set(_clock_label, null),
				]),
			]),
			//timer disabled for now
			set(_clock_timer, if(game_state.timer is int, game_state.timer*60))
		]
		),

		set(_card_spawn_delay, if(game_state.in_mulligan, 120, 0)),

		instrument_command('turn_banner',
		if(_state = null and (not MODULE_OPTIONS.startgame) and game_state.in_mulligan = false or is_new_turn, [

			if(avi != null,
				avi.new_turn_flash()
			)

			where avi = find(_avatars, value.player_num = game_state.current_player_turn_index),
			spawn('turn_banner', {
				mid_x: level_width/2,
				mid_y: board_center[1],
				_text: text,
				zorder: 4000,
				starting_delay: 0,
			}),

			lib.sound.play_sound(me, if(text != 'Opponent Turn', 'interface/your_turn', 'interface/enemy_turn')),

	 		reserve_animation_time('turn_banner', 120),
		]
			where text = if(observer, game_state.players[game_state.current_player_turn_index].name + q('s Turn), if(xor, 'Your Turn', 'Opponent Turn'))
			where xor = if (game_state.in_response_phase, not is_your_turn, is_your_turn)
		)),

	    set(_last_state_message, message),

		set(force_skip_responses, new_force_skip_responses),

		set(_tutorial, game_tutorial),
		set(_tutorial_init, true),

		// automatically send end turn in response phases.
		instrument('calc_end_turn',
			if(_auto_send_end_turn(game_state), end_turn())
		),

		bind_command(game_tutorial.game_updated, me, game_state),
		fire_event('game_updated'),
     ]
	 )
	 )
	 where game_tutorial = if(_tutorial_init = false, class client_tutorial<- construct(game_state.tutorial.client_tutorial, client_tutorial_args), _tutorial)
	 //we are force skipping responses until the next turn
	",

	_auto_send_end_turn: "def(class game_state game_state) ->bool
	if(
		(observer = false) and
		is_your_turn and
		game_state.in_response_phase and
		game_state.current_choice = null and
		game_state.free_ability = null and
		skipping_is_allowed and
		should_skip and
		_tutorial.skip_response_phase(me, game_state),

		true, false
	)

	where should_skip = new_force_skip_responses or have_no_possible_response or (game_state.is_final_response and would_win_anyways)
	where new_force_skip_responses = force_skip_responses and not (is_new_turn and is_your_turn)
	where have_no_possible_response = (game_state.players[game_state.nplayer].has_possible_response(game_state) = false)
	where turn_is_not_ended_already = (game_state.players[game_state.nplayer].has_ended_turn = false)
	where would_win_anyways = (end_of_turn_state and end_of_turn_state.players[opponent_index].life <= 0)
	where is_your_turn = (game_state.nteam = game_state.current_player_index)
	where is_new_turn = (_state != null and _state._uuid = game_state._uuid and game_state.in_mulligan = false and (game_state.nturn != _state.nturn or _state.in_mulligan and not game_state.in_mulligan))
	where skipping_is_allowed = true
	where opponent_index = game_state.next_player_index
	",

	handle_window_resize: "def(int new_width, int new_height) ->commands execute(me,
	[

		[ tile.destroy() | tile <- level.chars, tile is obj tile ],

		set(level.dimensions, [0,0,new_width,new_height]),

		fire_event('dimensions_updated'),

	])where delta_w = new_width - level_width
	  where delta_h = new_height - level_height
	  where card_width = min(135*card_scale, if(hand_size, card_area/hand_size, 100))
	  where card_scale = max(1.0, decimal(card_area)/decimal(1024 - 300))
	  where card_area = new_width - 300
	  where hand_size = count(level.chars, value is obj card and value.in_hand)",

	  _garbage_collection_pending: { default: false },

	  _game_result_banner_shown: { type: "int|null" },

	  connect_relay_server: "def(int session_id) ->commands
	  execute(me,
	  if(_client != null,
	  [
		tbs_send(_client, {type: 'connect_relay', relay_session: session_id, relay_host: TBS_SERVER_ADDRESS, relay_port: '23459'}),
	  ]
	  )
	  )
	  ",

	submit_deck: "def([string] deck, string|null avatar) ->commands
	execute(me,
	[
		map(deck, null asserting lib.json.get_document_map('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
		tbs_send(me.client, {type: 'submit_deck', deck: deck,
		player_info: {
			name: _mm_client_state.account_info.display_name,
			avatar: _mm_client_state.account_info.avatar,
			deck_name: selected_deck,
			deck_category: selected_deck_category,
			deck_avatar: avatar,
		}}) asserting deck,
		set(_submit_deck_time, level.cycle),
	])",
},


events: {

quit_game: "
	//The user is closing out the app. Quit elegantly by
	//sending a message saying so to the server.
	set(level.quitting_game, false);
	remove_object(me);
	spawn('quit_game_controller', { _mm_client_state: _mm_client_state })
",


settings_menu: "if(level.show_builtin_settings_dialog and not paused, [
	set(level.show_builtin_settings_dialog, false),

	if(text_entry != null, set(text_entry.has_focus, false),
	   _state = null, null,
		channeling_dialog, channeling_dialog.close(),

		(not state.current_choice) and no_mandatory_play and find(level.chars, value is obj tile and value.selectable) != null and _playing_card != null,
		//cancel the current card play on escape
		tile_clicked(null),

		//show our settings dialog.
		spawn('pause_dialog', 0, 0, { _mm: me, _controller: me, _title_controller: _title_controller })
	),
]
where channeling_dialog = find(level.chars, value is obj channeling_dialog))
where text_entry = find(level.chars, value is obj text_entry and value.has_focus)",

"+generate_mouseover_card": "mouse_enter_card(obj card<- arg.card)",

construct: "[]",

create: "[
	if(is_online_game,
		spawn('connection_status_display', {
			x: 2,
			y2: level_height - 2,
		}, [
			set(_connection_status_display, child),
		])
	),

	lib.sound.new_game(),

	remove_object(_log_controller),
	spawn('log_controller', 0, 0, {
		controller: me,
	}, [
		set(me._log_controller, child),
	]),

	if(_replay != null,
	[
		map([string]<- _replay.replay[replay_range[0]:replay_range[1]], schedule(1 + index*1, fire_event('message_received', {message: get_document_from_str(value)})))
	]
	where replay_range = [int,int] <- (_replay_options['range'] or [0,9999999])
	),

	[
		schedule(180, sound_loop(_ambient_sound, lib.citadel.sound_volume(_ambient_sound), 1.0)),
	],

//	if(is_online_game, [music_onetime('start-game.ogg'), schedule(50, music_queue(_music_theme + '.ogg'))],
//	music(_music_theme + '.ogg')),

	report({ type: 'start_scenario', scenario: campaign_scenario, location: campaign_location, }),
	lib.gui.set_screen_dimensions(level),

	add_object(_storyline),

	lib.citadel.add_main_background_shader(level),

	add(level.frame_buffer_shaders, [{
		begin_zorder: get_zorder('seals')-12,
		end_zorder: get_zorder('seals')-1,
		shader_info: 'seals_light_shader',
	}]),

	//handle_window_resize(level.camera_position[2], level.camera_position[3]),
	
	if(observer,
	[
		set(me._client, cl),
	] where cl = create_tbs_client(),

	if(size(get_module_args()) > 0, 
	[set(me._client, cl),
	tbs_send(cl, {type: 'start_game'}), log('game created')] where cl = create_tbs_client(),
	if(game_created, 
	[set(me._client, cl), log('game created')]
		where cl = create_tbs_client()
	)));

	fire_event('request_initial_state'),
]
",

"+request_initial_state": "
[
	if(_state = null and client.in_flight = 0, [
		log(['request_initial', _allow_deltas]),
		tbs_send(client, { type: 'request_updates', state_id: _state_id, allow_deltas: _allow_deltas }),
		schedule(5, fire_event('request_initial_state'))
	])
]
",

being_removed: "[
	stop_sound(_ambient_sound),
]",

"+update_storyline": "[
	fire_event(_storyline, 'game_updated')
]",

//right now we don't handle resizing mid-level.
//window_resize: "handle_window_resize(int<- arg.width, int<- arg.height)",

type_updated: "if(_state, [set(_avatars, []), fire_event('dimensions_updated')])",

"+dimensions_updated": "[
	lib.gui.set_screen_dimensions(level),

	remove_object(_log_controller),
	spawn('log_controller', 0, 0, {
		controller: me,
	}, [
		set(me._log_controller, child),
	]),

	[
		remove_object(find(level.chars, value is obj hex_effect_controller)),
		/*
		spawn('hex_effect_controller', 0, 0, {
			begin_zorder: -1000000,
			end_zorder: -100000,
		}),
		*/

		set(_theme.left_edge, int(avatar_width*(800.0/level_width))),
		set(_theme.right_edge, int((level_width - avatar_width)*(800.0/level_width))),
		set(_theme.top_edge, int(bot_opponent_area*(600.0/level_height))),
		set(_theme.bottom_edge, int(top_player_area*(600.0/level_height))),
	];

	if(_theme.background_image != null,
	spawn('image_widget', 0, 0, {
		image: string<- _theme.background_image,
		zorder: -10,
		draw_width: level_width+20,
		draw_height: level_height+20,
		image_area: [0,0,1620,940],
		mid_x: level_width/2,
		mid_y: level_height/2,
	}, [
		if(lib.citadel.preferences.disable_animations != true and (_theme.particle_effects is map), set(child.particles, _theme.particle_effects)),
	])
	),

	if(_last_state_message, [
		bind_command(_tutorial.game_updated, me, state),

        display_choice(state),
		set_widgets_for_message(state),
		set_schedule_for_message(state),
		spawn_trophies(state),
		spawn_tiles(state),
		adapt_input_state(),
		display_game_status(state),
		display_player_mana(state),
		update_log(state),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		spawn_opponent_cards(),
		update_schedule_objects(),
		display_free_ability(state),

		fire_event('game_updated'),
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0,
	       { controller: me, game_state: state, facing: 1, creature_object: creature.creature_object, hex_height: tile_height })
	          asserting creature.creature_object]
	| creature <- level.chars,
	  creature is obj creature,
	  creature.creature_object.is_on_board ]
]",

"+update_spells_on_stack": "
 [
  set(_spells_on_stack, survivors),
  map(leaving, execute(value, [
//	schedule(100, remove_object(value)),
  ]))
 ]
  where leaving = filter(_spells_on_stack, not card_on_stack(value))
  where survivors = filter(_spells_on_stack, card_on_stack(value))",

"+update_game": "
   if((not force_process) and
      (_game_state_queue != [] or cycle < _animation_end_time or paused or _animation_queue or _update_command_queue),
	 add(_game_state_queue, [message]),
     fire_event('do_update_game', {message: message})
	 )
     where message = map<- arg.message,
         force_process = null|bool<- arg.force_process
",

"+do_update_game": "
     if(state_id > _processed_state_id,

		if(_processed_animation_queue or game_state.animation_hints = [] or _state = null or _state._uuid != game_state._uuid,
		[
			set(_game_state_message_pending, message),
			set(_nanim_hint_nturn, game_state.nturn),
			set(_nanim_hint_processed, size(game_state.animation_hints)),
			set(_processed_animation_queue, false),
			_do_update_game(message, state_id),
		],
		[
			log(['QUEUE_STATE:', _nanim_hint_nturn, _nanim_hint_processed, game_state.nturn, size(game_state.animation_hints)]),
			set(_processed_animation_queue, true),
			set(_animation_queue, game_state.animation_hints[if(_nanim_hint_nturn = game_state.nturn, _nanim_hint_processed, 0):]),
			set(_game_state_queue, [message] + _game_state_queue),

			set(_nanim_hint_nturn, game_state.nturn),
			set(_nanim_hint_processed, size(game_state.animation_hints)),
		]) asserting _animation_queue = []
        where game_state = class game_state<- message.state
			 
	 )
     where state_id = int<- message.state_id
     where message = map<- arg.message",

"+game_updated": "instrument_command('game_updated', schedule(1, [
		set(_garbage_collection_pending, true),

	 	adapt_input_state(),


		[
			(create_avatars(); update_avatars()),

//			log('game updated'),
//			map(display_icons, if(value, set(value.player_index, index))),
//			map(display_icons, if(value, set(value.scale, 1.0))),
		]

		     where positions = [
			   int(left_edge_display_areas - display_area_width*0.5),
			   int(right_edge_display_areas + display_area_width*0.5),
			 ],

	 	reserve_animation_time('game_update', 10),
		log('SET NEW STATE'),


		display_game_status(game_state),
		display_player_mana(game_state),
		display_choice(game_state),
	    [

		//cards to remove that used to be in our hand, but no longer.
		[
		   remove_object(card)

		| card <- level.chars,
		  card is obj card,
		  card.in_hand and not card.is_placeholder,
		  _selected_creature = null or (card.card_type not in _selected_creature.creature_object.activated_abilities),
		  find(state.players[card.player_index asserting card.player_index != null].hand, value = card.card_type) = null,
		  card not in pending_card_discards
		],

	
		[card.destroy() | card <- level.chars,
		 card is obj card,
		 card.stack_id != null,
		 find(state.stack, value.card_uuid = card.card_type._uuid) = null
		],

		[card.destroy() | card <- level.chars,
		 card is obj card,
		 card.in_hand = false and card.in_opponent_hand = false and
		 card.card_type.orphaned_by_update
		],

		//remove cards that are in our deck.
		[animate(card, { mid_x: gui_left_edge, mid_y: level_height - lib.gui.py(60), card_size: 2.0, alpha: 0 }, { duration: 20, on_complete: remove_object(card) })
		 | card <- level.chars,
		 card is obj card,
		 find(myplayer.deck, card.card_type = value) != null,
		 _crypt_library_dialog = null or (card not in _crypt_library_dialog.items)
		],

		//remove cards that are in our opponent's deck.
		[animate(card, { mid_x: gui_right_edge, mid_y: lib.gui.py(40), card_size: 2.0, alpha: 0 }, { duration: 20, on_complete: remove_object(card) })
		 | card <- level.chars,
		 card is obj card,
		 find(enemy_player.deck, card.card_type._uuid = value._uuid) != null
		],

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(game_state),
		spawn_trophies(game_state),
	  ],

	  set_widgets_for_message(game_state),
	  set_schedule_for_message(game_state),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(game_state.creatures,
		                     value.summon_id = creature.summon_id) or
							 game_state.graveyard[creature.summon_id] or
							 game_state.exiled_creatures[creature.summon_id]
	    where creature = obj.creature_object
		| obj <- level.chars, obj is obj creature],
		value), 30, 0)), 

	  map(filter(level.chars, value is obj creature and
	          find(game_state.permanents,
			       context.value.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = game_state.graveyard[value.creature_object.summon_id] or
		                      game_state.exiled_creatures[value.creature_object.summon_id]), 
	  _queue_update_command('update_cards', [fire_event(card, 'game_updated') | card <- level.chars, card is obj card]),
	  [
	    spawn_opponent_cards(),
		spawn_cards_in_hand(),
		spawn_cards_in_graveyard(),
		update_schedule_objects(),
	  ],
	  

	  map(game_state.permanents,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
			 _queue_update_command('update_creatures',
		     	[set(obj.game_state, state),
			 	 set(obj.creature_object, value),
			 	if(card_rules, set(value.rules, card_rules))]
			 ),
	      
		  //create a new object to represent this creature.
		  [//log('SPAWN CREATURE: ' + value.name),
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: value,
				  game_state: state,
				  controller: me,
				  hex_height: tile_height,
				},
				[
				  if(card_rules, set(value.rules, card_rules))
				] asserting value)
		  ])
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value is obj creature and
		                                value.creature_object.summon_id = context.value.summon_id) where card_rules = if(doc and doc.rules, string<- doc.rules, '')
										where doc = map|null<- lib.json.get_document_map('data/cards.cfg')[lib.citadel.actual_card_name(value.name)]),
	
	  spawn_game_icons(state),

	  spawn_movement_arrows(state),

										
	  if(game_state.winner, 
			  
	   [
	   if(game_state.winner_index = game_state.nplayer and puzzle_name != null and (puzzle_name not in account_info.puzzles_completed),
		  add(account_info.puzzles_completed, [puzzle_name])
	   ),

	   if(observer = false and _sent_game_result = false,
		[
		log(['XXX: SEND', campaign_location, campaign_scenario]),
		set(_sent_game_result, true),
		if(game_state.winner_index = game_state.nplayer and (victory_unlock is string), add(_mm_client_state.account_info.unlocks, [victory_unlock])),
	   	if(game_state.winner_index = game_state.nplayer and specified_reward != null, [
			if(specified_reward.packs, schedule(200, ; award_packs(specified_reward.packs))),
			if(specified_reward.cards, award_cards(specified_reward.cards, 0)),
			if(specified_reward.gold, award_gold(specified_reward.gold)),
			if(specified_reward.location != null and _title_controller != null, _title_controller.set_campaign_location(specified_reward.location)),
			map(specified_reward.flags, if(_title_controller != null, _title_controller.set_campaign_flag(value))),
		],
		mm_client, tbs_send(mm_client, {
			type: 'finish_bot_game',
			user: myplayer.name,
			multiplayer: is_online_game,
			puzzle_name: puzzle_name,
			campaign_location: campaign_location,
			campaign_scenario: campaign_scenario,
			campaign_sets: campaign_sets,
			unlock: if(game_state.winner_index = game_state.nplayer, victory_unlock, null),
			victory: game_state.winner_index = game_state.nplayer,

			quests: map(game_state.players[game_state.nplayer].quests, value.get_info()),
		   }) asserting mm_client),
		])

		;

		schedule(_animation_end_time - cycle,
		[

		reserve_animation_time('end_game', 10000000),

		[animate(c, {alpha: 0}, {on_complete: remove_object(c), duration: 10}) | c <- level.chars, c is obj creature],

		[set(c.paused, true) | c <- level.chars, c is obj card|obj button_controller|obj seal|obj end_turn_button],


		schedule(120,
		spawn('blur_controller', {
			blur_amount: 0.0,
			end_zorder: 9000,
		}, [
			animate(child,{
				blur_amount: 2.0,
			}, {
				duration: 10,
			})
		])),

		set(_game_result_banner_shown, cycle),

		[remove_object(c) | c <- level.chars, c is obj tip_dialog],

		if(_used_cheats = false and not observer, report({ type: 'complete_game', user: username, time: cycle/60.0, result: (game_state.winner = game_state.players[game_state.team_index(game_state.nplayer)]), multiplayer: is_online_game, scenario: campaign_scenario, location: campaign_location, })),

		set(game_result, game_state.winner = game_state.players[game_state.team_index(game_state.nplayer)]),

		[
			spawn('turn_banner', {
				mid_x: level_width/2,
				mid_y: board_center[1] - lib.gui.py(80),
				_text: if(victory, 'Victory', 'Defeat'),
				zorder: 10000,
				permanent: true,
			}
			),

			record_stats({
				table: 'game',
				action: 'finish',
				uuid: state._uuid,
				victory: victory,
			}),
		
		] where victory = (game_state.winner = game_state.players[game_state.team_index(game_state.nplayer)]),

		_stop_mood_sound(),

		if(game_state.winner = game_state.players[game_state.team_index(game_state.nplayer)],
		   lib.sound.play_sound(me, 'interface/victory'),
		   lib.sound.play_sound(me, 'interface/defeat')
		),

		if(game_setup_message != null and game_state.winner != game_state.players[game_state.team_index(game_state.nplayer)] and specified_reward = null,
			schedule(200, spawn('button_controller', {
				text: 'Restart Game',
				_font_size: px(18),
				on_click: (def() ->commands me.restart_game()),
				zorder: 10000,
				button_width: lib.gui.py(200),
				x: level_width/2 - lib.gui.py(100),
				mid_y: level_height/2 + lib.gui.py(100),
			}))
		),

		schedule(if(specified_reward != null and specified_reward.packs, 280, 200),
		spawn('button_controller', {
			text: 'Leave Game',
			_font_size: px(18),
			on_click: (def() ->commands me.quit_game()),
			zorder: 10000,
			button_width: lib.gui.py(200),
			x: level_width/2 - lib.gui.py(100),
			mid_y: level_height/2 + lib.gui.py(200),
		}, [
			set(child.has_focus, true),
		])),

		])

	  ]),

	  update_log(game_state),
	  
	  display_free_ability(game_state),


	bind_command(spawn_tip_object, game_state),

	fire_event('update_storyline'),

])
  where game_state = state
)
",

message_received: "[

  if(message.type != 'chat_message', set(_last_message_receive_time, cycle)),

  if(_disconnection_dialog and _disconnection_dialog.disconnected_server, [
	set(_disconnection_dialog, null),
	remove_object(_disconnection_dialog),
  ]),

instrument_command('message_received_' + (string<-message.type),
  switch(message.type,
		 'bye', (map(level.chars, remove_object(value)); if(_responding_to_challenge and respond_to_challenge != null, respond_to_challenge(), return_callback(game_result, _state))),

		 'pong_game', pong_game(),

		 'heartbeat', if(message.players, set(_heartbeat_status, filter([PlayerHeartbeat]<- message.players, value.ingame))),

		 'message', [
//		 	spawn_chat_widgets({nick: 'server', message: string<- message.message, timestamp: int<- (message.timestamp or 0)})
		 ], //has message.message with the server message.

		 'confirm_sync',

		  [
		  set(me._remote_state_id_timestamp, cycle),
		  set(me._remote_state_id, int<- message.state_id),
		  ],

		 'player_disconnect',
		 [
			set(_disconnected_players[message.player], level.cycle),
			if(_disconnection_dialog = null and (_state = null or not _state.winner),
			   spawn('disconnection_dialog', 0, 0, {
				_controller: me,
			   }, [
			   	set(_disconnection_dialog, child),
			   ])
			)
		 ],

		 'player_reconnect',
		 [
			set(_disconnected_players, remove_from_map(_disconnected_players, message.player)),
			if(size(_disconnected_players) = 1 and message.player in _disconnected_players,
			   [set(_disconnection_dialog, null), remove_object(_disconnection_dialog)])
		 ],

		 'chat_message',
		 if(message.sub_type = 'presence',
		   if(_state != null and message.nick = enemy_player.name and message.info is map,
			_received_presence_state(map<- message.info)
		   ),

		   message.sub_type = 'text',
//		   spawn_chat_widgets({nick: string<- message.nick, message: string<- message.text, timestamp: int<- (message.timestamp or 0)}),
		   [], //has {text: string, nick: string}
		   ),
		 
		 'game_created',
         [set(me._client, cl), log('DDD: game created')]
		    where cl = create_tbs_client(),

		 'observer_connect',
		 if(lower(nick) not in map(_observers, lower(value)),
		 [
			add(_observers, [nick])
		 ]) where nick = string<- message.nick,

         'game',
		 [
		 if(message.observers != null, set(_observers, [string]<- message.observers)),
		 if(game_state = null,
		 [
			set(_allow_deltas, false),
		 ],
		    observer = false and game_state.players[game_state.nplayer].deck_submitted = false and _choose_deck_object = null,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
			if((specified_deck or (selected_deck and user_decks)) and (_submit_deck_time = null or level.cycle > _submit_deck_time+50), [
				submit_deck(deck, if(user_decks and selected_deck, user_decks[selected_deck].avatar)),
				set(_state, class game_state<- game_state);

				record_stats({
					table: 'game',
					action: 'start',
					uuid: state._uuid,
					is_online: is_online_game,
					campaign_node_id: campaign_node_id,
					nplayer: state.nplayer,
					deck: deck,
					lanes: state.lanes,
				});

				if(observer = false,
					lib.stats.send_stats('game_start', [time().unix, is_online_game, state.players[(state.nplayer+1)%2].name])
				);
				
				game_start_animation(class game_state<- game_state),

				] where deck = specified_deck or user_decks[selected_deck].cards,

				_title_controller != null and _show_deck_selection_at_start,

				//else present the deck selection screen.
				set(_state, class game_state<- game_state);
				[
					game_start_animation(class game_state<- game_state),
					spawn('choose_deck_screen_controller', {
						_mm: me,
						_controller: me,
						title_controller: _title_controller,
					}, [
						set(_choose_deck_object, child),
						schedule(300, child.activate()),
					])
				],

				null asserting specified_deck or selected_deck | 'must specify a deck'

				),

		  ]
		    where user_decks = if(selected_deck_category = 'custom', account_info.decks, DeckMap<- lib.json.get_document_map('data/starting-decks.cfg')),
	
	    [
		log(['YYY GOT game message state id = ', message.state_id, _sent_move_message, if(game_state, game_state.nplayer), if(game_state, game_state.current_player_index)]),
		if(message.server_time is int and _sent_move_message != null, create_server_response_label(int<- message.state_id, int<- message.server_time)),
		set(me._state_id_timestamp, cycle),
	    set(me._state_id, max(_state_id, int<- message.state_id)),
		set(me._allow_deltas, true),
		fire_event('update_game', {message: message + {state: game_state}})
		]
	   )
	   ] where game_state = null|class game_state<-
	   if(message.delta,
		  get_game_state_from_delta(if(_replay != null, -1, int<- message.delta_basis), message.delta),
		  message.state), // end 'game' case.

         [null])) asserting message.type != 'invalid_session',
		 fire_event('request_updates')
	 ]
	 where message = map<- arg.message",

"+request_updates": "if(client.in_flight = 0,
		  [
		    log(['REQUEST_UPDATES', _allow_deltas]),
			tbs_send(client, { type: 'request_updates', state_id: _state_id, allow_deltas: _allow_deltas }),
		  ])",
"+connection_error": "[
	log('message error', string<- arg.error),
	fire_event('request_updates'),

	set(_recent_connection_errors, filter(_recent_connection_errors, value > time().unix-20) + [time().unix]),
	set(_last_connection_error, string<- arg.error),
]",

mouse_wheel: "[
	if(card_mouseover != null and card_mouseover.in_hand and yscroll > 0 and _playing_card = null,
		spawn('inspect_card_dialog', 0, 0, { _mm: me, _controller: me, _card: card_mouseover }),
	),
	
	] where yscroll = int<- arg.yscroll
",

"mouse_down*": "[
	if(_playing_card != null and no_mandatory_play and (mouse_button = 3 or find(level.chars, value is obj player_avatar and value.mouseover or value is obj tile and value.mouseover or value is obj card and value.mouse_over or value is obj button_controller and value.mouseover) = null), [
		clear_input_state(); spawn_cards_in_hand(); _spawn_tile_cursors()
	])
] where mouse_button = int<- arg.mouse_button",

draw: "
	_tutorial.draw(me)
",

process: "
[
check_quiet_front_music(),
_update_timer(),
if(_garbage_collection_pending and cycle > _animation_end_time and not _update_command_queue, [
	trigger_garbage_collection(1),
	set(_garbage_collection_pending, false),
]),

if(_connection_status_display != null and cycle%10 = 0,
[
	set(_connection_status_display.info, conn_status),
	set(_connection_status_display.report, report),
]
	
where report =
	sprintf('Last server message: %sms\n%s%s%s\n%s',
	        if(last_heard_from_server < 2100, '&lt;2000', str(last_heard_from_server)),
			if(recent_errors > 0, sprintf('Connection errors: %d\n%s\n', recent_errors, _last_connection_error), ''),
			if(_recover_connection_time is int and cycle - _recover_connection_time < 120, 'RESETTING CONNNECTION...\n', ''),
			fold(map(_heartbeat_status, sprintf('%s: %dms', value.nick, value.lag)), a + '\n' + b, ''),
			_sync_text
	)
where conn_status = if(recent_errors = 0 and last_heard_from_server < 5000 and worst_lag < 2000, { color: 'green', summary: 'Connected' },
                       last_heard_from_server > 9000, { color: 'gray', summary: sprintf('Server Disconnect (%ds)', last_heard_from_server/1000) },
					   recent_errors > 0, { color: if(recent_errors > 2, 'red', 'yellow'), summary: sprintf('Connection errors (%d)', recent_errors) },
					   last_heard_from_server >= 5000, { color: 'yellow', summary: sprintf('Server Lag (%ds)', last_heard_from_server/1000) },
					   worst_lag >= 10000, {color: 'red', summary: sprintf('Opponent Disconnect (%ds)', worst_lag/1000) },
					                       {color: 'yellow', summary: sprintf('Opponent Lag (%ds)', worst_lag/1000) } )
where recent_errors = if(_recent_connection_errors and _recent_connection_errors[size(_recent_connection_errors)-1] > time().unix-20, size(_recent_connection_errors), 0)
where last_heard_from_server = ((cycle - _last_message_receive_time)*1000)/60
where worst_lag = (max(map(_heartbeat_status, value.lag)) or 0)*10
),

if(_debug_label_mouse_loc, _debug_show_mouse_loc()),
if(in_background,
 [
  pump_game_state_queue(),
  process_connection(),
  if(_choice_object != null and cycle%10 = 0, _process_presence_state()),
 ],
 [
  
  //remove the opponent's preview card if the card it's based on is no longer around.
  if(_opponent_card_mouseover, if(find(level.chars, value = _opponent_card_mouseover) = null, [
	set(_opponent_card_mouseover, null),
	set(_opponent_preview_card, null),
  ])),

  if(_state,
 	 set(_anim_stats[anim_state], val+1)
 	 where val = _anim_stats[anim_state] or 0
 	 where anim_state = if(cycle <= _animation_end_time, _animation_reason, myturn, 'idle', 'opponent_idle')
  ),

  process_disconnected_label(),

  create_animation_status_label(_animation_end_time - cycle),
  
  refresh_state_id_sync_label(),

  if(_prev_mouse_pos != [mouse_x,mouse_y], [
     set(_last_mouse_move, cycle),

	 if(_tooltip and not lock_tooltip, [
		 map(_tooltip, remove_object(value)),
		 set(_tooltip, []),
		 set(_tooltip_locked_by, null)
	 ]) where lock_tooltip = (_tooltip_locked_by != null and _tooltip_locked_by is obj creature and _tooltip_locked_by.has_mouseover and (_tooltip_locked_by in level.chars)),
  ]),

  set(_prev_mouse_pos, [mouse_x,mouse_y]),

  if(cycle - _last_mouse_move = 30 and _tooltip = [], [
	show_tooltip(),
  ]),

  if(cycle%10 = 0, _process_presence_state()),

  if(_end_turn_pending, end_turn()),

  [

  if(card_mouseover and card_mouseover.in_hand and card_mouseover.hand_index != card_over and not _card_dragging,
     mouse_leave_card(card_mouseover)),
  if(card_over != -1 and (card_mouseover = null or card_mouseover.hand_index != card_over),
	 if(card_obj and ('animate_draw' not in card_obj.animated_movements), mouse_enter_card(card_obj))
		where card_obj = find(level.chars, value is obj card and value.is_placeholder = false and value.in_hand and value.player_index = state.nplayer and value.hand_index = card_over and myplayer.mulligan = false)
  )
  ] where card_over = _hand_card_moused_over,

  set(me._prev_ctrl_keys, level.player.ctrl_keys),

  //enter pressed
  if('Return' in level.player.ctrl_keys and 'Return' not in me._prev_ctrl_keys,

     if(_chat_area = null or find(level.chars, value = _chat_area) = null,
     	spawn_chat_widgets(),
		_chat_area.set_focus()
	 )
  ),

  //space pressed
  if(' ' in level.player.ctrl_keys and (' ' not in me._prev_ctrl_keys) and find(level.chars, value is obj text_entry and value.has_focus) = null and _end_turn_button != null and _end_turn_button.highlight,
	end_turn()
	//set(_skip_animations, true)
  ),

  //escape pressed
  if('Escape' in level.player.ctrl_keys and 'Escape' not in me._prev_ctrl_keys and
     _chat_area != null,
	 [
//	 set(_chat_area.has_focus, false)
	 ]
  ),

//  if(_chat_area != null and _chat_area.has_focus, set(_last_chat_area_interact, cycle)),

//  if(_chat_area != null and cycle - _last_chat_area_interact > 2500 and find(level.chars, value = _chat_area) != null, [
//	remove_object(_chat_area),
//	set(_chat_area.has_focus, false),
//  ]),

  if(_response_pause_counter > 0, [
	  add(_response_pause_counter, -1),
	  if(' ' in level.player_info.ctrl_keys, [
		set(_response_pause_counter, -1),
	  ])
  ]),
  if(_response_pause_counter = 0, [
	set(_response_pause_counter, -1),
	send_move_message({
	 type: 'moves',
	 state_id: _state_id,
	 moves: [end_turn_message]
	}),
  ]),
  if(_animated_spell_card,
	 if(_spell_animation_time >= 60, [
			 log('REMOVE SPELL: ' + if(_animated_spell_card in level.chars, true, false)),
		add(_spells_on_stack, [_animated_spell_card]),
		set(_animated_spell_card, null),
		set(_spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(_spell_animation_time = 80 and (level.player_info.ctrl_mod_key in [1,2]),
	     reserve_animation_time('spell_anim', 20),
	 [
	    add(_spell_animation_time, 1),
		if(_spell_animation_time <= 20, [
			set(_animated_spell_card.alpha, new_alpha),
			] where new_alpha = min(255, if(_spell_animation_time <= 20, _spell_animation_time*22, (100 - _spell_animation_time)*22))
			),
	 ]))), //end animated_spell_card

	pump_game_state_queue(),
	process_connection(),
 ]),
 
]",

end_anim: "animation('normal')",
}, //end events

timer_frequency: 10,

}
