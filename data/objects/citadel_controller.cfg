{
id: "citadel_controller",
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,
vars: {
	client: null,
	state: null,
	state_id: -1,
	processed_state_id: -1,
	card_preview: null,
	card_preview_for: null,
	game_created: false,
	session_id: -1,
	font: 'RobotoCondensed-Regular',
	color: 'antique_white',
	selected_deck: '',
	game_server_address: TBS_SERVER_ADDRESS,
	game_server_port: TBS_SERVER_PORT,

},

tmp: {
	//location of the tops of our cards
	card_hand_top: 0,

	prev_ctrl_keys: [],

	playing_card: -1,
	playing_ability: null,
	targets_chosen: [],
	active_targets: [],
	animation_move_time: 0,
	animation_end_time: -1,
	game_state_queue: [],
	furthest_animation_hint: 0,
	animation_hints_id: 0,
	animated_spell_card: null,
	spells_on_stack: [],
	spell_animation_time: 0,

	choice_object: null,

	deck_obj: null,
	discard_obj: null,
	hand_obj: null,
	level_obj: null,

	card_mouseover: null,
	cards_suggest_discard: null,	

	last_state_message: null,

	status_label: null,

	response_pause_counter: -1,

	timer_bar: null,

	turn_schedule: null,
	bdk_controller: null,

	//is a list of card objects when we are showing the discard pile.
	discard_pile_cards: null,
},

properties: {
	return_callback: { default: "@eval def(bool result) ->commands null" },

	game_created: { get: "vars.game_created", set: "set(vars.game_created, value)" },
	session_id: { get: "vars.session_id", set: "set(vars.session_id, value)" },
	selected_deck: { get: "vars.selected_deck", set: "set(vars.selected_deck, value)" },
	game_server_address: { get: "vars.game_server_address", set: "set(vars.game_server_address, value)" },
	game_server_port: { get: "vars.game_server_port", set: "set(vars.game_server_port, value)" },

	level_width: "level.dimensions[2]",
	level_height: "level.dimensions[3]",

	card_keeps: "[card.vars.hand_index | card <- level.chars, card.type = 'card', card.vars.in_hand, card.marked_as_keep]",

	card_keep_draw_id: "[card.card_type.draw_id | card <- level.chars, card.type = 'card', card.vars.in_hand, card.marked_as_keep]",

	end_turn_message: "{type: 'end_turn', keep: card_keeps}",

	set_status_label: "def(text, color='white', duration=150) [
		if(tmp.status_label, remove_object(tmp.status_label)),
		spawn('citadel_controller.status_label', 0, 0, 1, [
			set(tmp.status_label, child),
			set(child.zorder, 1200),
			if(duration > 0, execute(child, schedule(duration,
			                                         remove_object(child)))),
			debug('init label: ' + text),
			child.init_label(text, color, tmp.card_hand_top),
		])
	]",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def(new_state=null) execute(me, [
		if(tmp.card_mouseover, mouse_leave_card(tmp.card_mouseover)),
	   	map(level.chars, if(value.type = 'tile', set(value.selectable, false))),
		set(tmp.playing_card, -1),
		set(tmp.playing_ability, null),
		set(tmp.targets_chosen, []),
		set(tmp.active_targets, []),
		set(tmp.cards_suggest_discard, null),
		set(tmp.card_mouseover, null),
	    if(tmp.card_mouseover, tmp.card_mouseover.hide_keep_button()),
	])",

	//debug function to execute FFL on the server.
	server_exec: "def(code) execute(me, tbs_send(vars.client, {
		type: 'moves',
		state_id: vars.state_id,
		moves: [{
			type: 'debug',
			exe: code
		}]
	}))
	",

	debug_draw: "def(ncards) if(is_string(ncards), debug_card(ncards), server_exec('players[current_player].draw_cards(me, ' + ncards + ')'))",
	debug_mana: "def(nmana) server_exec('add(players[current_player].resources, ' + nmana + ')')",
	debug_card: "def(name) server_exec('add(players[current_player].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",
	debug_card_enemy: "def(name) server_exec('add(players[next_player_index].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",

	debug_enemy_hand: "map(vars.state.opponent_obj.hand, value.name)",
	
	animation_up_to_date: "vars.processed_state_id = vars.state_id",
	reserve_animation_time: "def(ncycles) if(end_time > tmp.animation_end_time, set(me.tmp.animation_end_time, end_time)) where end_time = level.cycle + ncycles",
	myplayer: "vars.state.players[vars.state.nplayer]",

	hand_index_after_discarding: "def(nhand) nhand - count(level.chars, value.type = 'card' and value.vars.discarded and value.vars.hand_index < nhand)",

	mark_sent_discards: "
	[set(card.vars.sent_discard_msg, true) |
	  card <- level.chars, card.type = 'card', card.vars.discarded = true]
	",

	discard_command: "def(additional_indexes=[])
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = additional_indexes + [card.vars.hand_index |
	    card <- level.chars, card.type = 'card', card.vars.discarded = true,
		                     card.vars.sent_discard_msg = false]
	",

	remove_preview_card: "def(card) if(vars.card_preview and (vars.card_preview_for = card or card = null), [if(vars.card_preview.vars.creature, vars.card_preview.vars.creature.destroy()), remove_object(vars.card_preview), set(vars.card_preview, null)])",

	mouse_enter_card: "def(card) [
	 if(card.vars.in_hand, card.show_keep_button()),
	 (if(tmp.playing_card = -1, if(tmp.card_mouseover = card, null,
	  if(tmp.card_mouseover != null, [
			mouse_leave_card(tmp.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.vars.in_hand,
	  if(discards != null and possible_targets != [],
	  [
	 	card.show_halo(),
	    set(tmp.card_mouseover, card),
	    set(tmp.cards_suggest_discard, discards),

		//synthetic clicks to suggest discarding
	  	[card_right_clicked(card) | card <- level.chars, card.type = 'card', card.vars.hand_index in discards]
	  ])
	  where discards = (local_player.suggest_discards(local_player.calculate_cost(local_player.hand[card.vars.hand_index]), [card.vars.hand_index] + [card.vars.hand_index | card <- level.chars, card.type = 'card', card.vars.discarded or card.marked_as_keep])
		  ))
 	  where possible_targets = card.card_type.possible_targets(vars.state, vars.state.nplayer, [])
	  )))

	asserting (not card.vars.in_hand) or (card.vars.hand_index < size(local_player.hand)) | 
	[size(card.vars.hand_index), card.vars.hand_index, card.card_type.name, [[card.vars.hand_index, card.vars.in_hand, card.card_type.name] | card <- level.chars, card.type = 'card'], [card.name | card <- local_player.hand]]
	  )]
	  where local_player = myplayer",

	mouse_leave_card: "def(card) [
	  card.hide_keep_button(),
	  if(tmp.card_mouseover = card, [
		map(tmp.cards_suggest_discard, if(obj and obj.vars.discarded, card_clicked(obj)) where obj = find(level.chars, value.type = 'card' and value.vars.hand_index = context.value)),
		set(tmp.card_mouseover, null),
	])
	]",

	clear_discard_pile: "def() -> commands execute(me,
		if(tmp.discard_pile_cards, [
			map(tmp.discard_pile_cards, remove_object(value)),
			set(tmp.discard_pile_cards, null)
		])
	)",

	mouse_enter_discard: "def(int nplayer) -> commands execute(me, [
	  clear_discard_pile(),
	  set(tmp.discard_pile_cards, []),
	  map(vars.state.players[nplayer].discard_pile,
	      spawn('card', level_width/2, level_height/2 - (size(vars.state.players[nplayer].discard_pile)-1)*50 + index*50, 1, [
			set(child.card_size, 2),
			set(child.vars.in_hand, false),
		  	set(child.card_type, construct('card', get_document('data/cards.cfg')[value])),
			set(child.zorder, 4000 + index),
			add(tmp.discard_pile_cards, [child])
		  ]))
	])",

	mouse_click_discard: "def(int nplayer) -> commands execute(me, cycle_discard_pile())",

	cycle_discard_pile: "def(int delta=1) -> commands if(tmp.discard_pile_cards, execute(me, [
		map(tmp.discard_pile_cards, [
			set(value.x, target.x),
			set(value.y, target.y),
			set(value.zorder, target.zorder),
		] where target = tmp.discard_pile_cards[(index + delta)%size(tmp.discard_pile_cards)])
	]))",

	mouse_leave_discard: "def(int nplayer) -> commands execute(me, [
		clear_discard_pile(),
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(tile) if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
		 set(vars.card_preview_for, tile.vars.loc)
	   ]) where card = get_document('data/cards.cfg')[creature.name])
	      where creature = vars.state.creature_at_loc(tile.vars.loc)",
	mouse_leave_tile: "def(tile) remove_preview_card(tile.vars.loc)",

	mouse_enter_log: "def(index)
	   if(items = null, if(is_string(vars.card_preview_for),
			           remove_preview_card(vars.card_preview_for)),
		[
//			 mouse_enter_card({card_type: construct('card',
//			    get_document('data/cards.cfg')[items[1]])}),
			 set(vars.card_preview_for, items[1])
	    ])
	    where items = if(index = -1, null,
		   regex_match(vars.state.log[index], '(.*) plays (.*)'))",

	card_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	  if(card.vars.discarded,
	  [card.set_discarded(false), add(myplayer.resources, -1)],
	  [tile_clicked(null),

	   //commit to any card discard at this point.
	   set(tmp.card_mouseover, null),
	   if(tmp.card_mouseover, tmp.card_mouseover.hide_keep_button()),
	   set(tmp.cards_suggest_discard, null),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])
	]))",
	card_right_clicked: "def(card) [
	 if(card.marked_as_keep, card.toggle_keep()),
	 if(vars.state.nplayer = vars.state.current_player,
	 if((not card.vars.discarded) and (not card.card_type.hero), [
	   tile_clicked(null),
	   add(myplayer.resources, 1),
	   card.set_discarded(true)
	],
	 if(card.card_type.hero, set_status_label('Hero cards may not be discarded for mana', 'red'))
	))
	]",

	option_clicked: "def(choice_value) execute(me, [
	debug('option clicked: ' + choice_value),
	tbs_send(vars.client, {
		type: 'moves',
		state_id: vars.processed_state_id,
		moves: [{
			type: 'make_choice',
			choice: choice_value,
		}],
	})
	])",
	      
	tile_clicked: "def(tile) [if(not vars.state.current_choice, [
	   execute(me, 	map(level.chars, if(value.type = 'tile',
	                                    set(value.selectable, false)))),
	   if(tile and tmp.playing_card != -1 and tile.selectable,
		  choose_targets_for_card(
		    find(level.chars, value.type = 'card' and
			                  value.vars.hand_index = tmp.playing_card),
			tmp.targets_chosen + [tile.vars.loc]),
		 
		 if(tile and tmp.playing_ability != null and tile.selectable,
		    choose_targets_for_ability(tmp.playing_ability.creature,
			                           tmp.playing_ability.ability,
									   [tile.vars.loc]),

		//cancel all discards
	   [
		if(tile, [card_clicked(card) |
				  card <- level.chars,
				  card.type = 'card' and card.vars.discarded]),
		if(tile != null, adapt_input_state(null))
	   ]))
	 ])]",
	
	choose_targets_for_ability: "def(creature, ability, targets) execute(me, [
		 tbs_send(vars.client, {
		   type: 'moves',
		   state_id: vars.processed_state_id,
		   moves: discard_command(myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability.name, targets: targets, player_index: vars.state.current_player}]
		  }),
		  mark_sent_discards,
		  [set(tile.selectable, false) | tile <- level.chars, tile.type = 'tile'],
		  set(tmp.playing_card, -1),
		  set(tmp.targets_chosen, []),
		  set(tmp.active_targets, []),
		  set(tmp.playing_ability, {creature: creature, ability: ability}),
	])",
	
	choose_targets_for_card: "def(card, current_targets) execute(me,
	if(vars.state.in_response_phase and not card.card_type.is_response,
	set_status_label('Can only cast response spells during response phase', 'red'),
	[
	   if(vars.state.nplayer = vars.state.current_player,
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [] and not unique_violation,
		      if(possible_targets = null,
				[
				 tbs_send(vars.client, {
				   type: 'moves',
				   state_id: vars.processed_state_id,
				   moves: discard_command() + [{
					type: 'play_card',
					index: hand_index_after_discarding(card.vars.hand_index),
					player_index: vars.state.current_player,
					targets: current_targets,
				   }]
				  }),
				 mark_sent_discards,
				 set(tmp.playing_card, -1),
				 set(tmp.playing_ability, null),
				],
			    [
				 map(level.chars, if(value.type = 'tile', set(value.selectable, value.vars.loc in possible_targets))),
				 set(tmp.playing_card, card.vars.hand_index),
				 set(tmp.playing_ability, null),
				 set(tmp.active_targets, []),
				 set(tmp.targets_chosen, current_targets)
				]),
			  [
			   set_status_label(if(possible_targets = [], 'No valid targets',
			        if(not can_afford, 'Not enough mana: ' + myplayer.resources + ' to play ' + card.card_type.name,
						card.card_type.name + ' is already on the field, you may not play copies of a hero.')), 'red')
			  ])]
		where unique_violation = card.card_type.hero and card.card_type.creature and find(vars.state.creatures, value.name = card.card_type.name and value.controller = vars.state.nplayer)

		//we should already have suggested discards at this point, so
		//if the card is playable, the player can afford it straight-up
		where can_afford = myplayer.can_afford(card.card_type.school, card.card_type.cost, card.card_type.loyalty_cost)
		where possible_targets = card.card_type.possible_targets(vars.state, vars.state.nplayer, current_targets))
	 ]))",
	
	
	creature_clicked: "def(creature) execute(me, [
	    if(creature.vars.creature_object.is_on_board,
		  [map(filter(level.chars, value.type = 'creature_status'), value.destroy()),
		   spawn('creature_status', 300, 410, 1, [set(child.creature_object, creature.vars.creature_object)])]
		  )
	  ])",
	
	can_use_ability: "def(creature, ability_name)
	 vars.state.nplayer = vars.state.current_player and
	 vars.state.nplayer = creature.controller and
	 ((not vars.state.in_response_phase) or ability.is_response) and
	 ((not ability.exhausts_creature) or (not creature.is_exhausted)) and
	 myplayer.suggest_discards(myplayer.calculate_cost(ability)) != null and creature.summoned and
	 ability.is_usable(vars.state, creature)
	  asserting ability
	  where ability = find(creature.activated_abilities, value.name = ability_name)",
	 
	
	ability_clicked: "def(creature, ability_name)
	execute(me, [
	if(animation_up_to_date and can_use_ability(creature, ability_name),
		//we'll calculate our possible_targets:
		// - null means we play the ability right now
		// - [] means there are no valid targets and the ability can't play
		// - a list of targets means we invite the player to select their
		//   preferred target.
		if(possible_targets = null, 
	    [
		  tbs_send(vars.client, 
		  {
			type: 'moves',
			state_id: vars.state_id,
		    moves: discard_command(myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name, targets: [], player_index: vars.state.current_player}],
		  }),
		  mark_sent_discards
		  ],
		 if(possible_targets = [], set_status_label('No available targets for ability', 'red'),
		    [
				[set(tile.selectable, if(tile.vars.loc in possible_targets, true, false)) | tile <- level.chars, tile.type = 'tile'],
				set(tmp.playing_card, -1),
				set(tmp.targets_chosen, []),
				set(tmp.active_targets, []),
				set(tmp.playing_ability, {creature: creature, ability: ability}),
				
			]))
		where possible_targets = ability.possible_targets(vars.state, creature, [])
	) asserting ability
	  where ability = find(creature.activated_abilities, value.name = ability_name)
	  ])",
	
	animate_draw_cards: "def(ncards)
	  if(size(cards) >= ncards, map(cards,
		 value.animate_draw()
	  ))
	  where cards = sort([card | card <- level.chars, card.type = 'card', card.vars.hand_index != null], a.vars.hand_index > b.vars.hand_index)",
	
	card_on_stack: "def(card)
	   card.vars.stack_id and find(vars.state.stack, value.stack_id = card.vars.stack_id)",

	handle_animation_hint: "def(hint) [
	if(hint.type in ['play_card', 'play_ability'],
	  [
		reserve_animation_time(100),
		set(tmp.spell_animation_time, 0),
		spawn('card', xloc, 150 + 40*size(vars.state.stack), 1,
			   [
			    if(tmp.animated_spell_card, [
		   		    add(tmp.spells_on_stack, [tmp.animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(tmp.animated_spell_card, child),
		        set(child.vars.in_hand, false),
				set(child.vars.allow_drag, true),
				set(child.vars.stack_id, hint.stack_id),
				set(child.card_size, 2),
			    set(child.alpha, 0),
			    set(child.zorder, 1000 + hint.stack_id),
				sound_loop('spells/Spell-windup2.wav', 0.35, 0.5),
				set(draw_primitives, map(hint.targets, if(target_tile, {
					type: 'arrow',
					texture: 'ink.png',
					texture_scale: 0.2,
					arrow_head_length: 40,
					arrow_head_width: 0.4,
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value.type = 'tile' and value.vars.loc = context.value))),
			    set(child.card_type,
				 if(hint.type = 'play_card',
				    construct('card', get_document('data/cards.cfg')[hint.card_type]),
					hint.ability))
				])
]
	  where xloc = (level_width - 1024)/2 +
	               if(find(hint.targets, value[1] <= 3),
	            if(find(hint.targets, value[1] >= 7), 512, 712),
	  
	           //none on left
			   if(hint.targets, 312, 512))
	),
	if(hint.type in ['fizzle', 'resolve'],
		if(hint.type = 'fizzle', fizzling_card.start_fizzle_animation(), fizzling_card.start_resolve_animation())
		where fizzling_card = find(level.chars, value.type = 'card' and value.vars.stack_id = hint.stack_id)
	)
   ]
",

	set_widgets_for_message: "def(message)
	  if(message.state.nplayer = message.state.current_player, 
	    set_widgets(
		
		if((not message.state.in_response_phase) and
		   (not message.state.done_movement) and
		   find(message.state.creatures,
		        value.controller = message.state.nplayer) != null,
		[
		{
			type: 'button',
			id: 'movement_button',
			x: level_width - 524,
			y: level_height - 618,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: 'Movement',  font: vars.font, size: 16, color: vars.color},
			on_click: def() execute(me, (if(animation_up_to_date, [set_widgets([]),
			             set(tmp.playing_card, -1),
						 set(tmp.playing_ability, null),
			             set(tmp.active_targets, []),
						 tbs_send(vars.client,
						   {
						     type: 'moves',
							 state_id: vars.state_id,
						     moves: discard_command() + [{type: 'movement'}]
						   }
						  ),
						  mark_sent_discards
						 ]))),
		}
		], []) +
	
		[
		{
			type: 'button',
			id: 'end_turn_button',
			x: level_width - 524,
			y: level_height - 568,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: if((not message.state.in_response_phase), 'End Turn', 'End Response'), font: vars.font, size: 16, color: vars.color},
			on_click: def() execute(me, if(animation_up_to_date, [set_widgets([]),
			             set(tmp.playing_card, -1),
						 set(tmp.playing_ability, null),
			             set(tmp.active_targets, []),
						 tbs_send(vars.client, {
						  type: 'moves',
						  state_id: vars.state_id,
						  moves: [end_turn_message]
						 })
						 ])),
		},
		
		]),
	    set_widgets([{
			type: 'label',
			text: if((not message.state.in_response_phase), 'Enemy Main Phase', 'Enemy Response Phase'),
			id: 'status_label',
			x: level_width - 524,
			y: level_height - 538,
			font: vars.font, 
			size: 16, 
			color: vars.color			
	   }]))",
	
	set_schedule_for_message: "def(message) [
		if(tmp.turn_schedule, remove_object(tmp.turn_schedule)),
		spawn('citadel_controller.turn_schedule',
		      level_width - 360, 480, 0, [
			set(child.state, message.state),
			set(tmp.turn_schedule, child),
		])
	]",

	spawn_tiles: "def(message)
		 if(find(level.chars, value.type = 'tile') = null, 
		   map(range(message.state.rows), map(range(message.state.columns), spawn('tile', 132 + (level_width - 1024)/2 + col*90 + if(row%2 = 1, 45, 0), 104 + row*52, 1, [set(child.vars.loc, [row,col]), set(child.game_state, message.state)]) where col = value) where row = value),
		   [ [set(tile.game_state, message.state)] | tile <- level.chars, tile.type = 'tile']
		  )
	",

	spawn_cards_in_hand: "def(class game state, int drawn_cards=0) ->commands
	[
	  map(state.players[state.nplayer].hand,
	     spawn('card', 117 + index*card_spacing, card_top, 1,
		   [set(child.vars.in_hand, true),
		    set(child.vars.hand_index, index),
			set(child.zorder, 900+index),
			set(child.card_size, card_scale),
	        set(child.vars.player, state.players[state.nplayer]),
		    set(child.card_type, value),

			set(child.y2, level_height - 5),

			//make the new card animate its way in if it's just been drawn.
			if(size(state.players[state.nplayer].hand) - index <= drawn_cards, fire_event(child, 'animate_draw')),

			if(value.draw_id in card_keep_draw_id, child.toggle_keep()),
		  ])),

		set(tmp.card_hand_top, card_top),
	]
  where card_top = decimal<- level_height - (203*card_scale - 20)
  where card_spacing = decimal<- min(135*card_scale, if(hand_size, card_x_area/hand_size, 100))
  where card_scale = decimal<- min(card_scale_x, card_scale_y)
  where card_scale_x = decimal<- (5.0/max(5.0, hand_size*0.8))*decimal(card_x_area)/decimal(1024 - 300)
  where card_scale_y = decimal<- card_y_area/203.0
  where card_y_area = decimal<- level_height - 560
  where card_x_area = decimal<- level_width - 300
  where hand_size = int<- size(state.players[state.nplayer].hand)
	",

	display_player_life: "def(message)
		map(message.state.players, map(range(max(value.life, 0)), spawn('citadel_controller.heart', if(context.index = 0, 62 + (level_width - 1024)/2, level_width - (52 + (level_width - 1024)/2)), 34 + index*40, 1)))",
	
	display_choice: "def(message) [
	  if(tmp.choice_object, [tmp.choice_object.destroy(), set(tmp.choice_object, null)]),
	  if(message.state.current_choice and message.state.current_choice.player_index = message.state.nplayer,
	  	spawn('choice_controller', 0, 0, facing, [
			set(child.game, message.state),
			set(tmp.choice_object, child),
			debug('spawned choice'),
		 ]))
    ]",

	update_log: "def(message)
		find(level.chars, value.type = 'log_controller').set_log(message.state.log, if(vars.state, myplayer, null))",
	
	bdk: "def(string bot_name) [
		if(tmp.bdk_controller, remove_object(tmp.bdk_controller)),
		spawn('bdk_controller', 0, 0, 1, [
			child.load(bot_name),
			set(tmp.bdk_controller, child),
		]),
	]",

	force_submit_deck: "def([string] deck)
		execute(me, tbs_send(vars.client, {type: 'submit_deck', deck: deck, force: true}))",
},

on_generate_mouseover_card: "mouse_enter_card(card)",

on_create: "[ 
	fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),
	console_output_to_screen(false), if(size(get_module_args()) > 0, 
	[set(vars.client, cl),
	tbs_send(cl, {type: 'start_game'}), debug('game created')] where cl = tbs_client(get_module_args().server_address, get_module_args().server_port, get_module_args().session_id),
	if(game_created, 
	[set(vars.client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		where cl = tbs_client(game_server_address, game_server_port, session_id),
	set_widgets(
	[{
		type: 'grid',
		columns: 1,
		children: [

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Join Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'request_updates', state_id: vars.state_id})]
				         where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 2))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Create Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Play vs Bot', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', bot: true, bot_type: 'evolutionary', args: {rules: 'evo/evolution12.cfg'}, session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

		]
	},
	])))]
",

on_update_discard_and_deck: "[
	map(tmp.deck_obj, value.set_label(str(size(vars.state.players[index].deck)), vars.font)),
	map(tmp.discard_obj, value.set_label(str(size(vars.state.players[index].discard_pile)), vars.font)),
	map(tmp.hand_obj, value.set_text(['Cards', str(size(vars.state.players[index].hand)), 'Mana', str(vars.state.players[index].resources)], vars.font)),
	map(tmp.level_obj, value.set_widgets([{
		type: 'grid',
		x: 40,
		columns: 2,
		children: fold(map(filter(vars.state.players[index].resource_level, value > 0), [
			{
				type: 'image',
				image: 'magic-icons.png',
				area: [3+17*(key-1), 3, 18+17*(key-1), 18],
			},

			{
				type: 'label',
				text: 'Lvl ' + str(value),
				font: 'RobotoCondensed-Bold', 
				color: 'white',
				size: 12,
			},

			{
				type: 'label',
				text: str(vars.state.players[context.index].xp_level[key]) + '/' + str(vars.state.players[context.index].xp_needed[key]),
				font: 'RobotoCondensed-Bold',
				color: 'white',
				size: 12,
			},

			{
				type: 'label',
				text: 'XP',
				font: 'RobotoCondensed-Bold',
				color: 'white',
				align_h: 'right',
				size: 12,
			},

		]), a+b)
	}])),
]",

on_window_resize: "[
	[ [add(card_back.x, delta_w)]
	| card_back <- level.chars,
	  card_back.type = 'citadel_controller.card_back',
	  card_back.tmp.player_index = 1],

	[ card.destroy() | card <- level.chars, card.type = 'card', card.vars.in_hand],
	
	[ tile.destroy() | tile <- level.chars, tile.type = 'tile' ],

    [remove_object(heart) | heart <- level.chars, heart.type = 'citadel_controller.heart'],
	
	set(level.dimensions, [0,0,new_width,new_height]),
	fire_event('dimensions_updated')
] where delta_w = new_width - level_width
  where delta_h = new_height - level_height
  where card_width = min(135*card_scale, if(hand_size, card_area/hand_size, 100))
  where card_scale = max(1.0, decimal(card_area)/decimal(1024 - 300))
  where card_area = new_width - 300
  where new_width = max(width,1024)-1
  where new_height = max(height,768)-1
  where hand_size = count(level.chars, value.type = 'card' and value.vars.in_hand)",

on_dimensions_updated: "[
	if(tmp.last_state_message, [
        display_choice(tmp.last_state_message),
		set_widgets_for_message(tmp.last_state_message),
		set_schedule_for_message(tmp.last_state_message),
		spawn_tiles(tmp.last_state_message),
		adapt_input_state(tmp.last_state_message),
		display_player_life(tmp.last_state_message),
		update_log(tmp.last_state_message),
		spawn_cards_in_hand(vars.state)
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0, 1,
	          [set(child.creature_object, creature.creature_object)] asserting creature.creature_object)]
	| creature <- level.chars,
	  creature.type = 'creature',
	  creature.creature_object.is_on_board ]
]",

on_update_spells_on_stack: "
 [
  set(tmp.spells_on_stack, survivors),
  map(leaving, execute(value, [
  	set(value.vars.do_not_remove, true),
	stop_sound('spells/Spell-windup2.wav', 0.5),
	[schedule(n, [
	  map(value.draw_primitives, set(value.color, [255,0,0,255-n*10]))])
	  | n <- range(25)],
	schedule(26, remove_object(value)),
  ]))
 ]
  where leaving = filter(tmp.spells_on_stack, not card_on_stack(value))
  where survivors = filter(tmp.spells_on_stack, card_on_stack(value))",

on_update_game: "
   if((not force_process) and
      (tmp.game_state_queue != [] or level.cycle < tmp.animation_end_time),
	 add(tmp.game_state_queue, [message]),

     if(message.state_id > vars.processed_state_id,
	 [
	 	adapt_input_state(message.state),

		debug('ZZ: update_game: ' + message.state.nturn + '/' + message.nplayer + ' / ' + message.state.current_player_index),

		if(not tmp.deck_obj, [
			set(tmp.deck_obj, deck_obj),
			set(tmp.discard_obj, discard_obj),
			map(discard_obj, set(value.tmp.controller, me)),
			set(tmp.hand_obj, hand_obj),
			set(tmp.level_obj, level_obj),
			map(discard_obj, set(value.tmp.player_index, index)),
			map(deck_obj, set(value.tmp.player_index, index)),
			map(hand_obj, set(value.tmp.player_index, index)),
			map(level_obj, set(value.tmp.player_index, index)),
			map(discard_obj, set(value.animation, 'front')),
			map(hand_obj, set(value.animation, 'hand')),
			map(level_obj, set(value.animation, 'hand')),
			map(deck_obj, set(value.scale, 0.5)),
			map(discard_obj, set(value.scale, 0.5)),
			map(hand_obj, set(value.scale, 0.5)),
			map(level_obj, set(value.scale, 0.5)),
			map(deck_obj, add_object(value)),
			map(discard_obj, add_object(value)),
			map(hand_obj, add_object(value)),
			map(level_obj, add_object(value)),
		] where deck_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 450, 1))
		  where discard_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 150, level_width - 150), 450, 1))
		  where hand_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 250, level_width - 250), 450, 1))
		  where level_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 250, 1))),

	 	reserve_animation_time(10),
	    set(vars.processed_state_id, message.state_id),
		map(animation_hints, handle_animation_hint(value)),
		set(tmp.animation_hints_id, message.state.animation_hints_id),
		set(tmp.furthest_animation_hint, size(message.state.animation_hints)),
	    set(vars.state, message.state),
		debug('SET NEW STATE'),

	    debug('got state_id: ' + message.state_id + '/' + vars.state_id + ' response phase: ' + if(vars.state, vars.state.in_response_phase)),
	    [remove_object(heart) | heart <- level.chars, heart.type = 'citadel_controller.heart'],

		display_player_life(message),
		display_choice(message),
	    if(creature_status,
			if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
			   where creature = find(message.state.permanents,
			        value.summon_id = creature_status.creature_object.summon_id)
				
				) where creature_status = find(level.chars, value.type = 'creature_status'),
	    [map(filter(level.chars, (value.type in ['card', 'tile.level_label']) and ((value.type != 'card') or (not value.vars.do_not_remove) and value != tmp.animated_spell_card) and not (value in tmp.spells_on_stack)), value.destroy()),

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(message)
	  ],

	  if(message.state.in_response_phase and message.state.nplayer = message.state.current_player,
		[
		  spawn('citadel_controller.timer_bar', 0, 0, 1, [
		  	child.create_bar(),
			set(tmp.timer_bar, child),
		  ]),

		  if(tmp.timer_bar, remove_object(tmp.timer_bar)),

	      set(tmp.response_pause_counter, 150),
		  set_status_label(if(message.state.stack, '', 'Combat phase -- ') + 'Press SPACE if you want to respond', 'white', 150),
		],

		[
			if(tmp.timer_bar, remove_object(tmp.timer_bar)),
			set(tmp.response_pause_counter, -1),
		]
	  ),

	  set_widgets_for_message(message),
	  set_schedule_for_message(message),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(tmp.animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(message.state.creatures,
		                     value.summon_id = creature.summon_id) or
							 message.state.graveyard[creature.summon_id]
	    where creature = obj.vars.creature_object
		| obj <- level.chars, obj.type = 'creature'],
		value), 30, 0)), 

	  map(filter(level.chars, value.type = 'creature' and
	          find(message.state.permanents,
			       context.value.vars.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = message.state.graveyard[value.creature_object.summon_id]), 
	  [
		spawn_cards_in_hand(message.state, drawn_cards),
		if(drawn_cards > 0, reserve_animation_time(30 + 10*size(message.state.players[message.state.nplayer].hand)))
	  ]
		  where drawn_cards =
		    fold([hint.ncards | hint <- animation_hints,
		                        hint.type = 'draw_cards',
							    hint.player_index = message.state.nplayer], a+b, 0),
	  
	  map(message.state.permanents,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     [set(obj.creature_object, value),
			 if(card_rules, set(value.rules, card_rules))],
	      
		  //create a new object to represent this creature.
		  [debug('SPAWN CREATURE: ' + value.name),
	      spawn('creature', 0, 0, 1,
				[set(child.creature_object, value), if(card_rules, set(value.rules, card_rules))] asserting value)])
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value.type = 'creature' and
		                                value.vars.creature_object.summon_id = context.value.summon_id) where card_rules = if(doc, doc.rules, '') where doc = get_document('data/cards.cfg')[value.name]),
										
	  if(message.state.winner, set_widgets(me, {
		type: 'dialog',
		background_alpha: 255,
		background_frame: 'empty_window',
		zorder: 1100,
		rect:[-50, -50, 500, 100],
		children: [
			{
				type:'grid', 
				columns:1, 
				xy:[0,20], 
				column_widths:500, 
				column_alignments:'center', 
				children: [
					{
						type: 'label',
						size: 40, 
						zorder: 1100,
						text: '${message.state.winner.name} Wins!', 
						font: 'RobotoCondensed-Bold', 
						color: 'red'
					},

					{
						type: 'button',
						label: {type: 'label', font: font, size: 18, color: font_color, text: 'Leave Game'},
						on_click: bind(me.return_callback, message.state.winner = message.state.players[0]),
					},
				]
			}
		],
	  })),

	  set(tmp.last_state_message, message),

	  update_log(message),


fire_event('update_discard_and_deck')


] where animation_hints =
   if(tmp.animation_hints_id != message.state.animation_hints_id,
	  message.state.animation_hints,
	  message.state.animation_hints[tmp.furthest_animation_hint:])
))
",

on_message_received: "[debug('XX message received: ' + message.state_id),
  switch(message.type,
		 'game_created',
         [set(vars.client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = tbs_client(game_server_address, game_server_port, 1),

         'game',
		 if(message.state.players[message.state.nplayer].deck_submitted = false,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
			if(vars.selected_deck and user_decks, [
				map(user_decks[vars.selected_deck].cards, null asserting get_document('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
				tbs_send(vars.client, {type: 'submit_deck', deck: deck}) asserting deck,
				] where deck = user_decks[vars.selected_deck].cards,
				null asserting vars.selected_deck | 'must specify a deck')
		  ] asserting user_decks
		    where user_decks = get_document('user-decks.cfg',['null_on_failure','user_preferences_dir']),
	
	    [
	    set(vars.state_id, max(vars.state_id, message.state_id)),
		fire_event('update_game', {message: message})
		]
	   ), // end 'game' case.

         //default case.
         [debug('got message: ', message)]),
		 fire_event('request_updates')]",

on_request_updates: "if(vars.client.in_flight = 0,
					      [debug('request_updates: ' + vars.state_id), tbs_send(vars.client, { type: 'request_updates', state_id: vars.state_id })])",
on_connection_error: "[debug('message error', error), fire_event('request_updates')]",

on_process: "
 [
  set(tmp.prev_ctrl_keys, level.player.ctrl_keys),

  if(vars.state and vars.state.nplayer = vars.state.current_player and
     (enter_key in level.player.ctrl_keys) and
	 not (enter_key in tmp.prev_ctrl_keys), [
	 	if(tmp.spell_animation_time < 78,
		   set(tmp.spell_animation_time, 78)),
		set_widgets([]),
		set_status_label(''),
		tbs_send(vars.client, {
		 type: 'moves',
		 state_id: vars.state_id,
		 moves: [end_turn_message]
		})
	  ]
     ) where enter_key = 13,

  if(tmp.response_pause_counter > 0, [
	  add(tmp.response_pause_counter, -1),
	  if(' ' in level.player.ctrl_keys, [
		set(tmp.response_pause_counter, -1),
		if(tmp.timer_bar, remove_object(tmp.timer_bar)),
		set_status_label('Take your time to think about how you want to respond', 'white'),
	  ])
  ]),
  if(tmp.response_pause_counter = 0, [
	set(tmp.response_pause_counter, -1),
	if(tmp.timer_bar, remove_object(tmp.timer_bar)),
	tbs_send(vars.client, {
	 type: 'moves',
	 state_id: vars.state_id,
	 moves: [end_turn_message]
	}),
  ]),
  if(tmp.animated_spell_card,
	 if(tmp.spell_animation_time >= 100, [
			 debug('REMOVE SPELL: ' + if(tmp.animated_spell_card in level.chars, true, false)),
		add(tmp.spells_on_stack, [tmp.animated_spell_card]),
		set(tmp.animated_spell_card, null),
		set(tmp.spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(tmp.spell_animation_time = 80 and (ctrl_mod_key in [1,2]),
	     reserve_animation_time(20),
	 [
	    add(tmp.spell_animation_time, 1),
		if(tmp.spell_animation_time <= 20, [
			set(tmp.animated_spell_card.alpha, new_alpha),
			map(tmp.animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = if(tmp.spell_animation_time <= 20, tmp.spell_animation_time*22, (100 - tmp.spell_animation_time)*22)
			),
	 ]))), //end animated_spell_card

  if(tmp.game_state_queue != [] and level.cycle >= tmp.animation_end_time,
	[
	  set(tmp.game_state_queue, tmp.game_state_queue[1:]),
	  fire_event('update_game', {message: tmp.game_state_queue[0], force_process: true})
	]),
    if(vars.client, tbs_process(vars.client))
 ]",

on_end_anim: "animation('normal')",
zorder: 50,
timer_frequency: 10,
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [
	{
		id: "heart",
		animation: [
			{
				id: "normal",
				image: "tiles.png",
				rect: [5,67,19,79],
				frames: 1,
			}
		],
	},

	{
		id: "card_back",
		animation: [
			{
				id: "normal",
				image: "card-back.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "front",
				image: "card-citadel.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "hand",
				image: "card-hand.png",
				rect: [0,0,145,203],
				scale: 1,
			},

		],

		properties: {

			set_label: "def(text, font) execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'black',
				x: 74,
				y: 80,
			}]))",

			set_text: "def(text_list, font) execute(me, set_widgets(
			  map(text_list, {
			  	type: 'label',
				text: value,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'white',
				x: 74,
				y: 40 + index*26
			  })))",

			set_widgets: "def(widgets) execute(me, set_widgets(widgets))",
		},

		on_mouse_enter: "if(tmp.controller, tmp.controller.mouse_enter_discard(tmp.player_index))",
		on_mouse_leave: "if(tmp.controller, tmp.controller.mouse_leave_discard(tmp.player_index))",
		on_click: "if(tmp.controller, tmp.controller.mouse_click_discard(tmp.player_index))",

		tmp: {
			player_index: 0,
			controller: null,
		}
	},

	{
		id: "status_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			init_label: "def(text, color, card_top) execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				color: color,
				size: 18,
				x: 100,
				y: card_top - 20,
			}]))",

			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		},
	},

	{
		id: "timer_bar",
		hidden_in_game: true,

		tmp: {
			bar: null,
		},

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		on_process: "set(tmp.bar.animation_position, cycle/2.0)",

		properties: {
			create_bar: "def() execute(me, [
				set_widgets([timebar]),
				set(tmp.bar, timebar),
			]
			where timebar = widget(me, {
				type: 'bar',
				id: 'bar',
				left_cap:{area:[0,7,2,7], image:'life.png'}, right_cap:{area:[27,7,3,7], image:'life.png'}, bar:{area:[2,7,2,7], image:'life.png'},
				drained_tick_color: [0,0,0,0],
				bar_color: 'red',
				segments: 1,
				segment_length: 75,
				drained: 1,
				x: 500,
				y: level_height - 196,
			}) 
			)",
			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		}
	},

	{
		id: "turn_schedule",
		hidden_in_game: true,

		tmp: {
			state: null
		},

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			create_label: "def(text) {
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				size: 12,
				color: 'gray',
			}",

			state: {
				get: "tmp.state",
				set: "execute(me, [
					set(tmp.state, value),
					set_widgets([{
						type: 'grid',
						columns: 2,
						children: [
							create_label(''),
							create_label(value.players[value.turn%size(value.players)].name) + {color: 'white'},
							create_label(''),
							create_label('Turn ' + ((value.turn/size(value.players))+1)) + {color: 'white'},
							create_label(if(not value.done_movement, '-> ', '')),
							create_label('Main Phase'),
							create_label(''),
							create_label('Move Phase') + {color: 'dim_gray'},
							create_label(if(value.precombat_phase, '-> ', '')),
							create_label('Combat Phase'),
							create_label(if(value.done_movement and not value.precombat_phase, '-> ', '')),
							create_label('Main Phase'),
						],
					}])
				])"
			}
		}
	}

],
}
