{
id: "citadel_controller",
prototype: ["citadel_controller_base"],
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,

properties: {
	//is a list of card objects when we are showing the discard pile.
	_discard_pile_cards: { type: "[obj card]", default: [] },

	_bdk_controller: { type: "null|obj bdk_controller" },
	_turn_schedule: { type: "null|obj citadel_controller.turn_schedule" },
	_timer_bar: { type: "null|obj citadel_controller.timer_bar" },

	_response_pause_counter: { type: "int", default: -1 },

	_last_state_message: { type: "map", default: {} },

	_status_label: { type: "null|obj citadel_controller.status_label" },

	state: "class game<- _state asserting _state",
	_state: { type: "class game|null" },
	_state_id: { type: "int", default: -1 },
	_processed_state_id: { type: "int", default: -1 },
	_client: { type: "object|null" },

	client: "object<- _client asserting _client",

	_card_preview_for: { type: "any", default: null },
	_card_preview: { type: "obj card|null" },
	card_mouseover: { type: "obj card|null" },

	//location of the tops of our cards
	_card_hand_top: { type: "decimal", default: 0.0 },

	_prev_ctrl_keys: { type: "[string]", default: [] },

	_playing_card: { type: "int", default: 0 },
	_playing_ability: { type: "class util.playing_activated_ability|null" },

	_targets_chosen: { type: "[Loc]", default: [] },

	animation_move_time: { type: "int", default: 0 },
	_animation_end_time: { type: "int", default: -1 },

	_game_state_queue: { type: "[map]", default: [] },
	_furthest_animation_hint: { type: "int", default: 0 },

	_animation_hints_id: { type: "int", default: 0 },

	_animated_spell_card: { type: "null|obj card", default: null },
	_spells_on_stack: { type: "[obj card]", default: [] },

	_spell_animation_time: { type: "int", default: 0 },

	_choice_object: { type: "null|obj choice_controller" },

	_deck_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_discard_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_hand_obj: { type: "[obj citadel_controller.card_back]", default: [] },
	_level_obj: { type: "[obj citadel_controller.card_back]", default: [] },

	_cards_suggest_discard: { type: "[int]|null" },

	font: "string<- 'RobotoCondensed-Regular'",
	color: "string<- 'antique_white'",
	font_color: "string<- 'antique_white'",


	return_callback: { type: "function(bool) ->commands",
	                   default: "@eval def(bool result) ->commands null" },

	game_created: { type: "bool", default: false },
	session_id: { type: "int", default: -1 },
	selected_deck: { type: "string", default: "" },
	game_server_address: { type: "string", default: "@eval TBS_SERVER_ADDRESS" },
	game_server_port: { type: "int", default: "@eval TBS_SERVER_PORT" },

	level_width: "int<- level.dimensions[2]",
	level_height: "int<- level.dimensions[3]",

	card_keeps: "[int]<- [card.hand_index | card <- level.chars, card is obj card, card.in_hand, card.marked_as_keep]",

	card_keep_draw_id: "[int]<- [card.card_type.draw_id | card <- level.chars, card is obj card, card.in_hand, card.marked_as_keep]",

	end_turn_message: "{string -> any}<- {type: 'end_turn', keep: card_keeps}",

	set_status_label: "def(string text, string color='white', int duration=150) ->commands 
	[
		if(_status_label, remove_object(_status_label)),
		spawn('citadel_controller.status_label', 0, 0, 1, [
			set(_status_label, child),
			set(child.zorder, 1200),
			if(duration > 0, execute(child, schedule(duration,
			                                         remove_object(child)))),
			debug('init label: ' + text),
			child.init_label(text, color, int(_card_hand_top)),
		])
	]",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def(class game|null new_state=null) ->commands execute(me, [
		if(me.card_mouseover, mouse_leave_card(me.card_mouseover)),
		[set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		set(_playing_card, -1),
		set(_playing_ability, null),
		set(_targets_chosen, []),
		set(_cards_suggest_discard, null),
		set(me.card_mouseover, null),
	    if(card_mouseover, card_mouseover.hide_keep_button()),
	])",

	//debug function to execute FFL on the server.
	server_exec: "def(string code) ->commands
	execute(me, tbs_send(client, {
		type: 'moves',
		state_id: _state_id,
		moves: [{
			type: 'debug',
			exe: code
		}]
	}))
	",

	debug_draw: "def(int ncards) ->commands server_exec('players[current_player].draw_cards(me, ' + ncards + ')')",
	debug_mana: "def(int nmana) ->commands server_exec('add(players[current_player].resources, ' + nmana + ')')",
	debug_card: "def(string name) ->commands server_exec('add(players[current_player].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",
	debug_card_enemy: "def(string name) ->commands server_exec('add(players[next_player_index].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",

	debug_enemy_hand: "[string]<- map(state.opponent_obj.hand, value.name)",
	
	animation_up_to_date: "bool<- _processed_state_id = _state_id",
	reserve_animation_time: "def(int ncycles) ->commands if(end_time > _animation_end_time, set(me._animation_end_time, end_time)) where end_time = level.cycle + ncycles",
	myplayer: "class player<- _state.players[_state.nplayer] asserting _state",

	hand_index_after_discarding: "def(int nhand) ->int nhand - count(level.chars, value is obj card and value.discarded and value.hand_index < nhand)",

	mark_sent_discards: "commands<-
	[set(card.sent_discard_msg, true) |
	  card <- level.chars, card is obj card, card.discarded = true]
	",

	discard_command: "def([int] additional_indexes=[]) ->[map]
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = additional_indexes + [card.hand_index |
	    card <- level.chars, card is obj card, card.discarded = true,
		                     card.sent_discard_msg = false]
	",

	remove_preview_card: "def(any card) ->commands if(_card_preview and (me._card_preview_for = card or card = null), [if(_card_preview.creature, _card_preview.creature.destroy()), remove_object(_card_preview), set(_card_preview, null)])",

	mouse_enter_card: "def(obj card card) ->commands [
	 if(card.in_hand, card.show_keep_button()),
	 (if(me._playing_card = -1, if(me.card_mouseover = card, null,
	  if(me.card_mouseover != null, [
			mouse_leave_card(me.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.in_hand,
	  if(discards != null and possible_targets != [],
	  [
	 	card.show_halo(),
	    set(me.card_mouseover, card),
	    set(_cards_suggest_discard, discards),

		//synthetic clicks to suggest discarding
	  	[card_right_clicked(card) | card <- level.chars, card is obj card, card.hand_index in discards]
	  ])
	  where discards = (local_player.suggest_discards(local_player.calculate_cost(local_player.hand[card.hand_index]), filter([card.hand_index] + [card.hand_index | card <- level.chars, card is obj card, card.discarded or card.marked_as_keep], value != null))
		  ))
 	  where possible_targets = if(card.card_type is class card, card.card_type.possible_targets(state, state.nplayer, []), [])
	  )))

	asserting (not card.in_hand) or (card.hand_index < size(local_player.hand)) | 
	[size(card.hand_index), card.hand_index, card.card_type.name, [[card.hand_index, card.in_hand, card.card_type.name] | card <- level.chars, card is obj card], [card.name | card <- local_player.hand]]
	  )]
	  where local_player = myplayer",

	mouse_leave_card: "def(obj card card) ->commands [
	  card.hide_keep_button(),
	  if(me.card_mouseover = card and _cards_suggest_discard != null, [
		map(_cards_suggest_discard, if(obj and obj.discarded, card_clicked(obj)) where obj = find(level.chars, value is obj card and value.hand_index = context.value)),
		set(_cards_suggest_discard, null),
		set(me.card_mouseover, null),
	])
	]",

	clear_discard_pile: "def() -> commands execute(me,
		if(_discard_pile_cards, [
			map(_discard_pile_cards, remove_object(value)),
			set(_discard_pile_cards, [])
		])
	)",

	mouse_enter_discard: "def(int nplayer) ->commands execute(me, [
	  clear_discard_pile(),
	  set(_discard_pile_cards, []),
	  map(state.players[nplayer].visible_discard_pile,
	      spawn('card', level_width/2, level_height/2 - (size(state.players[nplayer].visible_discard_pile)-1)*50 + index*50,
		   {
		  	card_type: construct('card', lib.json.get_document_map('data/cards.cfg')[value]),
			controller: me,
			card_size: 2,
			in_hand: false,
			zorder: 4000 + index,
		   },
		   [
			add(_discard_pile_cards, [child]),
		  ]))
	])",

	mouse_click_discard: "def(int nplayer) -> commands execute(me, cycle_discard_pile())",

	cycle_discard_pile: "def(int delta=1) -> commands if(_discard_pile_cards, execute(me, [
		map(_discard_pile_cards, [
			set(value.x, target.x),
			set(value.y, target.y),
			set(value.zorder, target.zorder),
		] where target = _discard_pile_cards[(index + delta)%size(_discard_pile_cards)])
	]))",

	mouse_leave_discard: "def(int nplayer) -> commands execute(me, [
		clear_discard_pile(),
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(obj tile tile) ->commands
	if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
		 set(me._card_preview_for, tile.loc)
	   ]) where card = lib.json.get_document_map('data/cards.cfg')[creature.name])
	      where creature = state.creature_at_loc(tile.loc)",
	mouse_leave_tile: "def(object tile) ->commands remove_preview_card(tile.loc)",

	mouse_enter_log: "def(int index) ->commands
	   if(items = null, if(is_string(me._card_preview_for),
			           remove_preview_card(me._card_preview_for)),
		[
//			 mouse_enter_card({card_type: construct('card',
//			    get_document('data/cards.cfg')[items[1]])}),
			 set(me._card_preview_for, items[1])
	    ])
	    where items = if(index = -1, null,
		   regex_match(state.log[index], '(.*) plays (.*)'))",

	card_clicked: "def(obj card card) ->commands if(state.nplayer = state.current_player,
	  if(card.discarded,
	  [debug('set not discarded'), card.set_discarded(false), add(myplayer.resources, -1)],
	  [tile_clicked(null),

	   //commit to any card discard at this point.
	   set(me.card_mouseover, null),
	   if(me.card_mouseover, me.card_mouseover.hide_keep_button()),
	   set(_cards_suggest_discard, null),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])
	]))",
	card_right_clicked: "def(obj card card) ->commands [
	 if(card.marked_as_keep, card.toggle_keep()),
	 if(state.nplayer = state.current_player,
	 if((not card.discarded) and (not card.card_type.hero), [
	   debug('set card discarded'),
	   tile_clicked(null),
	   add(myplayer.resources, 1),
	   card.set_discarded(true)
	],
	 if(card.card_type.hero, set_status_label('Hero cards may not be discarded for mana', 'red'))
	))
	]",

	option_clicked: "def(null|int|string choice_value) ->commands execute(me, [
	debug('option clicked: ' + choice_value),
	tbs_send(client, {
		type: 'moves',
		state_id: _processed_state_id,
		moves: [{
			type: 'make_choice',
			choice: choice_value,
		}],
	})
	])",
	      
	tile_clicked: "def(obj tile|null tile) ->commands
	[if(not state.current_choice, [
	   execute(me, 	map(level.chars, if(value is obj tile,
	                                    set(value.selectable, false)))),
	   if(tile and me._playing_card != -1 and tile.selectable,
		  choose_targets_for_card(
		   obj card<- //assert we succeed in finding.
		    find(level.chars, value is obj card and
			                  value.hand_index = me._playing_card),
			_targets_chosen + [tile.loc]),
		 
		 if(tile and _playing_ability != null and tile.selectable,
		    choose_targets_for_ability(_playing_ability.creature,
			                           _playing_ability.ability,
									   [tile.loc]),

		//cancel all discards
	   [
		if(tile, [card_clicked(card) |
				  card <- level.chars,
				  card is obj card,
				  card.discarded]),
		if(tile != null, adapt_input_state(null))
	   ]))
	 ])]",
	
	choose_targets_for_ability: "def(class creature creature, class activated_ability ability, [Loc] targets) ->commands execute(me, [
		 tbs_send(client, {
		   type: 'moves',
		   state_id: _processed_state_id,
		   moves: discard_command(if(discards, discards, []) where discards = myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability.name, targets: targets, player_index: state.current_player}]
		  }),
		  mark_sent_discards,
		  [set(tile.selectable, false) | tile <- level.chars, tile is obj tile],
		  set(me._playing_card, -1),
		  set(_targets_chosen, []),
		  set(_playing_ability, construct('util.playing_activated_ability', {creature: creature, ability: ability})),
	]) asserting client",
	
	choose_targets_for_card: "def(obj card card, [Loc] current_targets) ->commands
	execute(me,
	if(card_instance and state.in_response_phase and not card_instance.is_response,
	set_status_label('Can only cast response spells during response phase', 'red'),
	[
	   if(card_instance and card.hand_index != null and state.nplayer = state.current_player,
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [] and not unique_violation,
		      if(possible_targets = null,
				[
				 tbs_send(client, {
				   type: 'moves',
				   state_id: _processed_state_id,
				   moves: discard_command() + [{
					type: 'play_card',
					index: hand_index_after_discarding(card.hand_index),
					player_index: state.current_player,
					targets: current_targets,
				   }]
				  }) asserting _client,
				 mark_sent_discards,
				 set(me._playing_card, -1),
				 set(_playing_ability, null),
				],
			    [
				 map(level.chars, if(value is obj tile, set(value.selectable, value.loc in possible_targets))),
				 set(me._playing_card, card.hand_index),
				 set(_playing_ability, null),
				 set(_targets_chosen, current_targets)
				]),
			  [
			   set_status_label(if(possible_targets = [], 'No valid targets',
			        if(not can_afford, 'Not enough mana: ' + myplayer.resources + ' to play ' + card_instance.name,
						card_instance.name + ' is already on the field, you may not play copies of a hero.')), 'red')
			  ])]
		where unique_violation = card_instance.hero and card_instance.creature and find(state.creatures, value.name = card_instance.name and value.controller = state.nplayer)

		//we should already have suggested discards at this point, so
		//if the card is playable, the player can afford it straight-up
		where can_afford = myplayer.can_afford(card_instance.school, card_instance.cost, card_instance.loyalty_cost)
		where possible_targets = card_instance.possible_targets(state, state.nplayer, current_targets))
	 ])) where card_instance = null|class card <- if(card.card_type is class card, card.card_type, null)",
	
	
	creature_clicked: "def(obj creature creature) ->commands execute(me, [
	    if(creature.creature_object and creature.creature_object.is_on_board,
		  [map(filter(level.chars, value is obj creature_status), value.destroy()),
		   spawn('creature_status', 300, 410, { creature_object: creature.creature_object })]
		  )
	  ])",
	
	can_use_ability: "def(class creature creature, string ability_name) ->bool
	 state.nplayer = state.current_player and
	 state.nplayer = creature.controller and
	 ((not state.in_response_phase) or ability.is_response) and
	 ((not ability.exhausts_creature) or (not creature.is_exhausted)) and
	 myplayer.suggest_discards(myplayer.calculate_cost(ability)) != null and creature.summoned and
	 ability.is_usable(state, creature)
	  asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)",
	 
	
	ability_clicked: "def(class creature creature, string ability_name) ->commands
	execute(me, [
	if(animation_up_to_date and can_use_ability(creature, ability_name),
		//we'll calculate our possible_targets:
		// - null means we play the ability right now
		// - [] means there are no valid targets and the ability can't play
		// - a list of targets means we invite the player to select their
		//   preferred target.
		if(possible_targets = null, 
	    [
		  tbs_send(client, 
		  {
			type: 'moves',
			state_id: state,
		    moves: discard_command(discards asserting discards where discards = myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name, targets: [], player_index: state.current_player}],
		  }) asserting client,
		  mark_sent_discards
		  ],
		 if(possible_targets = [], set_status_label('No available targets for ability', 'red'),
		    [
				[set(tile.selectable, if(tile.loc in possible_targets, true, false)) | tile <- level.chars, tile is obj tile],
				set(me._playing_card, -1),
				set(_targets_chosen, []),
				set(_playing_ability, construct('util.playing_activated_ability', {creature: creature, ability: ability})),
				
			]))
		where possible_targets = ability.possible_targets(state, creature, [])
	) asserting ability
	  
	  where ability = find(creature.activated_abilities, value.name = ability_name)
	  ])",
	
	animate_draw_cards: "def(int ncards) ->commands
	  if(size(cards) >= ncards, map(cards, value.animate_draw(index)))
	  where cards = sort([card | card <- level.chars, card is obj card, card.hand_index != null], a.hand_index > b.hand_index)",
	
	card_on_stack: "def(object card) ->class message.play_card_base|null
	   find(state.stack, value.stack_id = card.stack_id)
	     asserting _state",

	handle_animation_hint: "def(class animation.hint hint) ->commands [
	if(hint is class animation.play_card_hint,
	  ([
		reserve_animation_time(100),
		set(_spell_animation_time, 0),
		spawn('card', xloc, 150 + 40*size(state.stack),
		  {
			 card_type: hint.card,
			 controller: me,
			 in_hand: false,
			 allow_drag: true,
			 stack_id: hint.stack_id,
			 card_size: 2,
			 alpha: 0,
			 zorder: 1000 + hint.stack_id,
		  },
			   [
			    if(_animated_spell_card, [
		   		    add(_spells_on_stack, [_animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(_animated_spell_card, child),
				sound_loop('spells/Spell-windup2.wav', 0.35, 0.5),
				set(child.draw_primitives, filter(map(hint.targets, if(target_tile, {
					type: 'arrow',
					texture: 'ink.png',
					texture_scale: 0.2,
					arrow_head_length: 40,
					arrow_head_width: 0.4,
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value is obj tile and value.loc = context.value)), value != null)),
				])
]
	  where xloc = (level_width - 1024)/2 +
	            if(find(hint.targets, value[1] <= 3),
	              if(find(hint.targets, value[1] >= 7), 512, 712),
	  
	              //none on left
			      if(hint.targets, 312, 512)
		)
	  )
	),
	if(hint.type in ['fizzle', 'resolve'],
	  if(fizzling_card,
		if(hint.type = 'fizzle', fizzling_card.start_fizzle_animation(), fizzling_card.start_resolve_animation()))
		where fizzling_card = find(level.chars, value is obj card and value.stack_id = hint.stack_id)
	)
   ]
",

	set_widgets_for_message: "def(class game game) ->commands
	  if(game.nplayer = game.current_player, 
	    set_widgets(
		
		if((not game.in_response_phase) and
		   (not game.done_movement) and
		   find(game.creatures,
		        value.controller = game.nplayer) != null,
		[
		{
			type: 'button',
			id: 'movement_button',
			x: level_width - 524,
			y: level_height - 618,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: 'Movement',  font: me.font, size: 16, color: me.color},
			on_click: def() execute(me, (if(animation_up_to_date, [set_widgets([]),
			             set(me._playing_card, -1),
						 set(_playing_ability, null),
						 tbs_send(client,
						   {
						     type: 'moves',
							 state_id: me._state_id,
						     moves: discard_command() + [{type: 'movement'}]
						   }
						  ),
						  mark_sent_discards
						 ]))),
		}
		], []) +
	
		[
		{
			type: 'button',
			id: 'end_turn_button',
			x: level_width - 524,
			y: level_height - 568,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: if((not game.in_response_phase), 'End Turn', 'End Response'), font: me.font, size: 16, color: me.color},
			on_click: def() execute(me, if(animation_up_to_date, [set_widgets([]),
			             set(me._playing_card, -1),
						 set(_playing_ability, null),
						 tbs_send(client, {
						  type: 'moves',
						  state_id: me._state_id,
						  moves: [end_turn_message]
						 })
						 ])),
		},
		
		]),
	    set_widgets([{
			type: 'label',
			text: if((not game.in_response_phase), 'Enemy Main Phase', 'Enemy Response Phase'),
			id: 'status_label',
			x: level_width - 524,
			y: level_height - 538,
			font: me.font, 
			size: 16, 
			color: me.color			
	   }]))",
	
	set_schedule_for_message: "def(class game game) ->commands [
		if(_turn_schedule, remove_object(_turn_schedule)),
		spawn('citadel_controller.turn_schedule',
		      level_width - 360, 480, 0, [
			set(child.state, game),
			set(_turn_schedule, child),
		])
	]",

	spawn_tiles: "def(class game game) ->commands
		 if(find(level.chars, value is obj tile) = null, 
		   map(range(game.rows), map(range(game.columns),
		     spawn('tile', 132 + (level_width - 1024)/2 + col*90 + if(row%2 = 1, 45, 0), 104 + row*52, { _controller: me }, [set(child.loc, [row,col]), set(child.game_state, game)]) where col = value) where row = value),
		   [ [set(tile.game_state, game)] | tile <- level.chars, tile is obj tile]
		  )
	",

	spawn_cards_in_hand: "def(class game state, int drawn_cards=0) ->commands
	[
	  map(state.players[state.nplayer].hand,
	     spawn('card', 117 + int(index*card_spacing), int(card_top),
		 {
			facing: 1,
			controller: me,
			in_hand: true,
			hand_index: index,
			zorder: 900+index,
			card_size: card_scale,
			player: state.players[state.nplayer],
			card_type: value,
		 },
		 [
			set(child.y2, level_height - 5),

			//make the new card animate its way in if it's just been drawn.
			if(size(state.players[state.nplayer].hand) - index <= drawn_cards, fire_event(child, 'animate_draw')),

			if(value.draw_id in card_keep_draw_id, child.toggle_keep()),
		  ])),

		set(me._card_hand_top, card_top),
	]
  where card_top = decimal<- level_height - (203*card_scale - 20)
  where card_spacing = decimal<- min(135*card_scale, if(hand_size, card_x_area/hand_size, 100))
  where card_scale = decimal<- min(card_scale_x, card_scale_y)
  where card_scale_x = decimal<- (5.0/max(5.0, hand_size*0.8))*decimal(card_x_area)/decimal(1024 - 300)
  where card_scale_y = decimal<- card_y_area/203.0
  where card_y_area = decimal<- level_height - 560
  where card_x_area = decimal<- level_width - 300
  where hand_size = int<- size(state.players[state.nplayer].hand)
	",

	display_player_life: "def(class game state) ->commands
		map(state.players, map(range(max(value.life, 0)), spawn('citadel_controller.heart', if(context.index = 0, 62 + (level_width - 1024)/2, level_width - (52 + (level_width - 1024)/2)), 34 + index*40, 1)))",
	
	display_choice: "def(class game state) ->commands [
	  if(_choice_object, [_choice_object.destroy(), set(_choice_object, null)]),
	  if(state.current_choice and state.current_choice.player_index = state.nplayer,
	  	spawn('choice_controller', 0, 0,
		{
			facing: facing,
			game: state,
		}, [
			set(_choice_object, child),
			debug('spawned choice'),
		 ]))
    ]",

	update_log: "def(class game game) ->commands
	 log_controller.set_log([string]<- game.log, if(_state, myplayer, null))
	  asserting log_controller
	  where log_controller = find(level.chars, value is obj log_controller)",
	
	bdk: "def(string bot_name) ->commands [
		if(_bdk_controller, remove_object(_bdk_controller)),
		spawn('bdk_controller', 0, 0, { controller: me }, [
			child.load(bot_name),
			set(_bdk_controller, child),
		]),
	]",

	force_submit_deck: "def([string] deck) ->commands
		execute(me, tbs_send(client, {type: 'submit_deck', deck: deck, force: true}))",
},

on_generate_mouseover_card: "mouse_enter_card(obj card<- arg.card)",

on_create: "[ 
	fire_event('window_resize', {width: level.camera_position[2], height: level.camera_position[3]}),
	console_output_to_screen(false), if(size(get_module_args()) > 0, 
	[set(me._client, cl),
	tbs_send(cl, {type: 'start_game'}), debug('game created')] where cl = tbs_client(string<- get_module_args().server_address, string|int<- get_module_args().server_port, int<- get_module_args().session_id),
	if(game_created, 
	[set(me._client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		where cl = tbs_client(game_server_address, game_server_port, session_id),
	set_widgets(
	[{
		type: 'grid',
		columns: 1,
		children: [

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Join Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(me._client, cl),
				             tbs_send(cl, {type: 'request_updates', state_id: _state_id})]
				         where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 2))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Create Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(me._client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Play vs Bot', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(me._client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', bot: true, bot_type: 'evolutionary', args: {rules: 'evo/evolution12.cfg'}, session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

		]
	},
	])))]
",

on_update_discard_and_deck: "[
	map(_deck_obj, value.set_label(str(size(state.players[index].deck)), me.font)),
	map(_discard_obj, value.set_label(str(size(state.players[index].visible_discard_pile)) + '/' + size(state.players[index].discard_pile), me.font)),
	map(_hand_obj, value.set_text(['Cards', str(size(state.players[index].hand)), 'Mana', str(state.players[index].resources)], me.font)),
	map(_level_obj, value.set_widgets([{
		type: 'grid',
		x: 40,
		columns: 2,
		children: fold(map(filter(state.players[index].resource_level, value > 0), [
			{
				type: 'image',
				image: 'magic-icons.png',
				area: [3+17*(key-1), 3, 18+17*(key-1), 18],
			},

			{
				type: 'label',
				text: 'Lvl ' + str(value),
				font: 'RobotoCondensed-Bold', 
				color: 'white',
				size: 12,
			},

			{
				type: 'label',
				text: str(state.players[context.index].xp_level[key]) + '/' + str(state.players[context.index].xp_needed[key]),
				font: 'RobotoCondensed-Bold',
				color: 'white',
				size: 12,
			},

			{
				type: 'label',
				text: 'XP',
				font: 'RobotoCondensed-Bold',
				color: 'white',
				align_h: 'right',
				size: 12,
			},

		]), a+b)
	}])),
]",

on_window_resize: "[
	[ [add(card_back.x, delta_w)]
	| card_back <- level.chars,
	  card_back is obj citadel_controller.card_back,
	  card_back.player_index = 1],

	[ card.destroy() | card <- level.chars, card is obj card, card.in_hand],
	
	[ tile.destroy() | tile <- level.chars, tile is obj tile ],

    [remove_object(heart) | heart <- level.chars, heart is obj citadel_controller.heart],
	
	set(level.dimensions, [0,0,new_width,new_height]),
	fire_event('dimensions_updated')
] where delta_w = new_width - level_width
  where delta_h = new_height - level_height
  where card_width = min(135*card_scale, if(hand_size, card_area/hand_size, 100))
  where card_scale = max(1.0, decimal(card_area)/decimal(1024 - 300))
  where card_area = new_width - 300
  where new_width = max(level_width,1024)-1
  where new_height = max(level_height,768)-1
  where hand_size = count(level.chars, value is obj card and value.in_hand)",

on_dimensions_updated: "[
	if(_last_state_message, [
        display_choice(state),
		set_widgets_for_message(state),
		set_schedule_for_message(state),
		spawn_tiles(state),
		adapt_input_state(state),
		display_player_life(state),
		update_log(state),
		spawn_cards_in_hand(state)
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0,
	       { facing: 1, creature_object: creature.creature_object })
	          asserting creature.creature_object]
	| creature <- level.chars,
	  creature is obj creature,
	  creature.creature_object.is_on_board ]
]",

on_update_spells_on_stack: "
 [
  set(_spells_on_stack, survivors),
  map(leaving, execute(value, [
  	set(value.do_not_remove, true),
	stop_sound('spells/Spell-windup2.wav', 0.5),
	[schedule(n, [
	  map(value.draw_primitives, set(value.color, [255,0,0,255-n*10]))])
	  | n <- range(25)],
	schedule(26, remove_object(value)),
  ]))
 ]
  where leaving = filter(_spells_on_stack, not card_on_stack(value))
  where survivors = filter(_spells_on_stack, card_on_stack(value))",

on_update_game: "
   if((not force_process) and
      (_game_state_queue != [] or level.cycle < _animation_end_time),
	 add(_game_state_queue, [message]),

     if(state_id > _processed_state_id,
	 [
	 	adapt_input_state(game_state),

		debug('ZZ: update_game: ' + game_state.nturn + '/' + (int<- message.nplayer) + ' / ' + game_state.current_player_index),

		if(not _deck_obj, [
			set(_deck_obj, deck_obj),
			set(_discard_obj, discard_obj),
			map(discard_obj, set(value.controller, me)),
			set(_hand_obj, hand_obj),
			set(_level_obj, level_obj),
			map(discard_obj, set(value.player_index, index)),
			map(deck_obj, set(value.player_index, index)),
			map(hand_obj, set(value.player_index, index)),
			map(level_obj, set(value.player_index, index)),
			map(discard_obj, set(value.animation, 'front')),
			map(hand_obj, set(value.animation, 'hand')),
			map(level_obj, set(value.animation, 'hand')),
			map(deck_obj, set(value.scale, 0.5)),
			map(discard_obj, set(value.scale, 0.5)),
			map(hand_obj, set(value.scale, 0.5)),
			map(level_obj, set(value.scale, 0.5)),
			map(deck_obj, add_object(value)),
			map(discard_obj, add_object(value)),
			map(hand_obj, add_object(value)),
			map(level_obj, add_object(value)),
		] where deck_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 450, 1, {controller: me} ))
		  where discard_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 150, level_width - 150), 450, 1, {controller: me} ))
		  where hand_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 250, level_width - 250), 450, 1, {controller: me} ))
		  where level_obj = map(range(size(game_state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 250, 1, {controller: me} ))),

	 	reserve_animation_time(10),
	    set(me._processed_state_id, state_id),
		map(animation_hints, handle_animation_hint(value)),
		set(_animation_hints_id, game_state.animation_hints_id),
		set(_furthest_animation_hint, size(game_state.animation_hints)),
	    set(_state, game_state),
		debug('SET NEW STATE'),

	    debug('got state_id: ' + state_id + '/' + _state_id + ' response phase: ' + if(_state, _state.in_response_phase)),
	    [remove_object(heart) | heart <- level.chars, heart is obj citadel_controller.heart],

		display_player_life(game_state),
		display_choice(game_state),
	    if(creature_status,
			if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
			   where creature = find(game_state.permanents,
			        value.summon_id = creature_status.creature_object.summon_id)
				
				) where creature_status = find(level.chars, value is obj creature_status),
	    [
		
		[tile_label.destroy() | tile_label <- level.chars,
		 tile_label is obj tile.level_label],

		[card.destroy() | card <- level.chars,
		 card is obj card,
		 not card.do_not_remove,
		 card != _animated_spell_card,
		 not (card in _spells_on_stack)],

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(game_state)
	  ],

	  if(game_state.in_response_phase and game_state.nplayer = game_state.current_player,
		[
		  spawn('citadel_controller.timer_bar', 0, 0, 1, [
		  	child.create_bar(),
			set(_timer_bar, child),
		  ]),

		  if(_timer_bar, remove_object(_timer_bar)),

	      set(_response_pause_counter, 150),
		  set_status_label(if(game_state.stack, '', 'Combat phase -- ') + 'Press SPACE if you want to respond', 'white', 150),
		],

		[
			if(_timer_bar, remove_object(_timer_bar)),
			set(_response_pause_counter, -1),
		]
	  ),

	  set_widgets_for_message(game_state),
	  set_schedule_for_message(game_state),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(game_state.creatures,
		                     value.summon_id = creature.summon_id) or
							 game_state.graveyard[creature.summon_id]
	    where creature = obj.creature_object
		| obj <- level.chars, obj is obj creature],
		value), 30, 0)), 

	  map(filter(level.chars, value is obj creature and
	          find(game_state.permanents,
			       context.value.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = game_state.graveyard[value.creature_object.summon_id]), 
	  [
		spawn_cards_in_hand(game_state, drawn_cards),
		if(drawn_cards > 0, reserve_animation_time(30 + 10*size(game_state.players[game_state.nplayer].hand)))
	  ]
		  where drawn_cards =
		    fold([hint.ncards | hint <- animation_hints,
		                        hint is class animation.draw_cards_hint,
							    hint.player = game_state.nplayer], a+b, 0),
	  
	  map(game_state.permanents,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     [set(obj.creature_object, value),
			 if(card_rules, set(value.rules, card_rules))],
	      
		  //create a new object to represent this creature.
		  [debug('SPAWN CREATURE: ' + value.name),
	      spawn('creature', 0, 0, {
				  facing: 1,
				  creature_object: value
				},
				[if(card_rules, set(value.rules, card_rules))] asserting value)])
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value is obj creature and
		                                value.creature_object.summon_id = context.value.summon_id) where card_rules = if(doc and doc.rules, string<- doc.rules, '')
										where doc = map|null<- lib.json.get_document_map('data/cards.cfg')[value.name]),
										
	  if(game_state.winner, set_widgets(me, {
		type: 'dialog',
		background_alpha: 255,
		background_frame: 'empty_window',
		zorder: 1100,
		rect:[-50, -50, 500, 100],
		children: [
			{
				type:'grid', 
				columns:1, 
				xy:[0,20], 
				column_widths:500, 
				column_alignments:'center', 
				children: [
					{
						type: 'label',
						size: 40, 
						zorder: 1100,
						text: '${game_state.winner.name} Wins!', 
						font: 'RobotoCondensed-Bold', 
						color: 'red'
					},

					{
						type: 'button',
						label: {type: 'label', font: font, size: 18, color: font_color, text: 'Leave Game'},
						on_click: bind(me.return_callback, game_state.winner = game_state.players[0]),
					},
				]
			}
		],
	  })),

	  set(_last_state_message, message),

	  update_log(game_state),


fire_event('update_discard_and_deck')


] where animation_hints =
   if(_animation_hints_id != game_state.animation_hints_id,
	  game_state.animation_hints,
	  game_state.animation_hints[_furthest_animation_hint:])
  where game_state = class game<- message.state
))
  where state_id = int<- message.state_id
  where message = map<- arg.message,
         force_process = null|bool<- arg.force_process
",

on_message_received: "[
  trigger_garbage_collection(),
  switch(message.type,
		 'game_created',
         [set(me._client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = tbs_client(game_server_address, game_server_port, 1),

         'game',
		 if(game_state.players[game_state.nplayer].deck_submitted = false,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
			if(selected_deck and user_decks, [
				map(user_decks[selected_deck].cards, null asserting lib.json.get_document_map('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
				tbs_send(me.client, {type: 'submit_deck', deck: deck}) asserting deck,
				] where deck = user_decks[selected_deck].cards,
				null asserting selected_deck | 'must specify a deck')
		  ]
		    where user_decks = DeckMap<- get_document('user-decks.cfg',['null_on_failure','user_preferences_dir']),
	
	    [
	    set(me._state_id, max(_state_id, int<- message.state_id)),
		fire_event('update_game', {message: message})
		]
	   ), // end 'game' case.

         //default case.
         [debug('got message: ', message)]),
		 fire_event('request_updates')]
	 where game_state = class game<- message.state
	 where message = map<- arg.message",

on_request_updates: "if(client.in_flight = 0,
					      [debug('request_updates: ' + _state_id), tbs_send(client, { type: 'request_updates', state_id: _state_id })])",
on_connection_error: "[debug('message error', string<- arg.error), fire_event('request_updates')]",

on_process: "
 [
  set(me._prev_ctrl_keys, [string]<- level.player_info.ctrl_keys),

  if(_state and _state.nplayer = _state.current_player and
     (enter_key in ([string]<- level.player_info.ctrl_keys)) and
	 not (enter_key in _prev_ctrl_keys), [
	 	if(_spell_animation_time < 78,
		   set(_spell_animation_time, 78)),
		set_widgets([]),
		set_status_label(''),
		tbs_send(client, {
		 type: 'moves',
		 state_id: _state_id,
		 moves: [end_turn_message]
		})
	  ]
     ) where enter_key = 13,

  if(_response_pause_counter > 0, [
	  add(_response_pause_counter, -1),
	  if(' ' in ([string]<- level.player_info.ctrl_keys), [
		set(_response_pause_counter, -1),
		if(_timer_bar, remove_object(_timer_bar)),
		set_status_label('Take your time to think about how you want to respond', 'white'),
	  ])
  ]),
  if(_response_pause_counter = 0, [
	set(_response_pause_counter, -1),
	if(_timer_bar, remove_object(_timer_bar)),
	tbs_send(client, {
	 type: 'moves',
	 state_id: _state_id,
	 moves: [end_turn_message]
	}),
  ]),
  if(_animated_spell_card,
	 if(_spell_animation_time >= 100, [
			 debug('REMOVE SPELL: ' + if(_animated_spell_card in level.chars, true, false)),
		add(_spells_on_stack, [_animated_spell_card]),
		set(_animated_spell_card, null),
		set(_spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(_spell_animation_time = 80 and (level.player_info.ctrl_mod_key in [1,2]),
	     reserve_animation_time(20),
	 [
	    add(_spell_animation_time, 1),
		if(_spell_animation_time <= 20, [
			set(_animated_spell_card.alpha, new_alpha),
			map(_animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = if(_spell_animation_time <= 20, _spell_animation_time*22, (100 - _spell_animation_time)*22)
			),
	 ]))), //end animated_spell_card

  if(_game_state_queue != [] and level.cycle >= _animation_end_time,
	[
	  set(_game_state_queue, _game_state_queue[1:]),
	  fire_event('update_game', {message: _game_state_queue[0], force_process: true})
	]),
    if(client, tbs_process(client))
 ]",

on_end_anim: "animation('normal')",
zorder: 50,
timer_frequency: 10,
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [
	{
		id: "heart",
		animation: [
			{
				id: "normal",
				image: "tiles.png",
				rect: [5,67,19,79],
				frames: 1,
			}
		],
	},

	{
		id: "card_back",
		animation: [
			{
				id: "normal",
				image: "card-back.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "front",
				image: "card-citadel.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "hand",
				image: "card-hand.png",
				rect: [0,0,145,203],
				scale: 1,
			},

		],

		properties: {

			set_label: "def(string text, string font) ->commands execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'black',
				x: 74,
				y: 80,
			}]))",

			set_text: "def([string] text_list, string font) ->commands execute(me, set_widgets(
			  map(text_list, {
			  	type: 'label',
				text: value,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'white',
				x: 74,
				y: 40 + index*26
			  })))",

			set_widgets: "def([map] widgets) ->commands execute(me, set_widgets(widgets))",

			player_index: 0,
			controller: { type: "obj citadel_controller" },
		},

		on_mouse_enter: "if(controller, controller.mouse_enter_discard(player_index))",
		on_mouse_leave: "if(controller, controller.mouse_leave_discard(player_index))",
		on_click: "if(controller, controller.mouse_click_discard(player_index))",
	},

	{
		id: "status_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			init_label: "def(string text, Color color, int card_top) ->commands
			execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				color: color,
				size: 18,
				x: 100,
				y: card_top - 20,
			}]))",

			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		},
	},

	{
		id: "timer_bar",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		on_process: "set(bar.animation_position, cycle/2.0)",

		properties: {
			bar: { type: "bar_widget", dynamic_initialization: true },

			create_bar: "def() ->commands [
				set_widgets([timebar]),
				set(bar, timebar),
			]
			where timebar = bar_widget<- widget(me, {
				type: 'bar',
				id: 'bar',
				left_cap:{area:[0,7,2,7], image:'life.png'}, right_cap:{area:[27,7,3,7], image:'life.png'}, bar:{area:[2,7,2,7], image:'life.png'},
				drained_tick_color: [0,0,0,0],
				bar_color: 'red',
				segments: 1,
				segment_length: 75,
				drained: 1,
				x: 500,
				y: level_height - 196,
			})",
			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		}
	},

	{
		id: "turn_schedule",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			create_label: "def(string text) ->map {
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				size: 12,
				color: 'gray',
			}",

			state: {
				type: "null|class game",
				set_type: "class game",
				set: "execute(me, [
					set(_data, value),
					set_widgets([{
						type: 'grid',
						columns: 2,
						children: [
							create_label(''),
							create_label(value.players[value.turn%size(value.players)].name) + {color: 'white'},
							create_label(''),
							create_label('Turn ' + ((value.turn/size(value.players))+1)) + {color: 'white'},
							create_label(if(not value.done_movement, '-> ', '')),
							create_label('Main Phase'),
							create_label(''),
							create_label('Move Phase') + {color: 'dim_gray'},
							create_label(if(value.precombat_phase, '-> ', '')),
							create_label('Combat Phase'),
							create_label(if(value.done_movement and not value.precombat_phase, '-> ', '')),
							create_label('Main Phase'),
						],
					}])
				])"
			}
		}
	}

],
}
