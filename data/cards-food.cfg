{
	"Call of the Pack": {
		name: "Call of the Pack",
		type: "spell",
		cost: 5,
		loyalty_cost: 5,
		school: FOOD,
		rules: "Summon three Pack Wolfs.",
		possible_targets: "
		def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		   if(size(targets) = 3, null,
		      filter(game.players[nplayer].summoning_locs(game, construct('creature', {name: 'Wolf', school: FOOD, image_num: 5})),
			         not (value in targets)))",
		on_play: "def(class game game, class message.play_card info) ->commands
		  map(info.targets, game.summon_creature(
		   lib.citadel.create_creature('Pack Wolf', {
			name: 'Pack Wolf',
			controller: game.current_player,
			loc: value,
		})))"
	},

	"Nature's Blessing": {
		name: "Nature's Blessing",
		type: "spell",
		cost: 0,
		loyalty_cost: 3,
		school: FOOD,
		rules: "You gain &+;&2;&mana;.",
		on_play: "def(class game game, class message.play_card info) ->commands add(game.players[game.current_player].resources, 2)",
		ai_patterns: "def(class game game, [[int]] targets) ->[string|null]
		[
			'cost ' + game.player_obj.calculate_cost(me)
		]"
	},

	"Primal Rage": {
		name: "Primal Rage",
		type: "spell",
		cost: 1,
		loyalty_cost: 2,
		school: FOOD,
		is_response: true,
		rules: "Target creature gains &+;&2;&attack; and &+;&2;&life; this turn.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands [
		   target.apply_effect_until_end_of_turn('attack', 2),
		   target.apply_effect_until_end_of_turn('life', 2)
		 ] where target = game.creature_at_loc_or_die(info.targets[0])"
	},

	"Outsmart the Guards": {
		name: "Outsmart the Guards",
		type: "spell",
		cost: 1,
		loyalty_cost: 1,
		school: FOOD,
		is_response: true,
		rules: "Swap the positions of two target adjacent non-building creatures in the same lane.",
		possible_targets: "
		def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(size(targets) = 0,
		    [creature.loc | creature <- game.creatures,
			                not creature.is_building,
							creature.is_valid_target(game, nplayer, me)],
			if(size(targets) = 1,
		     [creature.loc | creature <- game.creatures,
			                 not creature.is_building,
							 creature.is_valid_target(game, nplayer, me),
							 creature.loc[0] = targets[0][0],
							 abs(creature.loc[1] - targets[0][1]) = 1],
			 null))",
		on_play: "def(class game game, class message.play_card info) ->commands [
			set(target_a.loc, target_b.loc),
			set(target_b.loc, target_a.loc),
		] where target_a = game.creature_at_loc_or_die(info.targets[0]),
		        target_b = game.creature_at_loc_or_die(info.targets[1])",

		ai_patterns: "def(class game game, [[int]] targets) ->[string|null]
			if(target_a and target_a.controller = game.current_player_index and target_b and (size(targets) < 2 or targets[1] = target_b.loc) and target_b.controller != game.current_player_index,
			['move past enemy creature',
			 target_a.name + ' sneaks past ' + target_b.name,
			 ' var ' + target_a.tiles_from_start + ' tiles',
			 if(target_a.loc in lib.ai.current_spell_targets(game), 'your creature targeted'),
			 if(target_b.loc in lib.ai.current_spell_targets(game), 'their creature targeted'),
		debug_fn('outsmart: ' + str(targets), null)
			 ], [])
		
		  where target_b = game.creature_at_loc([target_a.loc[0], target_a.loc[1] + target_a.direction_moving])
		  where target_a = game.creature_at_loc_or_die(targets[0])
		 ",

		ai_flags: [AI_CARD_SAVES]
	},

	"Goblin King": {
		name: "Goblin King",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: FOOD,
		rules: "When Goblin King is summoned, summon a Goblin in each adjacent lane.\n'Goblin' creatures you control adjacent to Goblin King get &+;&1;&attack; and &+;&1;&life;.",
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder'],
			image_num: 15,
			on_summoned: "def(class game game) ->commands
			  map([[loc[0]-1,loc[1]], [loc[0]+1,loc[1]]],
			               if(game.is_loc_on_board(value) and
						      game.creature_at_loc(value) = null,
							  game.summon_creature(lib.citadel.create_creature('Goblin',
							    {
									name: 'Goblin',
									controller: game.current_player,
									loc: value,
								})
							  
							  )))",
			static_ability_effect: "if(creature != target and creature.controller = target.controller and game.locs_adjacent(creature.loc, target.loc) and ('Goblin' in target.tags),
			   [target.apply_static_effect('life', 1),
			    target.apply_static_effect('attack', 1)])",
			attack: 2,
			life: 3,
			move: 2,
			
		}
	},

	"Wolf Rider": {
		name: "Wolf Rider",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: FOOD,
		creature: {
			tags: ['Mounted', 'Goblin'],
			abilities: ['Marauder', 'Haste'],
			attack: 2,
			life: 2,
			move: 3,
			image_num: 50
		}
	},

	"If-Uluk, the Swift": {
		name: "If-Uluk, the Swift",
		type: "creature",
		cost: 3,
		loyalty_cost: 5,
		school: FOOD,
		hero: true,
		creature: {
			tags: ['Mounted', 'Goblin'],
			abilities: ['Marauder', 'Haste', 'Cover'],
			attack: 5,
			life: 3,
			move: 3,
			image_num: 50,
			overlays: [{image_num: 8}],
		}
	},

	"Goblin Grenadier": {
		name: "Goblin Grenadier",
		type: "creature",
		cost: 3,
		loyalty_cost: 1,
		school: FOOD,
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder'],
			activated_abilities: [{
				name: 'Detonate',
				cost: 0,
				loyalty_cost: 1,
				school: FOOD,
				rules: "Goblin Grenadier dies, each adjacent creature and construct gets 2 wounds.",
				is_response: true,
				on_play: "
				def(class game game, class creature creature, class message.play_ability info) ->commands
				[
					set(creature.destroyed, true),
					set(creature.death_animation_hint, 'explosion'),
					[ target.inflict_combat_damage(game, creature, 2)
					  | target <- game.creatures,
					    game.locs_adjacent(creature.loc, target.loc) ]
				]
				",
			}],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 30,
			image_num: 40,
			overlays: [{image_num: 2}],
		}
	},

	"Goblin Marauder": {
		name: "Goblin Marauder",
		type: "creature",
		cost: 0,
		loyalty_cost: 2,
		school: FOOD,
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder', 'Haste'],
			attack: 2,
			life: 1,
			move: 2,
			initiative: 30,
			image_num: 40,
		}
	},

	"Goblin": {
		name: "Goblin",
		type: "creature",
		cost: 10,
		token: true,
		loyalty_cost: 1,
		school: FOOD,
		creature: {
			tags: ['Goblin'],
			attack: 1,
			life: 1,
			move: 2,
			initiative: 30,
			image_num: 40,
		}
	},

	"Goblin Sapper": {
		name: "Goblin Sapper",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: FOOD,
		rules: "Goblin Sapper has &+;&2;&resist; against &range; attacks and &+;&3;&attack; attack against creatures with Fortification.",
		creature: {
			tags: ['Goblin'],
			abilities: ['Marauder'],
			attack: 1,
			life: 1,
			move: 3,
			initiative: 30,
			image_num: 40,
			overlays: [{image_num: 4}],
			static_ability_effect: "if(creature.controller != target.controller and game.locs_adjacent(creature.loc, target.loc) and target.fortification, 
				creature.apply_static_effect('attack', 3)
			)",
			resistance_against: "
			 def(class game game, class creature attacker, int damage) ->int
			   me.resistance + if(attacker.range > 1, 2, 0)",
		}
	},
	
	"Wolf": {
		name: "Wolf",
		type: "creature",
		cost: 2,
		loyalty_cost: 1,
		school: FOOD,
		creature: {
			tags: ['Wolf'],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 20,
			image_num: 5,
		}
	},

        "Pack Wolf": {
                name: "Pack Wolf",
                type: "creature",
                cost: 1,
                loyalty_cost: 3,
                school: FOOD,
                rules: "Pack Wolf has &+;&1;&attack; for each other 'Wolf' creature you control.",
                creature: {
                        tags: ['Wolf'],
                        attack: 1,
                        life: 1,
                        move: 2,
                        initiative: 20,
                        image_num: 5,
                        static_ability_effect: "if(creature = target,creature.apply_static_effect('attack', bonus) where bonus = count(game.creatures, value.controller = creature.controller and value != creature and ('Wolf' in value.tags)))"
                }
        },

	"Cave Troll": {
		name: "Cave Troll",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: FOOD,
		creature: {
			tags: ['Troll'],
			abilities: ['Regeneration'],
			attack: 4,
			life: 4,
			move: 2,
			image_num: 11,
		},
	},
	
	"Rampaging Troll": {
		name: "Rampaging Troll",
		type: "creature",
		cost: 5,
		loyalty_cost: 4,
		school: FOOD,
		rules: "At the start of your turn, remove all wounds from Rampaging Troll.",
		creature: {
			tags: ['Troll'],
			abilities: ['Marauder', 'Haste'],
			attack: 3,
			life: 3,
			move: 2,
			initiative: 30,
			image_num: 11,
			overlays: [{image_num: 27}],
			on_begin_turn: "def(class game game) ->commands
			  if(game.current_player = controller, set(me.wounds, 0))",
		},
	},

	"Lumbering Ogre": {
		name: "Lumbering Ogre",
		type: "creature",
		cost: 6,
		loyalty_cost: 4,
		school: FOOD,
		rules: "At start of each turn, if an enemy is immediately in front of Lumbering Ogre, Lumbering Ogre gains &+;&5;&attack; this turn.",
		creature: {
			tags: ['Ogre'],
			attack: 0,
			life: 8,
			move: 2,
			image_num: 17,
			on_begin_turn: "def(class game game) ->commands
			  if(is_engaged(game), me.apply_effect_until_end_of_turn('attack', 5))",
		}
	},

	"Green Adder": {
		name: "Green Adder",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: FOOD,
		creature: {
			tags: ['Serpent'],
			attack: 3,
			life: 1,
			move: 2,
			image_num: 64
		}
	},

	"Flash Adder": {
		name: "Flash Adder",
		type: "creature",
		is_response: true,
		cost: 0,
		loyalty_cost: 3,
		school: FOOD,
		rules: "At the end of your turn, sacrifice Flash Adder.",
		//flavor: "It strikes its prey faster than one would believe, and then slinks back to its burrow.",
		creature: {
			tags: ['Serpent'],
			abilities: ['Haste'],
			attack: 3,
			life: 1,
			move: 1,
			image_num: 65,
			on_end_turn: "def(class game game) ->commands
				if(game.current_player_index = controller, set(me.destroyed, true))"
		}
	},

	"Wose": {
		name: "Wose",
		type: "creature",
		cost: 5,
		loyalty_cost: 3,
		school: FOOD,
		rules: "At start of your turn, if Wose is in forest, remove all wounds from it. Otherwise, add one wound to it.",
		creature: {
			tags: ['Wose'],
			attack: 8,
			life: 8,
			move: 1,
			image_num: 59,
			on_begin_turn: "def(class game game) ->commands
			 if(game.current_player = controller,
			      if(construct and construct.name = 'Forest',
				     set(me.wounds, 0),
					 add(me.wounds, 1))) where construct = game.construct_at_loc(loc)"
		}
	},

	"Cavern Wurm": {
		name: "Cavern Wurm",
		type: "creature",
		cost: 4,
		loyalty_cost: 3,
		school: FOOD,
		creature: {
			tags: ['Wurm'],
			attack: 5,
			life: 3,
			move: 2,
			image_num: 65
		}
	},

	"Hydra": {
		name: "Hydra",
		type: "creature",
		cost: 6,
		loyalty_cost: 3,
		school: FOOD,
		creature: {
			tags: ['Serpent'],
			attack: 4,
			life: 4,
			move: 2,
			activated_abilities: [
				{
					name: "Regrow",
					cost: 1,
					school: FOOD,
					rules: "Remove one wound from this creature, it then gets &+;&1;&attack; and &+;&1;&life;.",

					is_usable: "def(class game game, class creature creature) ->bool creature.wounds > 0",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
					  add(creature.wounds, -1),
					  add(creature.attack, 1),
					  add(creature.life, 1)
					]",
				}
			],
			image_num: 63
		}
	},

	"Minotaur": {
		name: "Minotaur",
		type: "creature",
		cost: 4,
		loyalty_cost: 3,
		school: 1,
		creature: {
			tags: ['Creature'],
			abilities: ['Trample'],
			attack: 3,
			life: 4,
			move: 3,
			initiative: 30,
			image_num: 30,
		}
	},
	
	"Grove of Sanctity": {
		name: "Grove of Sanctity",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: FOOD,
		rules: "Creatures you control in this lane have Regeneration.",
		creature: {
			tags: ["Grove"],
			life: 3,
			is_construct: true,
			image_num: 2,
			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0] and not target.is_building, target.add_ability_static_duration('Regeneration'))"
		}
	},
	
	"Grove of Vigor": {
		name: "Grove of Vigor",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: FOOD,
		rules: "Creatures you control in this lane have &+;&1;&move; and Haste.",
		creature: {
			tags: ["Grove"],
			life: 3,
			is_construct: true,
			image_num: 2,
			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0] and not target.is_building, [target.add_ability_static_duration('Haste'), target.apply_static_effect('move', 1)])"
		}
	},

	"Grove of the Restless": {
		name: "Grove of the Restless",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: FOOD,
		rules: "Creatures you control in this lane have &+;&1;&attack;.",
		creature: {
			tags: ["Grove"],
			life: 3,
			is_construct: true,
			image_num: 2,
			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0] and not target.is_building, target.apply_static_effect('attack', 1))"
		}
	},
	
	"Trample": {
		name: "Trample",
		type: "spell",
		cost: 1,
		loyalty_cost: 1,
		school: FOOD,
		rules: "Target creature gains Trample.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		  add(creature.abilities, ['Trample'])
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc_or_die(info.targets[0])",

		ai_patterns: "def(class game game, [[int]] targets) ->[string|null]
		[
			'' + creature.tiles_from_start + ' tiles from start',
			if(opposing_creature, creature.name + ' vs ' + opposing_creature.name, 'unopposed'),
			if(opposing_creature, creature.name + ' distance ' + abs(creature.loc[1] - opposing_creature.loc[1])),
			if(opposing_creature and creature.attack >= opposing_creature.life - opposing_creature.wounds, 'enough attack to kill'),
			if(opposing_creature and creature.life - creature.wounds > opposing_creature.attack, 'enough life to survive'),

		] where opposing_creature = lib.ai.next_opposing_creature(game, creature)
		  where creature = game.creature_at_loc_or_die(targets[0])",

	},
	
	"Cover": {
		name: "Cover",
		type: "spell",
		is_response: true,
		cost: 2,
		loyalty_cost: 1,
		school: FOOD,
		rules: "Target creature gains Cover.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		  add(creature.abilities, ['Cover'])
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc_or_die(info.targets[0])",
		ai_patterns: "def(class game game, [[int]] targets) ->[string|null]
		[
		]
		",
	},
	
	"Quick Step": {
		name: "Quick Step",
		type: "spell",
		cost: 2,
		loyalty_cost: 1,
		school: FOOD,
		rules: "Target creature gains &+;&1;&move;.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		  add(creature.move, 1)
					asserting size(info.targets) = 1
					where creature = game.creature_at_loc_or_die(info.targets[0])",
	},
	
	"Hill Giant": {
		name: "Hill Giant",
		type: "creature",
		cost: 8,
		loyalty_cost: 3,
		school: FOOD,
		creature: {
			tags: ['Giant'],
			abilities: ['Trample', 'Haste'],
			attack: 8,
			life: 8,
			move: 2,
			initiative: 30,
			image_num: 61,
		},		
	},
	
	"Hurl": {
		name: "Hurl",
		type: "spell",
		cost: 2,
		school: FOOD,
		loyalty_cost: 2,
		is_response: true,
		rules: "Sacrifice a goblin, add 4 wounds to target creature in the same lane.",
		possible_targets: "
		  def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(size(targets) = 0,
		    [creature.loc | creature <- game.creatures,
			                not creature.is_building,
							'Goblin' in creature.tags,
							creature.is_valid_target(game, nplayer, me)],
			if(size(targets) = 1, [creature.loc | creature <- game.creatures, not creature.is_building, creature.loc[0] = targets[0][0], creature.is_valid_target(game, nplayer, me)],
			 null))",
		on_play: "def(class game game, class message.play_card info) ->commands [
			set(goblin.destroyed, true),
			add(target.wounds, 4)
		]
			where goblin = game.creature_at_loc_or_die(info.targets[0]),
			      target = game.creature_at_loc_or_die(info.targets[1])",
	},

	"Strip the Carcass": {
		name: "Strip the Carcass",
		type: "spell",
		school: FOOD,
		cost: 0,
		loyalty_cost: 2,
		is_response: true,
		rules: "When target creature dies this turn, its owner gains &mana; equal to the creature's &life;.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		  co.add_triggered_ability_until_end_of_turn({
			name: 'Strip the Carcass',
			rules: 'If creature dies this turn, owner gains resources equal to the creatures life',
			duration_hint: 'end of turn',
			on_die: 'def(class creature creature, class game game) ->commands
			  add(game.players[creature.controller].resources, creature.life)'})
			asserting size(info.targets) = 1
			where co = game.creature_at_loc_or_die(info.targets[0])",
	},

	"Furious Rampage": {
		name: "Furious Rampage",
		type: "spell",
		cost: 1,
		loyalty_cost: 1,
		school: FOOD,
		is_response: true,
		rules: "Target creature gains &+;&2;&attack;, &+;&2;&life;, &+;&2;&move;, and Trample this turn.",
		possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(size(targets) > 0, null,
		   [creature.loc | creature <- game.creatures, not creature.is_building,
			       creature.is_valid_target(game, nplayer, me)])",
		on_play: "def(class game game, class message.play_card info) ->commands [
		   target.apply_effect_until_end_of_turn('attack', 2),
		   target.apply_effect_until_end_of_turn('life', 2),
		   target.apply_effect_until_end_of_turn('move', 2),
		   target.add_ability_until_end_of_turn('Trample')
		  ]
		   where target = game.creature_at_loc_or_die(info.targets[0])",
/*
		ai_patterns: "def(class game game, [[int]] targets) ->[string|null]
		[
			'' + creature.tiles_from_start + ' tiles from start',
			if(opposing_creature, creature.name + ' vs ' + opposing_creature.name, 'unopposed'),
			if(opposing_creature, creature.name + ' distance ' + abs(creature.loc[1] - opposing_creature.loc[1])),
			if(opposing_creature and creature.attack >= opposing_creature.life - opposing_creature.wounds, 'already enough attack to kill'),
			if(opposing_creature and (creature.attack+2) >= opposing_creature.life - opposing_creature.wounds, 'enough attack to kill'),
			if(opposing_creature and (creature.life+2) - creature.wounds > opposing_creature.attack, 'enough life to survive'),

		] where opposing_creature = lib.ai.next_opposing_creature(game, creature)
		  where creature = game.creature_at_loc_or_die(targets[0])",*/
		ai_flags: [AI_CARD_SAVES]

	},
	
	"Feral Rampage": {
		name: "Feral Rampage",
		type: "spell",
		school: FOOD,
		cost: 1,
		loyalty_cost: 2,
		rules: "Target creature gains &+;&3;&attack;, &+;&3;&life;, and Trample this turn.",
		possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  //TODO: revert this to all_creatures_as_possible_targets.
		  //This is temporary code for bot testing.
		  if(game.done_movement, [], if(targets = [], [creature.loc | creature <- game.creatures, not creature.is_building, creature.is_valid_target(game, nplayer, me)]))
		",
		on_play: "def(class game game, class message.play_card info) ->commands [
			creature.add_ability_until_end_of_turn('Trample'),
			creature.apply_effect_until_end_of_turn('attack', 3),
			creature.apply_effect_until_end_of_turn('life', 3),
			]
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc_or_die(info.targets[0])",
/*
		ai_patterns: "def(class game game, [[int]] targets) ->[string|null]
		[
			'' + creature.tiles_from_start + ' tiles from start',
			if(opposing_creature, creature.name + ' vs ' + opposing_creature.name, 'unopposed'),
			if(opposing_creature, creature.name + ' distance ' + abs(creature.loc[1] - opposing_creature.loc[1])),
			if(opposing_creature and creature.attack >= opposing_creature.life - opposing_creature.wounds, 'already enough attack to kill'),
			if(opposing_creature and (creature.attack+3) >= opposing_creature.life - opposing_creature.wounds, 'enough attack to kill'),
			if(opposing_creature and (creature.life+3) - creature.wounds > opposing_creature.attack, 'enough life to survive'),

		] where opposing_creature = lib.ai.next_opposing_creature(game, creature)
		  where creature = game.creature_at_loc_or_die(targets[0])",
		  */
		
		ai_flags: [AI_CARD_SAVES],
	},

	"Slathering Wolf": {
		name: "Slathering Wolf",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: FOOD,
		rules: 'When Slathering Wolf damages an enemy creature, that creature gets &-;&1;&move; and gains Poisoned.',
		creature: {
			tags: ['Wolf'],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 20,
			image_num: 70,
			triggered_abilities: [{
				name: "Infectious disease",
				rules: "&-;&1;&move; and poisoned",
				on_deal_damage: "def(class creature creature, class game game, class creature target, int damage) ->commands
				[add(target.move, -1), 
					if(not ('Poisoned' in target.status_effects), add(target.status_effects, ['Poisoned']))]",
			}],
		}
	},

	"The Great Horde": {
		name: "The Great Horde",
		type: "spell",
		cost: 8,
		loyalty_cost: 2,
		school: FOOD,
		rules: "Summon a Goblin on every tile where you can summon a creature.",
		on_play: "def(class game game, class message.play_card info) ->commands
			map(
			game.player_obj.summoning_locs(game, goblin),
			game.summon_creature(goblin + {
				name: 'Goblin',
				controller: game.current_player,
				loc: value,
			}))
			where goblin = lib.citadel.create_creature('Goblin')"
	},

	"Intense Warfare": {
		name: "Intense Warfare",
		type: "spell",
		cost: 4,
		loyalty_cost: 3,
		school: FOOD,
		rules: "Your creatures Refresh. This turn is returned to the Pre-Combat phase.",
		on_play: "def(class game game, class message.play_card info) ->commands [
		  [ creature.refresh() | creature <- game.creatures,
		    not creature.is_building,
		    creature.controller = game.current_player_index ],

		  set(game.done_movement, false),
		  set(game.precombat_phase, 0),
		]",
		
	},

	"Vines of the Deep Wood": {
		name: "Vines of the Deep Wood",
		type: "spell",
		cost: 3,
		loyalty_cost: 3,
		school: FOOD,
		is_response: true,
		rules: "Place a neutral Forest construct in target tile, destroying any existing construct in the tile.",
		possible_targets: "all_tiles_as_possible_targets",

		on_play: "def(class game game, class message.play_card info) ->commands
		[
			if(target_construct, set(target_construct.destroyed, true)),
			bind_command(game.summon_construct,
			             lib.citadel.create_creature('Forest',
			{
				loc: info.targets[0],
			})),
		] where target_construct = game.construct_at_loc(info.targets[0])",
	},

	"Forest": {
		name: "Forest",
		type: "token",
		token: true,
		cost: 0,
		loyalty_cost: 0,
		school: FOOD,
		rules: "Creatures in this tile have Cover",
		creature: {
			tags: ["Terrain"],
			is_construct: true,
			image_num: 18,
			controller: -1,
			static_ability_effect: "if(creature.loc = target.loc and not target.is_construct, target.add_ability_static_duration('Cover'))",
		},
	},
}
