{
constructor: "[
	set(starting_life, life),
]",
properties: {
	summon_id: { variable: true, default: 0, type: "int" }, //unique within a game.
	name: { variable: true, type: "string" },
	school: { variable: true, default: [0], set: "set(me._data, if(value is int, [value], value))", set_type: "int|[int]", type: "[int]" },

	rules: { variable: true, default: '', type: "string" }, // copy of rules from card_type
	rules_short: { variable: true, default: [], type: "[string]" },  // summarized rules to put on the creature in-game.

	quests: { type: "[class quest]", default: [] },

	token: { type: 'bool', default: false },

	choices: { type: '[int]|null' }, //choices made when summoning this creature.
	channel: { type: 'int', default: 0 }, //amount of mana channeled into this when cast. Usually 0.

	settings: "map <- {}",  //any custom settings peculiar to the instance.

	game_sounds: { type: "string", default: "creature" },

	calculate_voice_summoned: "def(class game_state game) ->string|null
		voice_summoned
	",

	calculate_voice_die: "def(class game_state game) ->string|null
		voice_die
	",

	calculate_voice_redemption: "def(class game_state game) ->string|null
		voice_redemption
	",

	calculate_voice_engaged: "def(class game_state game, class creature enemy, bool doomed, bool enemy_doomed) ->string|null
		if(enemy_doomed and not doomed,
		   voice_battle_win,
		   doomed,
		   voice_battle_lose
		)
	",


	//Sounds
	voice_summoned: { type: "string|null" },
	voice_die: { type: "string|null" },
	voice_redemption: { type: "string|null" },
	voice_battle_win: { type: "string|null" },
	voice_battle_lose: { type: "string|null" },
	sound_summoned: { type: "string", default: "", get: "_data or if(voice_summoned = null, sprintf('gameplay/%s_played', game_sounds), 'null')" },
	sound_attack: { type: "string", default: "", get: "_data or sprintf('gameplay/%s_attack_creature', game_sounds)" },
	sound_breach: { type: "string", default: "", get: "_data or sprintf('gameplay/%s_attack_player', game_sounds)" },
	sound_death: { type: "string", default: "", get: "_data or sprintf('gameplay/%s_death', game_sounds)" },

	sound_regeneration: { type: "string", default: "gameplay/regeneration" },
	sound_walk: { type: "string", default: "" },

	sound_impact: { type: "string", default: "flesh" },

	//sound of weapon swinging when fighting. light/medium/heavy.
	sound_swish: { type: "null|string", default: "light" },

	ai_value: "def(class game_state game) ->int if(base_card, (int<- base_card.cost) + (int<- base_card.loyalty_cost)/2, 0)",

	animation_hints: { variable: true, default: [], type: "[map]" },
	animation_hint_id: { variable: true, default: 1, type: "int" },

	add_animation_hint: "def(map hint) ->commands [add(me.animation_hints, [hint + {hint_id: animation_hint_id}]), add(me.animation_hint_id, 1)]",

	death_animation_hint: { variable: true, type: "string|null" },

	attack_creature_anim: { type: "string|null" },

	attack_player_anim: { type: "string|null" },

	attack_effect: { type: "string|null" },

	damage_creature_effect: "def(class creature target_creature, int damage) ->[{ effect: string, frames_ahead: null|int }|null]
	if(damage > 0,
	[
	{
		effect: if(attack_effect != null, attack_effect, target_creature.is_building, 'rubble_effect', 'blood_spatter'),
		frames_ahead: 0,
	},

	if('Lethal' in abilities and not target_creature.is_building,
	{
		effect: 'blood_scatter',
		frames_ahead: 0,
	}
	),
	if(damage >= target_creature.life and target_creature.is_building,
	{
		effect: 'rubble_base_effect',
		frames_ahead: 0,
	}
	)
	],

	[])
	",

	attack_imprint: { type: "string|null" },

	attack_creature_imprint: "def(class creature target_creature, int damage) ->string|null
	if(damage >= target_creature.life, attack_imprint)
	",

	can_enter_endzone: { variable: true, default: true, type: "bool" },

	overlays: { variable: true, default: [], type: "[{image_num: int, alpha: decimal|null}]" },

	summoning_time: { variable: true, default: 0, get: "if(is_building, _data, 0)", type: "int" },
	summoning_counters: { variable: true, default: 0, type: "int" },
	force_summon: "set(me.summoning_counters, me.summoning_time)",

	increment_summoning: "add(me.summoning_counters, 1)",
	summoned: "summoning_counters >= summoning_time",

	is_building: { type: "bool", default: false },
	is_land: "false",
	is_regular_creature: "bool :: not is_land and not is_building",

	//the base card that this creature came from.
	card_name: { variable: true, default: null, type: 'string|null' },

	base_card: "map|null <- if(card_name != null, lib.json.get_document_map(q(data/cards.cfg))[lib.citadel.actual_card_name(card_name)])",
	calculate_portrait: "string :: portrait or 'null.png'",
	portrait: { type: "string|null", get: "if(_data != null, _data, if(base_card, string|null<- base_card.portrait))" },
	second_portrait: { type: "string|null", get: "if(_data != null, _data, if(base_card, string|null<- base_card.second_portrait))" },
	portrait_x_offset: { type: "decimal", default: 0.0 },
	portrait_y_offset: { type: "decimal", default: 20.0 },
	portrait_scale: { type: "decimal", default: 0.2 },

	portrait_focus: "[int,int]|null :: if(base_card, [int,int]|null<- base_card.portrait_focus)",
	portrait_focus_width: "int|null :: if(base_card, int|null<- base_card.portrait_focus_width)",
	portrait_focus_height: "int|null :: if(base_card, int|null<- base_card.portrait_focus_height)",

	hero: { variable: true, default: false, type: "bool" },

	tags: { variable: true, default: [], type: "[string]" },

	//Status effects -- terrain doesn't get status effects.
	status_effects: { variable: true, get: "if(is_terrain, [], _data)", default: [], type: '[string]' },

	is_terrain: "'Terrain' in tags",

	//a flag set to say that a creature can't move or do anything yet until
	//state-based actions have been applied to it.
	being_summoned: { type: "bool", default: false },
	summoned_this_turn: { type: "bool", default: false },

	turn_summoned: { type: "null|int" },

	exhaust_on_summon: "def(class game_state game) ->commands [
		set(being_summoned, false),
		if('Haste' in abilities, [
			set(spaces_moved_this_turn, 0),
			set(actions, max_actions),
			set(summoned_this_turn, false),
		], [
			set(spaces_moved_this_turn, 100), //makes it immobile
			set(actions, 0),
			set(summoned_this_turn, true),
		])
	]",

	exhaust: "def() ->commands [
		if(actions > 0, use_action()),
		set(spaces_moved_this_turn, move)
	]",
    
    snare: "def() ->commands 
        [add(status_effects, ['Snared']),
         set(spaces_moved_this_turn, move)]",

	// This helps the fact creature hasting (post-summoning hasting) is not
	// being enforced just by adding the ability (`Haste`), if the creature
	// summonning has already been completed.
	shake_haste: "def
		() -> commands
		// The creature has to be reconfigured as having available
		// movement points.
		set(spaces_moved_this_turn, 0)",

	use_action: "def() ->commands add(actions, -1)",
	has_action: "actions > 0",
	max_actions: { type: "int", default: 1 },
	actions: { type: "int", default: 1, set: "set(_data, max(value, 0))" },

	//a transient variable that is set only while combat is ongoing, will be set
	//to the creatures (usually one) that the creature attacks
	has_attacked: { type: "[class creature]", default: [] },

	set_sleeping: "def() ->commands if(not ('Sleeping' in status_effects),
		[add(me.status_effects, ['Sleeping']),
		set(me.ready_to_wakeup, false) ])",

	set_awake: "def() ->commands if('Sleeping' in status_effects, set(me.status_effects, filter(me.status_effects, not value in ['Sleeping'])))",

	is_sleeping: "'Sleeping' in status_effects",

	// Sleeping is a bit tricky to get right. You should be able to cast sleep on your units or enemy units, and they will sleep for one turn.
	// Naturally, it should be an effect which is removed at end of their controllers turn. However, then they manage to move in the time
	// between the end of their turn and start of the next players turn.
	// Thus, we use two flags. ready_to_wakeup is a private bool refreshed to true at end of their turn.
	// The creature refresh routine, called at turn start, calls "maybe_wakeup" to wake a unit up if ready_to_wakeup is true.
	ready_to_wakeup: {type: "bool", default: false, access: 'private'},
	maybe_wakeup: "def() ->commands if(ready_to_wakeup, [set_awake(), set(me.ready_to_wakeup, false)])",

	refresh: "def() ->commands [
	    map(activated_abilities, set(value.used_this_turn, false)),
		set(actions, max_actions),
		set(spaces_moved_this_turn, 0),
		maybe_wakeup()
	]",

	// List of strings containing keyworded abilities -- such as
	// 'Flying', First Strike', etc.
	abilities: { variable: true, default: [],
	  type: "[string]",
	  set_type: "[string]"},

	// List of activated abilities of type class card_base
	activated_abilities: {
		set: "set(me._data,
		        map(value, if(value is map, construct('activated_ability', value), value)))",
		type: "[class card_base]",
		set_type: "[map|class card_base]",
		default: [],
	},

	// List of triggered abilities of type class triggered_ability
	triggered_abilities: {
	  get: "if(summoned, _data, [])",
	  set: "set(me._data,
				        map(value, if(is_map(value), construct('triggered_ability', value), value)))",
	  type: "[class triggered_ability]",
	  set_type: "[map|class triggered_ability]",
	  default: [],
	  },
	
	passive_abilities: {
		set: "set(me._data, map(value, if(value is map, construct('passive_ability', value), value)))",
		type: "[class passive_ability]",
		set_type: "[map|class passive_ability]",
		default: [],
	},

	sprite_sheet: { variable: true, default: null, type: "null|string" },
	image_num: { variable: true, default: 0 },

	is_melee: "bool :: 'Ranged' not in abilities",
	is_ranged: "bool :: 'Ranged' in abilities",

	range: { variable: true, default: 0, type: "int" },
	attack: { variable: true, default: 0, get: "if(summoned, me._data, 0)" },
	life_shield: { type: "int", default: 0 },

	life: { type: "int", default: 1  },

	net_life: "int :: life + max(0, life_shield)",

	starting_life: { type: "int", default: 1 },
	move: { variable: true, default: 1, get: "if(is_building and (not 'Mobile' in abilities) or is_land, 0, 'Swift' in abilities, 2, 'Immobile' in abilities, 0,_data)" },
	spaces_moved_this_turn: { variable: true, default: 0 },
	initiative: { variable: true, default: 1 },

	armor: { variable: true, default: 0, get: "if(summoned, _data, 0)" },

	armor_against: "def(class game_state game, class creature attacker, int damage) ->int me.armor",

	resistance: { default: 0, type: "int", },
	conduit: { default: 0, type: "int", },

	modify_card_cost_targeted_at: "def(class card_base card, int nplayer) ->int
		if(nplayer != controller, resistance, 0) - conduit
	",

	level: { variable: true, default: 0 },

	energy: { variable: true, default: 0 },

	income: "def(class game_state game) ->int 0",
	opponent_income: "def(class game_state game) ->int 0",
	card_draw: "def(class game_state game) ->int 0",

	reached_endzone: { variable: true, default: false },

	is_valid_target: "def(class game_state game, int nplayer, class card_base|class creature obj) ->bool
	    not (game.team_index(nplayer) != game.team_index(controller) and
		     has_cover(game) or has_untargetable(game))",

	has_cover: "def(class game_state game) ->bool ('Cover' in abilities)",
	has_untargetable: "def(class game_state game) ->bool ('Untargetable' in abilities)",

	handle_summoning: "def(class game_state game) ->commands [
		game.add_animation_hint(
			construct('animation.summon_creature_hint', {
				creature: me,
				loc: loc,
			})
		),
		set(me.being_summoned, true),
		me.fire_event('on_summoned', [game]),

		_fire_moveover_events(game, loc),
	]",

	on_summoned: "def(class game_state game) ->commands null",

	on_damaged: "def(class game_state game, int damage) ->commands null",
	on_attacked: "def(class game_state game, class creature attacker, int damage) ->commands null",

	on_deal_damage: "def(class game_state game, class creature target, int damage, null|class animation.creature_attack_hint hint=null) ->commands
		if(('Life Drain' in abilities) and not target.is_building, [
			add(me.life, damage);
			if(hint, add(hint.drain, damage)),
		])",

	gain_life: "def(int amount) ->commands
	  if(amount > 0, add(life, amount))
	",

	direct_life_loss: "def(int damage) ->commands
	if(damage > 0,
		if(life_shield > 0,
			[
				add(life_shield, -shield_damage),
				add(me.life, -(damage - shield_damage)),
			]
			where shield_damage = min(damage, life_shield), 
			add(me.life, -damage)
		)
	)
	",
	
	inflict_damage: "def(class game_state game, int damage) ->commands
	if(damage_dealt > 0 and not indestructible,
	[
		direct_life_loss(damage_inflicted),
		me.fire_event('on_damaged', [game, damage_dealt]),
	])
	    where damage_dealt = min(net_life, damage_inflicted)
		where damage_inflicted = damage - armor
	",

	inflict_combat_damage: "def(class game_state game, class creature attacker, int damage, null|class animation.creature_attack_hint hint=null) ->commands
	[
	if(damage_dealt > 0,
	[
		if( ('Lethal' in attacker.abilities) and (not me.is_building), set(me.destroyed, true)),
		direct_life_loss(damage_inflicted),
		set(me.damage_dealt_killed, damage_dealt = me.net_life),
		if(damage_dealt = me.net_life, set(me.damage_dealt_killed_by, attacker.summon_id)),
		me.fire_event('on_attacked', [game, attacker, damage_dealt]),
		me.fire_event('on_damaged', [game, damage_dealt]),
		attacker.fire_event('on_deal_damage', [game, me, damage_inflicted, hint]),
		if(damage_dealt_turn = game.turn,
			add(me.damage_dealt_by, {
			attacker.summon_id: damage_dealt + damage_dealt_by[attacker.summon_id]
			}),
			[set(me.damage_dealt_turn, game.turn),
			 set(me.damage_dealt_by, {attacker.summon_id: damage_dealt}),
			]
		)
	]);

	if(hint != null, set(hint.damage, damage_inflicted))
	]
	  where damage_dealt = min(me.net_life, damage_inflicted)
	  where damage_inflicted = if(indestructible, 0, damage - me.armor_against(game, attacker, damage))",
	// Purpose of the above: damage_inflicted is essentially the armor-adjusted damage.
	// damage_dealt is the damage that is actually dealt, with the convention that you don't deal more than X damage to a unit with X hp.
	// damage_inflicted is what should be subtracted from the units life.
	// damage_dealt is what lifesteal calculations should be based on.

	hit_by_this_turn: "def(class game_state game) -> [int]
	  if(damage_dealt_turn = game.turn, map(damage_dealt_by, key), [])",
	killed_by_this_turn: "def(class game_state game) -> null|class creature
	  if(damage_dealt_turn = game.turn and damage_dealt_killed_by >= 0, game.creature_by_summon_id(damage_dealt_killed_by))",

	on_kill: "def(class game_state game, class creature victim) ->commands null",
	on_another_creature_died: "def(class game_state game, class creature victim) ->commands null",

	on_another_creature_summoned: "def(class game_state game, class creature new_creature) ->commands null",

	on_land_summoned: "def(class game_state game, class creature new_creature, null|class creature old_land) ->commands null",

	on_card_played: "def(class game_state game, class player player, class message.play_card info) ->commands null",

	on_die: "def(class game_state game) ->commands 
    add(game.num_creatures_killed_this_turn, 1)",

	on_card_discarded: "def(class game_state game, class player player, class card card) ->commands null",

	fire_events_on_death: "def(class game_state game) ->commands [
	   game.fire_creature_event('on_another_creature_died', [me]),

	   //If we die from our wounds, then the last creature who has inflicted a killing wound on
	   //us this turn is credited with our death.
	   if(net_life <= 0,
	     if(killer, killer.fire_event('on_kill', [game, me])) where killer = killed_by_this_turn(game)
	   )]",

	on_reach_endzone: "def(class game_state game) ->commands [
		bind_command(game.apply_trophy, if(controller = 0, 1, 0), loc[0]),

		set(me.reached_endzone, true),
		add(player.life, -damage),
		if(damage != 0,
		   add(game.animation_hints, [
		     construct('animation.player_damage_hint', {
			   type: 'player_damage_hint',
			   target_player: player_index,
			   source: me,
			   amount: damage,
			   intensity: damage + game.trophies[if(controller = 0, 1, 0)][loc[0]],
			 })
		   ])
		),
		if(not ('Phantasmal' in abilities), add(player.creatures_in_citadel, [me])),
	] where damage = if('Phantasmal' in abilities, 0, if('Assassinate' in abilities, max(0, attack*2), max(0, attack)))
	  where player = game.players[player_index]
	  where player_index = if(controller = 0, 1, 0)",

	sacrificed: { type: 'bool', default: false },
	valiant_delay_death: { type: 'bool', default: true },
	destroyed: { set: "if(not indestructible, set(me._data, value))", type: 'bool', default: false },
	obliterated: { type: 'bool', default: false },
	alive: "bool :: (net_life > 0 or is_land or indestructible or ('Valiant' in abilities)) and valiant_delay_death and (not destroyed) and (not sacrificed) and (not obliterated)",

	loc: { default: [-1,-1], type: 'Loc', set: "[set(_data, value)]" },

	set_loc: "def(class game_state game, Loc target, string move_type='move') ->commands
	if(target != loc, [
		_fire_moveover_events(game, target),

		if(game.is_loc_in_endzone(target, me.controller) and game.trophies[(me.controller+1)%2][target[0]] > 0,
			game.add_animation_hint(construct('animation.creature_shatter_seal_hint', {
				creature: me,
				target_player: (controller+1)%2,
				target_lane: target[0],
			}))
		),

		game.add_animation_hint(construct('animation.move_hint', {
			moves: [{
				type: move_type,
				creature: me,
				dest: target,
				source: loc,
			}],
		})),
		set(loc, target),
	])",

	is_on_board: "bool<- loc != [-1,-1]",

	tiles_from_start: "int<- if(loc, if(controller = 0, loc[1], 8 - loc[1]))",

	is_unblocked: "def(class game_state game) ->bool
		find(game.creatures, value.loc[0] = loc[0] and game.team_index(value.controller) != game.team_index(controller) and sign(value.loc[1] - loc[1]) = sign(direction_moving)) = null
	",

	controller: { variable: true, default: -1 },

	stats_label_size: "15",
	stats_font: "lib.font.regular_font",
	stats_alpha: "if(loc = null, 255, 96)",

	on_move_over_creature: "def(class game_state game, class creature creature) ->commands null",
	on_move_over_construct: "def(class game_state game, class creature construct) ->commands null",
	on_moved_over_by_creature: "def(class game_state game, class creature creature) ->commands null",

	on_move: "def(class game_state game) ->commands null",

	on_end_game: "def(class game_state game, int nwinner) ->commands
		null
	",

	indestructible: "('Indestructible' in abilities)",

	//formula which takes {creature, target, game} argument and applies the
	//static effect on the target.
	static_ability_effect: { variable: true, default: null, type: 'string|null' },

	//Evaluate passive effects. We iterate over our passive abilities and apply their effects.
	//Any passive ability which is deferred is not evaluated but instead added to the
	//game.deferred_passive_abilities list for evaluation later
	static_effect: "def(class game_state game) ->commands
	  map(passive_abilities,
	      if(value.deferred,
		     add(game.deferred_passive_abilities, [{creature: me, ability: value}]),
			 value.static_effect(game, me)
			)
		 )",

	_creature_effects: { default: [], type: '[class creature_static_effect]' },

	apply_creature_effect: "def(class game_state game, function(class game_state, class creature, map)->commands apply, function(class game_state, class creature, map)->commands revert, map info={}, int duration=DURATION_STATIC) ->commands [
		apply(game, me, info),
		add(_creature_effects, [construct('creature_static_effect', {
			apply_fn: apply,
			revert_fn: revert,
			duration: duration,
			info: info,
		})]),
	]",

	remove_creature_effects: "def(class game_state game, int duration=DURATION_STATIC) [
		[if(effect.revert_fn, effect.revert_fn(game, me, effect.info)) | effect <- me._creature_effects, effect.duration = duration],
		set(me._creature_effects, filter(me._creature_effects, value.duration != duration)),
	]",

	//allows cards to manage tracking data for specific creature effects
	effects_tracking: { type: '{string -> any}', default: {} },

	is_reloading: "def(class game_state game) ->bool
		('Ranged' in abilities) and game.current_player_turn_index != controller
	",

	apply_static_abilities: "def(class game_state game) ->commands
	if(summoned, [
	static_effect(game),
	if(me.static_ability_effect,
	    [map(game.creatures, commands<- eval_no_recover(me.static_ability_effect, {creature: me, target: value, game: game}))])])",

	apply_static_effect: "def(string attr, int delta, null|string tag=null) ->commands
	  if(summoned, [add(me[attr], delta), add(me.static_effects, [construct('creature.static_effect', {attr: attr, delta: delta, tag: tag})])])",
	apply_static_effect_while_summoning: "def(string attr, int delta) ->commands
	  if(not summoned, [add(me[attr], delta), add(me.static_effects, [construct('creature.static_effect', {attr: attr, delta: delta})])])",

	static_effects: { default: [], type: '[class creature.static_effect]', access: 'private' },
	static_status_effects: { default: [], type: '[string]', access: 'private' },
	static_abilities: { default: [], type: '[string]', access: 'private' },
	static_activated_abilities: { default: [], type: '[int]', access: 'private' },
	static_triggered_abilities: { default: [], type: '[int]', access: 'private' },

	this_turn_effects: { default: [], type: '[map]', access: 'private' },
	this_turn_abilities: { default: [], type: '[string]', access: 'private' },
	this_turn_activated_abilities: { default: [], type: '[class card_base]', access: 'private' },
	this_turn_triggered_abilities: { default: [], type: '[class triggered_ability]', access: 'private' },
	this_turn_passive_abilities: { default: [], type: '[class passive_ability]', access: 'private' },

	effect_tags: "[{ type: string, args: map|null }] :: filter(map(static_effects, { type: value.tag }) + map(this_turn_effects, { type: value.tag }) +
	  map(triggered_abilities, { type: value.tag }) +
	  map(passive_abilities, { type: value.effect, args: value.effect_args }) +

		if('Poisoned' in status_effects, [{type: 'poison_creature_effect'}], []) +
		if('Cover' in abilities, [{type: 'shield_effect'}], []),
				
		value is { type: string, args: map|null })",

	damage_dealt_turn: { default: -1, type: 'int', access: 'private' },
	damage_dealt_by: { default: {}, type: '{int -> int}', access: 'private' }, //maps creatures to amounts.
	damage_dealt_killed: { default: false, type: 'bool', access: 'private' }, //whether we were killed by combat damage
	damage_dealt_killed_by: { default: -1, type: 'int', access: 'private' }, //the creature who killed us by combat damage

	ability_id: { default: 1, type: 'int', access: 'private' },

	remove_static_effects: "def(class game_state game) ->commands [
        map(static_effects, add(me[value.attr], -value.delta)),
        set(me.static_effects, []),
        set(me.abilities, [string]<- remove_abilities(abilities, static_abilities)),
        set(me.static_abilities, []),

        set(me.status_effects, [string]<- remove_abilities(status_effects, static_status_effects)),
        set(me.static_status_effects, []),
	   
        set(me.activated_abilities, filter(me.activated_abilities, value.unique_id not in static_activated_abilities)),
        set(me.static_activated_abilities, []),
 
        set(me.triggered_abilities, filter(me.triggered_abilities, value.unique_id not in static_triggered_abilities)),
        set(me.static_triggered_abilities, []),

		remove_creature_effects(game, DURATION_STATIC),
    ]",

	add_ability_static_duration: "def(string ability) ->commands [
	  add(me.static_abilities, [ability]),
	  add(me.abilities, [ability])
	]",

	add_status_effect_static_duration: "def(string effect) ->commands [
	  add(me.static_status_effects, [effect]),
	  add(me.status_effects, [effect])
	]",

	add_activated_ability_static_duration: "
	def(map activated_ability) ->commands
	[
	  add(me.ability_id, 1),
	  add(me.static_activated_abilities, [ability_id]),
	  add(me.activated_abilities, [activated_ability + {unique_id: ability_id}])
	]",

	apply_effect_until_end_of_turn: "
	  def(string attr, int delta, null|string tag=null) ->commands
	  [
	   add(me[attr], delta),
	   add(me.this_turn_effects, [{attr: attr, delta: delta, tag: tag}])
	  ]",

	add_ability_until_end_of_turn: "def(string ability) ->commands
	[
	  add(me.this_turn_abilities, [ability]),
	  add(me.abilities, [ability])
	]",

	add_activated_ability_until_end_of_turn: "def(map ability) ->commands
	[
	  add(me.ability_id, 1),
	  add(me.this_turn_activated_abilities, [new_ability]),
	  add(me.activated_abilities, [new_ability])
	] where new_ability = construct('activated_ability', ability + {unique_id: ability_id})",

	add_triggered_ability_until_end_of_turn: "def(map ability) ->commands
	[
		add(me.ability_id, 1),
		add(me.this_turn_triggered_abilities, [new_ability]),
		add(me.triggered_abilities, [new_ability])
	] where new_ability = construct('triggered_ability', ability + {unique_id: ability_id})",

	add_passive_ability_until_end_of_turn: "def(map ability) ->commands
	[
		add(me.ability_id, 1),
		add(me.this_turn_passive_abilities, [new_ability]),
		add(me.passive_abilities, [new_ability])
	] where new_ability = construct('passive_ability', ability + {unique_id: ability_id})",

	add_triggered_ability_static_duration: "def(map ability) ->commands [
		add(me.ability_id, 1),		
		add(me.static_triggered_abilities, [ability_id]),
		add(me.triggered_abilities, [new_ability]),
	] where new_ability = construct('triggered_ability', ability + {unique_id: ability_id})",
	
	fire_event: "def(string event_name, list args) ->commands
	 commands<- [
	  call(function<- query(me, event_name), args),
	  [ call(function<- query(ability, event_name), [me] + args) |
	    ability <- triggered_abilities, not is_string(ability)],

	  [ call(function<- query(quest, event_name), [me] + args) |
	    quest <- quests],
	]",

	add_effect_hint: "def(class game_state game, string effect_name, int delay_time=20) ->commands
	add(game.animation_hints, [construct('animation.creature_effect_hint', { creature: me, effect: effect_name, delay: delay_time })])
	",

	begin_turn: "def(class game_state game) ->commands [
	  set(summoned_this_turn, false),
	  bind_command(remove_creature_effects, game, DURATION_BEGINNING_NEXT_TURN),
	  set(me.spaces_moved_this_turn, 0),
	  if(game.current_player = controller, [
	  		refresh();
			if('Regeneration' in abilities, add_animation_hint({
					type: 'regeneration'
				})),
			if('Sleeping' in status_effects, add_animation_hint({
					type: 'sleeping'
				})),
	  		add(me.life,  (count(abilities, value = 'Regeneration') *2)
	  		             -count(status_effects, value = 'Poisoned')),
			add(me.attack, -count(status_effects, value = 'Poisoned')),
            
            if('Snared' in status_effects, set(me.spaces_moved_this_turn, me.move)),
            set(me.status_effects, filter(me.status_effects, not value in ['Snared'])) //remove all snares
		]
	  );
	  me.fire_event('on_begin_turn', [game])
	]",

	on_begin_turn: "def(class game_state game) ->commands null",

	remove_abilities: "def([string|int|class card_base|class triggered_ability|class passive_ability] abilities, [string|int|class card_base|class triggered_ability|class passive_ability] removal) ->[string|int|class card_base|class triggered_ability|class passive_ability]
	 if(removal = [], abilities,
	  remove_abilities(remove_single_ability(abilities, removal[0]),
	                   removal[1:]))",

	remove_single_ability: "def([string|int|class card_base|class triggered_ability|class passive_ability] abilities, string|int|class card_base|class triggered_ability|class passive_ability item) ->[string|int|class card_base|class triggered_ability|class passive_ability]
	  if(is_string(item), if(i = -1, abilities, abilities[0:i] + abilities[i+1:]) where i = index(abilities, item),
	   filter(abilities, value != ability)
	    where ability = find(abilities, value = item))",
	
	on_end_turn: "def(class game_state game) ->commands null",
	on_end_turn_in_players_hand: "def(class game_state game, class card_base card) ->commands null",

	end_turn: "def(class game_state game) ->commands [
	 if(net_life <= 0, set(valiant_delay_death, false)),

	 bind_command(remove_creature_effects, game, DURATION_END_OF_TURN),
	 me.fire_event('on_end_turn', [game]),
	  if(game.current_player = controller, [
			if(is_sleeping, set(me.ready_to_wakeup, true))
		]
	  ),
	 _remove_this_turn_effects(),
	]",

	_remove_this_turn_effects: "def() ->commands [
	 	map(this_turn_effects, add(me[value.attr], -value.delta)),
		set(me.this_turn_effects, []),
	    set(me.abilities, [string]<- remove_abilities(abilities, this_turn_abilities)),
	    set(me.activated_abilities, [class card_base]<- remove_abilities(activated_abilities, this_turn_activated_abilities)),
	    set(me.passive_abilities, [class passive_ability]<- remove_abilities(passive_abilities, this_turn_passive_abilities)),
	    set(me.triggered_abilities, [class triggered_ability]<- remove_abilities(triggered_abilities, this_turn_triggered_abilities)),
	    set(me.this_turn_abilities, [])
	]",

	//the number of spaces this creature wants to move, according to its
	//behavior. (Which includes stopping when in range of an enemy).
	desired_moves: "def(class game_state game, int movement) ->int
	movement",

	has_unspent_moves: "bool :: move - spaces_moved_this_turn > 0",

	//expected destination this creature will move to under normal movement this turn.
	expected_move_loc: "def(class game_state game) ->null|Loc
	if(game.current_player_turn_index != controller or moves <= 0 or can_move_not_blocked(game) = false, null,
		   moves > 1 and game.creature_at_loc([loc.x, loc.y + direction_moving*2]) = null, [loc.x, loc.y + direction_moving*2],
		   [loc.x, loc.y + direction_moving]
	)
	   where moves = (move - spaces_moved_this_turn)
	",

	do_move: "def(class game_state game) ->commands
	  if(move - spaces_moved_this_turn > 0,
	     move_creature(game, move - spaces_moved_this_turn))",
	
	move_creature: "def(class game_state game, int nmoves) ->commands
	if(can_move_not_blocked(game),
		if(nmoves >= 2 and game.creature_at_loc([loc.x, loc.y + direction_moving*2]) = null,
		   do_move_internal(game, 2, direction),
		   do_move_internal(game, 1, direction)
		)
	)
	   where direction = direction_moving*sign(nmoves)
	   where moves = abs(nmoves)
	",

	can_move_not_blocked: "def(class game_state game) ->bool
	if(move - spaces_moved_this_turn <= 0, false,
	   move - spaces_moved_this_turn >= 2,
	   //moving 2 spaces
	   next_creature = null or (next_creature.controller = me.controller and game.creature_at_loc([loc.x, loc.y + direction_moving*2]) = null)
	     where next_creature = game.creature_at_loc([loc.x, loc.y + direction_moving]),
	   
	   //just moving 1 space.
	   game.creature_at_loc([loc.x, loc.y+direction_moving]) = null and
	   (is_ranged = false or
	    (
		//ranged creatures move forward if there is no enemy two spaces ahead
	    ((c = null or c.controller = me.controller) where c = game.creature_at_loc([loc.x, loc.y+direction_moving*2])) and
		
		//ranged creatures that have attacked only move forward if there is no enemy three spaces ahead
		(has_action or ((c2 = null or c2.controller = me.controller) where c2 = game.creature_at_loc([loc.x, loc.y+direction_moving*3])))
		)
	   )
	)
	",

	_fire_moveover_events: "def(class game_state game, Loc loc) ->commands
	if(not is_land,
		if(construct != null,
		[
			construct.fire_event('on_moved_over_by_creature', [game, me]),
			me.fire_event('on_move_over_construct', [game, construct]),
		]) where construct = game.land_at_loc(loc)
	)
	",

	do_move_internal: "def(class game_state game, int move_spaces, int dir=0) ->commands
	[
	  if(move_spaces > 0, add(game.num_moves_made, 1)),
	  add(me.spaces_moved_this_turn, move_spaces),
	  if(move_spaces = 0, null,
	  
	  if(game.creature_at_loc(target_loc) = null and (game.is_loc_on_board(target_loc) or game.is_loc_in_endzone(target_loc, controller) and can_enter_endzone),
		  [
		  map(range(1, move_spaces+1), [
		    if('Feral' not in abilities,
			   game.capture(moveover_loc, if(is_marauder and not is_cove, -1, controller))
			),
			if(creature != null, [creature.fire_event('on_moved_over_by_creature', [game, me]), me.fire_event('on_move_over_creature', [game, creature])]) where creature = game.creature_at_loc([loc[0], loc[1] + value*direction]),
			if(moveover_loc != target_loc, _fire_moveover_events(game, moveover_loc)),
		] where moveover_loc = [loc[0], loc[1] + value*direction]
		  where is_cove = if(construct != null, 'Cove' in construct.abilities, false)
		  where construct = game.land_at_loc([loc[0], loc[1] + value*direction])
		) where is_marauder = ('Marauder' in abilities),
		  me.set_loc(game, target_loc, 'move');
		  me.fire_event('on_move', [game]),
		  ], do_move_internal(game, move_spaces-1, direction)
	  )
	  where target_loc = [loc[0], loc[1] + move_spaces*direction])
	  where direction = if(dir = 0, direction_moving, dir)
	]
      asserting loc",
	
	is_engaged: "def(class game_state game) ->bool
		game.has_unspent_moves = false and has_action and game.current_player_turn_index = controller and is_melee and move - spaces_moved_this_turn > 0 and size(targets_attacking(game)) > 0
	",

	targets_attacking: "def(class game_state game) ->[class creature]
	[class creature]<-
	  if(has_attacked, has_attacked,
	     has_action = false and game.current_player_turn_index = controller or attack <= 0 or is_reloading(game), [],
	   filter(map(search_directions, if(effective_range > 0, find_target(game, value, value*effective_range))), value != null and (target_must_be_attacking_us = false or /*value.is_melee and*/ value.controller = game.current_player_turn_index and index(value.targets_attacking(game), me) != -1))
	  //we want to attack in both directions if we're neutral, otherwise
	  //attack in the direction we're going.
	  where search_directions = if(controller = -1, [-1,1], [direction_moving])
	  where target_must_be_attacking_us = game.current_player_turn_index != controller
	  where effective_range = if(is_ranged, 2, move - spaces_moved_this_turn > 0 or game.current_player_turn_index != controller, 1, 0)
	  )",
	
	do_attack: "def(class game_state game, null|[class creature] forced_targets=null, bool first_strike=false, bool main_combat=true) ->commands if(attack > 0 and not is_reloading(game), [

	  add(game.animation_hints, attack_hints),
	  map(targets, [
	               value.inflict_combat_damage(game, me, attack, attack_hints[index]),
	               ]),
	  if(targets and main_combat,
	    if(game.current_player_turn_index = controller,
		   set(has_attacked, targets)
		  )
		)
	]
	  where attack_hints = map(targets, construct('animation.creature_attack_hint', { type: 'attack_hint', attacker: me, defender: value, damage: attack, first_strike: first_strike}))
	  where targets = if(forced_targets != null, forced_targets, targets_attacking(game))
	)",
	

	find_target: "def(class game_state game, int moves_ahead, int max_moves) ->class creature|null
	  if(potential != null and potential.controller != me.controller,
		 potential, if(moves_ahead = max_moves, null, find_target(game, moves_ahead + sign(moves_ahead), max_moves)))
	  where potential = game.creature_at_loc([loc[0], loc[1] + moves_ahead])",

	find_blocker: "def(class game_state game, int moves_ahead, int max_moves, int dir=0) ->int
	   if(blocking_creature != null and
		  blocking_creature != me,
		  moves_ahead,
		  if(moves_ahead+1 < max_moves,
			 find_blocker(game, moves_ahead+1, max_moves), max_moves))
	   where blocking_creature = game.creature_at_loc([loc[0], loc[1] + moves_ahead*direction])
	   where direction = dir or direction_moving
	   ",

	find_first_vacant: "def(class game_state game, int moves_ahead, int dir=0) ->int
	  if(moves_ahead <= 0, 0,
	  if(game.creature_at_loc([loc[0],
			                  loc[1] + moves_ahead*direction]),
		    find_first_vacant(game, moves_ahead-1, direction),
			moves_ahead))
		where direction = dir or direction_moving",
	
	restored: { type: "bool", default: false },
	
	restore: "def(class game_state game) ->commands
		me.transform(game, lib.citadel.create_creature(card_name or name))
	",

	transform: "def(class game_state game, map|class creature new_type) ->commands
		bind_command(me._do_transform, game, new_type)
	",

	_do_transform: "def(class game_state game, map|class creature new_type) ->commands
	[
	  set(game.creatures, filter(game.creatures, value.summon_id != me.summon_id) + [new_creature]),

	  set(new_creature.loc, me.loc),
	  set(new_creature.controller, me.controller),
	  set(new_creature.summon_id, me.summon_id),
	  set(new_creature.card_name, me.card_name),
	  set(new_creature.spaces_moved_this_turn, me.spaces_moved_this_turn),
	  set(new_creature.actions, min(me.actions, new_creature.max_actions)),
	] where new_creature = if(is_map(new_type), construct('creature', new_type), new_type)",

	direction_moving: "if(controller = 1, -1, 1)",

	//if this creature allows summoning in additional tiles.
	allows_summoning: "def(class game_state game, class creature target) ->[Loc] fold(map(passive_abilities, value.allows_summoning(game, me, target)), a+b)",

	particle_effects: "[string] :: sum(map(passive_abilities, value.particle_effects) + map(triggered_abilities, value.particle_effects), [])",

	rules_tips: "[CreatureAbilityInfo] ::
	map(
	if(is_building, ['Building'], []) + unique(sort(abilities + status_effects)),
	{
		title: value + if(dups > 1, sprintf(q( (x%d)), dups), ''),
		text: string<- (help[value] asserting value in help | value),
		icon: string<- if(value = 'Valiant' and net_life <= 0, 'valiant-active.png', icon_info[value] or 'passive-generic.png'),
		duplicates: dups,
	}
	where dups = count(status_effects, value = context.value)
	where icon_info = lib.json.get_document_map('data/ability-icons.cfg'))

	+ if(resistance > 0, [{
		title: 'Resistance',
		text: sprintf(q(Your opponent must pay <b>%d</b> extra mana to target this creature with a spell.), resistance),
		icon: 'resistance.png',
		cost: resistance,
		cost_color: 'black',
	}], [])

	+ if(conduit > 0, [{
		title: 'Conduit',
		text: sprintf(q(Players pay <b>%d</b> less mana to target this creature with a spell.), conduit),
		icon: 'conduit.png',
		cost: conduit,
		cost_color: 'black',
	}], [])

	+ if(armor > 0, [{
		title: 'Armor',
		text: q(When this creature takes damage it is reduced by <b>) + str(armor) + if(armor = 1, q(</b> point.), q(</b> points.)),
		icon: 'null.png',
	}], [])

	+ map(
	filter(passive_abilities, value.hidden_on_creature = false),
	{
		title: value.name,
		text: q(<font size='-20%'><i>Passive Ability</i>\n</font>) + value.rules,
		icon: value.icon,
	})

	+ map(
	filter(triggered_abilities,
		not value.hidden_on_creature
			or value.hidden_on_creature
				and value.ignore_hidden_on_creature_on_turn_when_summoned
				and summoned_this_turn),
	{
		title: value.name,
		text: q(<font size='-20%'><i>Triggered Ability</i>\n</font>) + value.rules,
		icon: value.icon,
	})

	+ map(
	activated_abilities,
	{
		title: value.name,
		text: q(<font size='-20%'><i>Activated Ability&emdash;Costs ) + str(value.cost) + q(</i>\n</font>) + value.rules_text,
		is_activated: true,
		cost: value.cost,
		is_on_cooldown: value.is_on_cooldown,
	})

	+ map(sort(help_strings), {
		title: value,
		text: string<- (help[value] asserting value in help | value)
		  where help = lib.json.get_document_map('data/help-abilities.cfg'),
		icon: 'null.png',
	}) where help_strings = [string]<- if(base_card != null and base_card.help_strings is [string], base_card.help_strings, [])
	   where help = lib.json.get_document_map('data/help-abilities.cfg')
	",

	gui_status_grid: "
		if(status_effects = [], null,
			{
				type: 'grid',
				padding: [10,10],
				columns: 1,
				x: 10, y: 0,
				zorder: 2,
				children: map(([string] :: status_effects),
				{
					type: 'image',
					image: 'citadel-icons.png',
					area: [icon_num*10, 0, (icon_num+1)*10-1, 9]
					   where icon_num = switch(value,
					   'Poisoned', 6,
					   5)
				})
			}
		)
	",
	
	gui_stats_grid: "def(int facing, int img_w, int img_h) ->map
 	{
		type: 'grid',
		id: 'gui_stats_grid',
		columns: 2,				
		column_alignments: 'centre',
		xy: [if(facing >= 0, -30, 60), (img_h-10*itm_count/2)/2],
		alpha: stats_alpha,
		children: [] +				

		if((not is_land) and ((not is_building) or attack > 0),
		[
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*attack,266,126 + 10*attack,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [40,0,49,9],
			},
		], []) +

		[
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [30,0,39,9],
			},
		] +

		if((not is_land) and armor != 0, [
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*abs(armor),if(armor < 0,286,266),126 + 10*abs(armor),if(armor < 0,295,275)],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: if(armor < 0, [10,0,19,9], [20,0,29,9]),
			},
		], []) +

		if((not is_land) and (not loc), [
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*life,266,126 + 10*life,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [0,0,9,9],
			},
		], []) +

		if((not is_land) and ((not is_building) or move > 0),
		[
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*move,266,126 + 10*move,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [70,0,79,9],
			},
		], []) +

		if(energy > 0,
		[
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*energy,266,126 + 10*energy,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [60,0,69,9],
			},
		], []),
								
				
				/*+

		if(is_building or level > 0, [
			{
				type: 'label',
				color: 'black',
				text: '',
				size: 12,
				font: stats_font,
			},
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [127 + 9*level,266,136 + 9*level,275],
			},
		], [])*/
		
	} where itm_count = if((not is_building) or attack > 0,2,0) + 0 + if(armor != 0,2,0) + if((not is_building) or move > 0,2,0)/* + if(is_building or level > 0,2,0)*/
	",

	silence: "def(class game_state game) ->commands
	remove_static_effects(game);
	_remove_this_turn_effects();
	[
		set(me.abilities, []),
		set(me.activated_abilities, []),
		set(me.triggered_abilities, []),
		set(me.move, 1),
        set(me.max_actions, 1),
		set(me.armor, 0),
		set(me.passive_abilities, []),
	]",
},
	classes: {
		static_effect: {
			properties: {
				attr: { type: 'string' },
				delta: { type: 'int' },
				tag: { type: 'null|string' },
			}
		}
	}
}
