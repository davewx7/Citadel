{
	properties: {
		session_id: { variable: true, default: 0 },

		args: { variable: true, type: "map" },

		score_summons: "def(class game game, map play_info, class card card, [int] loc)
		 (
		 	//score for there being an unowned glyph with no other creature
			//claiming it.
			if(nearest_unowned_glyph != null,
			   if(find(game.creatures,
					   value.loc[0] = loc[0] and
					   value.loc[1] >= nearest_unowned_glyph[1]) = null,
					   nearest_unowned_glyph[1]*10, 0), 0)
		 )
			  where nearest_glyph = choose(filter(keys(game.villages), value[0] = loc[0]), value[1])
			  where nearest_unowned_glyph = choose(filter(keys(game.villages), value[0] = loc[0] and game.villages[value].owner != game.current_player), value[1])
		",

		score_spell: "def(class game game, map play_info, class card card, [[int]] targets) card.ai_score(game, targets)",

		score_play: "def(class game game, map play_info, class card card, [[int]] targets) if(card.creature and size(targets) = 1, score_summons(game, play_info, card, targets[0]), score_spell(game, play_info, card, targets))",

		calculate_card_play: "def(class game game, map play_info, class card card, [[int]] current_targets=[]) -> class bot.CardPlay|null
		  if(targets = [], null,
			if(targets = null, construct('bot.CardPlay', {
					card: card,
					targets: current_targets,
					score: score_play(game, play_info, card, current_targets),
					game: game,
				}),
				calculate_card_play(game, play_info, card, current_targets + [best_target])
			  where best_target = choose(targets, score_play(game, play_info, card, current_targets + [value]))
			))
		  where targets = card.possible_targets(game, game.nplayer, current_targets)
		",

		get_best_play: "def(class game game) -> class bot.CardPlay|null
		 if(plays,
		 if(best_combo and size(best_combo) >= 1,
			plays[best_combo[0]] + {discards: filter(map(player.hand, if(value in best_combo, null, index)), value != null)}, null)
		  where best_combo = choose(combinations, fold(map(value, decimal<- plays[value].score), a+b))
		  where player = game.players[game.nplayer]
		  where combinations = playable_combinations(game, plays)
		 )
		  where plays = calculate_plays(game, play_info)
		  where play_info = calculate_play_info(game)",

		calculate_plays: "def(class game game, map play_info, [class card]|null hand=null)
		           ->{class card -> class bot.CardPlay}|null
		    fold(filter(map(playable_cards(game, hand), if(info, {(value): info}, null) where info = calculate_card_play(game, play_info, value)), value != null), a+b asserting a and b)",

		calculate_play_info: "def(class game game) ->map {}",

		playable_combinations: "def(class game game, map plays_map, [class card] play=[], int existing_cost=0) -> [[class card]]
		   map(candidates, play + [value]) + fold(map(candidates, playable_combinations(game, plays_map, play + [value], existing_cost + player.calculate_cost(value))), a+b)
		   where candidates = [class card]<- filter(player.hand[starting_index:],
		    (not (value in play)) and
		    (player.resources + size(player.hand) - (size(play)+1+existing_cost)) >= player.calculate_cost(value) and
			plays_map[value] != null and
			value.possible_targets(game, game.nplayer, []) != [])
		   where starting_index = if(play = [], 0, index(player.hand, play[size(play)-1])+1)
		   where player = game.players[game.nplayer]
		",

		playable_cards: "def(class game game, [class card]|null hand) ->[class card]
		  filter(player_hand,
		   player.resources + (size(player_hand)-1) >=
		   player.actual_cost(value.school, value.cost, value.loyalty_cost) and
		   (value.is_response or (not game.in_response_phase)) and
		   value.possible_targets(game, game.nplayer, []) != [])
		        where player_hand = if(hand != null, hand, player.hand)
		        where player = game.players[game.nplayer]",

		//utilities
		lane_has_neutral_towers: "def(class game game, int nlane) find(game.creatures, value.loc[0] = nlane and value.controller = -1) != null",

		lane_has_neutral_glyphs: "def(class game game, int nlane) find(map(filter(game.villages, key[0] = nlane), value), value.owner = -1)",

		lane_has_enemy_glyphs: "def(class game game, int nlane) find(map(filter(game.villages, key[0] = nlane), value), value.owner != -1 and value.owner != game.nplayer)",

		lane_has_my_glyphs: "def(class game game, int nlane) find(map(filter(game.villages, key[0] = nlane), value), value.owner = game.nplayer)",

		lane_empty: "def(class game game, int nlane) find(game.creatures, value.loc[0] = nlane) = null",
		enemy_creatures_in_lane: "def(class game game, int nlane) ->[class creature] filter(game.creatures, value.loc[0] = nlane and value.controller != -1 and value.controller != game.current_player_index)",
		friendly_creatures_in_lane: "def(class game game, int nlane) ->[class creature] filter(game.creatures, value.loc[0] = nlane and value.controller = game.current_player_index)",
		enemy_constructs_in_lane: "def(class game game, int nlane) filter(game.constructs, value.loc[0] = nlane and value.controller != -1 and value.controller != game.current_player_index)",
		friendly_constructs_in_lane: "def(class game game, int nlane) filter(game.constructs, value.loc[0] = nlane and value.controller = game.current_player_index)",

		is_phase_my_combat: "def(class game game) ->bool
		  game.precombat_phase > 0 and
		  (game.nplayer = game.current_player_index)",

		is_phase_their_combat: "def(class game game) ->bool
		  game.precombat_phase > 0 and
		  (game.nplayer != game.current_player_index)",

		is_phase_my_before_combat: "def(class game game) ->bool
		  (not game.in_response_phase) and (not game.done_movement)",

		is_phase_my_after_combat: "def(class game game) ->bool
		  (not game.in_response_phase) and game.done_movement and
		  game.nplayer = game.current_player_index",

		is_in_response_to_their_spell: "def(class game game) ->bool
		  game.stack != []",

		request_updates: "def(object bot) -> commands
		  add(bot.script, [{
			session_id: session_id,
			send: {
				type: 'request_updates'
			}
		  }])
		",

		handle_message: "def(map message, object bot)
			if(message.type = 'game',
			   handle_game_message(message, bot),
			   request_updates(bot)

			)
		",

		handle_game_message: "def(class message.game message, object bot) [
		  if(message.state.players[message.state.nplayer].deck_submitted = false asserting message.state.players | message,
			[
			debug('BOT SUBMIT DECK: ' + deck),
			//submit our deck to the server.
			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'submit_deck',
					deck: deck,
				}
			}])
			],

			if(choice and choice.player_index = message.state.nplayer,
			send_moves(message, bot, [{
				type: 'make_choice',
				choice: 0,
			}]),

			if(message.state.nplayer = message.state.current_player,
				handle_game_message_internal(message, bot),
				request_updates(bot)

			)) where choice = message.state.current_choice)
		]",

		handle_game_message_internal: "def(class message.game message, object bot)
		    if(summons and summons.score > 0 and (not should_wait(message.state, summons)),
				  send_moves(message, bot,
					[
						{
							type: 'discard',
							indexes: discard_indexes
						},
						
						{
							type: 'play_card',
							index: final_index asserting final_index >= 0 | [final_index, hand_index, discard_indexes, size(player.hand)],
							player_index: message.state.nplayer,
							targets: summons.targets,
						} where final_index = hand_index - count(discard_indexes, value < hand_index)
					]
				where discard_indexes = (summons.discards asserting not (hand_index in summons.discards))
				where hand_index = (index(player.hand, summons.card) asserting find(player.hand, summons.card) | summons)
				  ),
				  end_turn(message, bot))
				where summons = get_best_play(message.state)
				where player = message.state.players[message.state.nplayer],
		",

		should_wait: "def(class game game, class bot.CardPlay best_play) ->bool
		  if(is_phase_my_after_combat(game), false, choose_to_wait(game, class card<- best_play.card))
		",

		choose_to_wait: "def(class game game, class card card) ->bool
		  false
		",

		end_turn: "def(class message.game message, object bot) send_moves(message, bot, [{type: 'end_turn', keep: []}])",

		send_moves: "def(class message.game message, object bot, [map] moves) [
				  debug('XX send moves: ' + moves),
				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'moves',
						state_id: message.state_id,
						moves: moves
					}
				  }])
		]",

		deck: "get_document('data/ai-deck.cfg')"
	},

	classes: {
		CardPlay: {
			card: { type: 'class card' },
			targets: { type: '[[int]]' },
			score: { type: 'int' },
			discards: { type: '[int]', default: [] },
			game: { type: 'class game' },
		}
	},
}
