{
	constructor: "[
		if(doc, add(me.creatures,
			map(doc, construct('creature', (map<- value) + {summon_id: 10+index})))
		) where doc = get_document('data/starting-creatures.cfg', ['null_on_failure']),
	   add(me.creatures, map(
	     map([1,2,3,4,5],
	       {
			  name: 'Guard Tower',
			  summoning_time: 0,
			  controller: -1,
			  attack: if(value = 1, 2, 1),
			  range: 2,
			  abilities: ['Fortification'],
			  life: if(value = 1, 4, 3),
			  is_building: true,
			  image_num: 6,
			  loc: village_locs[value],
			  summon_id: 1 + index,

			  settings: if(value = 1, '{ spoils: 4 }', '{ spoils: 2 }'),

			  rules: 'Spoils for destroying: ' + if(value = 1, 4, 2) + ' cards',

			  on_die: q(def(class game game) ->commands
			    map(game.players, if(index in victors, value.draw_cards(game, int<- settings.spoils)))
			    where victors = map(me.hit_by_this_turn(game), if(target, target.controller, null) where target = game.creature_by_summon_id(value))),
		   }), construct('creature', value))),
	   set(me.villages,
	       fold(map(village_locs,
		            {(value): {owner: -1,
					           level: [0,0,0,1,2,1,0,0,0][value[1]]}}), a+b))
	  ]
	      where village_locs =
		    fold(map(range(5), [loc, [loc[0], 8 - loc[1]]]
		         where loc = [[2,4], [0,3], [4,3], [2,1], [3,2]][value]), a + b)
	",

	properties: {
		nplayer: { variable: true, default: 0, type: 'int' },
		players: { variable: true, type: '[class player]' },
		current_player: "int <- current_player_index", // deprecated due to poor naming
		current_player_index: "int <- if(current_choice != null, current_choice.player_index, (nturn + precombat_phase + size(stack))%size(players))",
		player_obj: "class player <- players[current_player_index]",
		opponent_obj: "class player <- players[next_player_index]",
		next_player_index: "(current_player_index+1)%size(players)",
		next_player: "(current_player_index+1)%size(players)",

		player_init: "def(class player player) if(player.player_index = 0, player.begin_turn(me))",

		current_choice: { variable: true, default: null, type: 'class choice|null' },

		creature_summon_id: { type: 'int', default: 100, access: 'private' },
		nturn: { type: 'int', default: 0 },

		turn: "int <- nturn",
		precombat_phase: { variable: true, default: 0 },
		response_played: { variable: true, default: false },
		done_movement: { variable: true, default: false },

		stack: { variable: true, default: [], type: "[class message.play_card_base]" },
		stack_id: { variable: true, default: 1 },

		in_response_phase: "precombat_phase or stack",

		log_message: "def(string msg) add(me.log, [msg])",
		log: { default: [], type: '[string]' },

		creatures: { variable: true, default: [], type: "[class creature]" },
		creatures_and_avatars: "[class creature] <- creatures + map(players, value.creature_avatar)",
		permanents: { get: "creatures + constructs", type: "[class creature]" },
		permanents_and_avatars: { get: "creatures + constructs + map(players, value.creature_avatar)", type: "[class creature]" },

		constructs: { variable: true, default: [], type: "[class creature]" },

		//dead creatures, keyed by summon_id.
		graveyard: { variable: true, default: {}, type: "{int -> class creature}" },

		villages: { variable: true, default: {}, type: "{Loc -> map}" },

		capture: "def(Loc loc, int owner) ->commands [
		  if(me.villages[loc] != null,
		    [set(me.villages[loc].owner, owner),
			 ]),
		  if(construct and (construct.controller not in [owner, -1]),
		    set(construct.destroyed, true))
		      where construct = construct_at_loc(loc)
		]",

		rows: { variable: true, default: 6},
		columns: { variable: true, default: 9},

		animation_hints: { variable: true, type: '[class animation.hint]', default: [] },
		animation_hints_id: { variable: true, type: 'int', default: 1 },
		
		winner: "if(count(players, value.life > 0) = 1, find(players, value.life > 0), null)",
		winner_index: "if(count(players, value.life > 0) = 1,
		   if(players[0].life > 0, 0, if(players[1].life > 0, 1, -1)), null)",

		process_moves: "def([class message] moves)
		  map(moves, bind_command(process_game_move, value))
		",

		process_game_move: "overload(
		  def(class message.debug msg)        process_debug(msg),
		  def(class message.make_choice msg)  make_choice(msg),
		  def(class message.discard msg)      discard_cards(msg),
		  def(class message.play_card msg)    play_card(msg),
		  def(class message.play_ability msg) play_ability(msg),
		  def(class message.end_turn msg)     end_turn(msg),
		  def(class message.movement msg)     movement(msg)
		)",

		process_debug: "def(class message.debug info) [
			log_message('PROCESS DEBUG MESSAGE'),
			if(info.exe, if(result, result, log_message('failed to eval debug expression')) where result = eval(info.exe))
		]",

		discard_cards: "def(class message.discard info) players[current_player].discard_cards(info.indexes)",

		resolve_ability: "def(class message.play_ability info) [
		if(info.ability_obj.targets_valid(me, creature, info.targets), [
			debug('resolve ability'),
			info.ability_obj.on_play(me, creature, info),
			state_based_actions(),
			if(info.stack_id, add(me.animation_hints, [construct('animation.hint', {
				type: 'resolve',
				stack_id: info.stack_id,
			})]))
		],
		if(info.stack_id, add(me.animation_hints, [construct('animation.hint', {
			type: 'fizzle',
			stack_id: info.stack_id,
		})]))
		)
		]
		asserting info.ability_obj
		where creature = permanent_by_summon_id_or_die(info.creature)
		",

		play_ability: "def(class message.play_ability info) [
		if(creature and ability and
		   ((not ability.exhausts_creature) or (not creature.is_exhausted)), ([
		  player.spend(ability.school, ability.cost, ability.loyalty_cost),
		  if(ability.exhausts_creature, creature.set_exhausted()),

		  //resolve_ability(play_info)
		  add(me.stack_id, 1),
		  (add(me.stack, [play_info])
		    where play_info = info + {
				ability_obj: ability,
				stack_id: stack_id,
		    }),

		  add(me.animation_hints, [construct('animation.play_card_hint', {
			type: 'play_ability',
			card: ability,
			player: current_player,
			stack_id: stack_id,
			targets: [creature.loc] + info.targets
		  })]),
		  state_based_actions(),
		  set(me.response_played, true)
		] asserting player.can_afford(ability.school, ability.cost, ability.loyalty_cost),
		  (not in_response_phase) or ability.is_response),
		  if(creature and ability,
		     ability.targets_valid(me, creature, info.targets))
		 )
		  where ability = if(creature, find(creature.activated_abilities, value.name = info.ability))
		  where creature = find(permanents, value.summon_id = info.creature)
		  where player = players[current_player]
		]",

		set_current_choice: "def(map info)
			set(me.current_choice, construct('choice', info + if(info.player_index = null, {player_index: current_player}, {})))
		",

		make_choice: "def(class message.make_choice info) if(current_choice, [
			set(me.current_choice, null),
			bind_command(current_choice.card.on_play, me, current_choice.info + {choices: (list<- current_choice.info.choices or []) + [info.choice]})
			  asserting current_choice.card,
		])",

		resolve_card: "def(class message.play_card info) ->commands [
			if(not info.card.creature,
			   players[info.player_index].discard_visible(info.card.name)),

			//check the targets are still valid, otherwise the spell fizzles.
			if(info.card.targets_valid(me, info.player_index, info.targets),
				[
				   bind_command(info.card.on_play, me, info),

					if(info.stack_id, add(me.animation_hints, [construct('animation.hint', {
						type: 'resolve',
						stack_id: info.stack_id,
					})]))
				],
				
				if(info.stack_id, add(me.animation_hints, [construct('animation.hint', {
					type: 'fizzle',
					stack_id: info.stack_id,
				})]))
			),

			state_based_actions(),
		] asserting info.card",

		play_card: "def(class message.play_card info) ([
		  log_message(player.name + ' plays ' + player.hand[info.index].name),
		  debug('CARD PLAY: ' + player.hand[info.index].name + ' in phase ' + if(not done_movement, 'pre movement', if(precombat_phase, 'pre combat', 'post movement')) + if(in_response_phase, ' in response', '')),
		  player.spend(player.hand[info.index].school,
		               player.hand[info.index].cost,
					   player.hand[info.index].loyalty_cost),
		  set(player.hand, filter(player.hand, index != info.index)),
		  player.hand[info.index].record_animation(me, info, stack_id),

		  if(player.hand[info.index].plays_on_stack,
			 [
		     	add(me.stack, [play_info + {stack_id: stack_id}]),
				add(me.stack_id, 1),
			 ],
		     resolve_card(play_info)) where play_info = info + {card: player.hand[info.index], player_index: current_player},

		  set(me.response_played, true),
		  player.level_up(player.hand[info.index].school)
		  ]
		  asserting info.index >= 0 and info.index < size(player.hand),
		            player.can_afford(player.hand[info.index].school,
					                  player.hand[info.index].cost,
									  player.hand[info.index].loyalty_cost),
					(not in_response_phase) or player.hand[info.index].is_response,
					player.hand[info.index].targets_valid(me, current_player, info.targets)
				| [info.index, map(player.hand, value.name), in_response_phase])
		  where player = players[current_player]",

		set_creature_summoning_id: "def(class creature new_creature) ->commands [
			set(new_creature.summon_id, creature_summon_id),
			add(me.creature_summon_id, 1),
		]",

		summon_creature: "def(class creature new_creature) ->commands [
		  bind_command(set_creature_summoning_id, new_creature),
		  add(me.creatures, [new_creature]),
		  
		  bind_command(new_creature.handle_summoning, me),
		  state_based_actions(),
		  bind_command(new_creature.exhaust_on_summon, me),

	    ] asserting (not new_creature.is_construct)",

		summon_construct: "def(class creature new_construct) ->commands [
		  bind_command(set_creature_summoning_id, new_construct),
		  add(me.constructs, [new_construct]),
		  
		  bind_command(new_construct.handle_summoning, me),
		  state_based_actions(),
		  bind_command(new_construct.exhaust_on_summon, me),

		] asserting new_construct.is_construct",

		return_from_graveyard: "def(class creature creature)
		if(me.graveyard[creature.summon_id], [
			set(me.graveyard, remove_from_map(me.graveyard, creature.summon_id)),
			add(me.creatures, [creature]) asserting (not (creature in me.creatures))
		])",

		return_from_graveyard_to_hand: "def(class creature creature)
		if(target and target.card_name and target.controller >= 0 and target.controller < size(players), [
			set(me.graveyard, remove_from_map(me.graveyard, creature.summon_id)),
			add(me.players[creature.controller].hand, [target.card_name])
			
		]) where target = graveyard[creature.summon_id]",


		remove_static_effects: "def() map(me.players, value.remove_static_effects()) + map(me.permanents_and_avatars, value.remove_static_effects())",
		apply_static_effects: "def() map(me.permanents_and_avatars, value.apply_static_abilities(me) asserting value.apply_static_abilities != null | [value,index])",
		state_based_actions_internal: "def() [
		    set(me.creatures, new_creatures),
			set(me.constructs, new_constructs),
			map(me.creatures, if(not value.alive, add(me.graveyard, {value.summon_id: value}))),
			[ if(construct.card_name != null,
			     me.players[construct.controller].discard_visible(construct.card_name)) |
			  construct <- constructs,
			  construct.controller >= 0,
			  not construct.alive ],

			map(me.permanents, if(not value.alive, [
			  value.fire_events_on_death(me),
			  bind_command(value.fire_event, 'on_die', [me])
			])),
		 if(new_creatures != me.creatures,
		    bind_command(state_based_actions)
		   )
		]
				 
			where new_creatures = filter(me.creatures, value.alive)
			where new_constructs = filter(me.constructs, value.alive)
				 ",

		state_based_actions: "def() ->commands
		 [
		   bind_command(remove_static_effects),
		   bind_command(apply_static_effects),
		   bind_command(state_based_actions_internal),
		 ]
		",

		do_moves: "def() [
		   set(me.done_movement, true),
		   map(creatures, set(value.spaces_moved_this_turn, 0)),
		   map(filter(creatures, value.controller = current_player and not ('Exhausted' in value.status_effects)),
		       bind_command(value.do_move, me)),
		   map(filter(creatures, value.controller = current_player and not ('Exhausted' in value.status_effects)),
		       bind_command(value.fire_event, 'on_move', [me])
		 )]",


		do_first_strike_attacks: "def()
		   map(filter(creatures, ('First Strike' in value.abilities) and not ('Exhausted' in value.status_effects)),
		       bind_command(value.do_attack, me)
		      )",
		do_attacks: "def()
		   map(filter(creatures, (not ('First Strike' in value.abilities)) and not ('Exhausted' in value.status_effects)),
		       bind_command(value.do_attack, me)
		      )",

		do_trampling: "def() if(find(creatures, ('Trampling' in value.status_effects)),
		  map(filter(creatures, ('Trampling' in value.status_effects)),
		  [
		    bind_command(value.do_trample_move, me),

		  
		  bind_command(do_first_strike_attacks),
		  bind_command(do_attacks),
		  bind_command(cleanup_trampling),
		]))",

		cleanup_trampling: "def() map(me.creatures, set(value.status_effects, filter(value.status_effects, value != 'Trampling')))",
		
		do_endzone: "def() [
		  map(filter(creatures, is_loc_in_endzone(value.loc, value.controller)), [value.fire_event('on_reach_endzone', [me])]),
		  set(me.creatures, filter(creatures, not is_loc_in_endzone(value.loc, value.controller))),
		  [add(me.graveyard, {(creature.summon_id): creature}) | creature <- creatures, is_loc_in_endzone(creature.loc, creature.controller)],
		]",

		fire_creature_event: "def(string event_name, list args=[]) ->commands
			map(permanents_and_avatars, value.fire_event(event_name, [me] + args))
		",

		do_begin_turn: "def() map(permanents_and_avatars, value.begin_turn(me))",
		do_end_turn: "def() map(permanents_and_avatars, value.end_turn(me))",

		// any creatures in the graveyard have cards dis-assocated with them,
		// and those cards moved to their owner's discard pile.
		do_cleanup_graveyard: "def() [
			map(me.graveyard, if(value.card_name, [
				players[value.controller].discard_visible(value.card_name),
				set(value.card_name, '')
			]))
		]
		",

		resolve: "overload(
		  def(class message.play_ability item) resolve_ability(item),
		  def(class message.play_card item)    resolve_card(item)
		)",

		end_turn: "def(null|class message.end_turn info=null)
		  if(stack != [], [
			set(me.stack, stack[0:size(stack)-1]),
			bind_command(me.resolve, stack.last),
		   ],
		   if(not done_movement, movement(info),
		   if(precombat_phase, if((response_played or precombat_phase = 1) and players[(current_player+1)%size(players)].has_possible_response(me),
				    [add(me.precombat_phase, 1), set(me.response_played, false)],
				    [set(me.precombat_phase, 0), combat(info)]),
		   [
		   set(me.animation_hints, []),
		   add(me.animation_hints_id, 1),

		   state_based_actions(),

		   bind_command(do_end_turn),
		   bind_command(do_cleanup_graveyard),

		   players[nturn%size(players)].end_turn(me, if(info, info.keep, [])),
		   state_based_actions(),

		   log_message(players[next_player].name + ', Turn ' + ((me.nturn+1)/size(players)+1)),
			   
		   add(me.nturn, 1),
		   set(me.done_movement, false),
		   set(me.precombat_phase, 0),
		   set(me.response_played, false),
		   players[(nturn+1)%size(players)].begin_turn(me),
		   map(me.permanents, if(value.controller = next_player, value.increment_summoning)),
		   bind_command(do_begin_turn),
		   ])))",

		movement: "def(null|class message info=null)
		   if(not done_movement, [
			 bind_command(do_moves),
		     state_based_actions(),
			 bind_command(do_endzone),
		     state_based_actions(),

			 if(players[next_player].has_possible_response(me),
				[
			      add(me.precombat_phase, 1),
			      set(me.response_played, false)
				],
			 if(players[(next_player+1)%size(players)].has_possible_response(me),
				[
			      add(me.precombat_phase, 2),
			      set(me.response_played, false)
				],

				[
				  set(me.precombat_phase, 0),
			      set(me.response_played, false),

				  bind_command(combat, info),

				  if(info != null and info._class = 'message.end_turn',
					//the player asked to end the turn, not just do movement
					//and there was no response, so end turn.
					bind_command(end_turn, info),
				   )
				])
			  )
		   ])
		",

		combat: "def(null|class message info) [

		   //first strike combat
		   if(find(creatures, 'First Strike' in value.abilities),
			[
			  bind_command(do_first_strike_attacks),
		      state_based_actions()
			]),
		   
		   //regular combat.
		   bind_command(do_attacks),

		   state_based_actions(),

		   bind_command(do_trampling),
		   state_based_actions(),
		   bind_command(do_endzone),
		]
		",

		locs_adjacent: "def(Loc a, Loc b)
		  a[0] = b[0] and abs(a[1] - b[1]) = 1 or  //same row
		  abs(a[0] - b[0]) = 1  and (a[1] = b[1] or //one row apart
		        abs(a[1] - b[1]) = 1 and
				  ((a[0]%2 = 0 and a[1] = b[1]+1) or 
				   (a[0]%2 = 1 and a[1] = b[1]-1)))",

		all_locs: "[[row,col] | row <- range(rows), col <- range(columns)]",

		is_loc_on_board: "def(Loc loc) loc[0] >= 0 and loc[0] < rows and
		                           loc[1] >= 0 and loc[1] < columns",
		is_loc_in_endzone: "def(Loc loc, int controller) loc[0] >= 0 and loc[0] < rows and
		                         (controller = 0 and loc[1] = columns or
								  controller = 1 and loc[1] = -1)",
		construct_at_loc: "def(Loc loc) -> class creature|null
		   find(constructs, value.loc = loc)",
		creature_at_loc: "def(Loc loc) -> class creature|null
		   find(creatures, value.loc = loc)",

		creature_at_loc_or_die: "def(Loc loc) -> class creature
		   result asserting result | loc
		   where result = creature_at_loc(loc)",
		construct_at_loc_or_die: "def(Loc loc) -> class creature
		   result asserting result | loc
		   where result = construct_at_loc(loc)",

		creature_by_summon_id: "def(int id) -> class creature|null find(creatures, value.summon_id = id) or graveyard[id]",
		creature_by_summon_id_or_die: "def(int id) -> class creature result asserting result where result = find(creatures, value.summon_id = id) or graveyard[id]",
		permanent_by_summon_id: "def(int id) -> class creature|null find(permanents, value.summon_id = id) or graveyard[id]",
		permanent_by_summon_id_or_die: "def(int id) -> class creature result asserting result where result = find(permanents, value.summon_id = id) or graveyard[id]",
	},

	test: [
		{ command: "set(vars.game, construct('game', {players: [construct('player', {hand: []})]}))",
		  assert: "vars.game.rows = 6 and vars.game.columns = 9" }
	]
}
