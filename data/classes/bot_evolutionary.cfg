{
	bases: ["bot"],

	constructor: "set(me.rules, file_backed_map(args.rules, def() 1d2000 - 1000,
	   {deck: default_deck})) asserting args.rules",

	properties: {
	score_summons: "def(class game game, class card card, [int] loc) ->int
	  rule('summon ' + card.name) +
	  rule('summon ' + if(is_lane_empty, 'lane empty', 'lane not empty')) +

	  fold(map(friendly_constructs_in_lane(game, lane), rule('summon ' + card.name + ' in lane with friendly construct ' + value.name)), a+b) +
	  fold(map(enemy_constructs_in_lane(game, lane), rule('summon ' + card.name + ' in lane with enemy construct ' + value.name)), a+b) +
	  fold(map(enemy_creatures_in_lane(game, lane),
	        rule('summon ' + card.name + ' vs ' + value.name) +
			if(find(friendly_creatures_in_lane(game, lane), value.loc[1] > context.value.loc[1] = null) = null,
			rule('summon ' + card.name + ' vs unblocked ' + value.name) +
			rule('summon ' + card.name + ' vs unblocked on tile ' + value.tiles_from_start), 0)
		   ), a+b) +
	  fold(map(friendly_creatures_in_lane(game, lane), rule('summon ' + card.name + ' allied with ' + value.name)), a+b) +
	  if(lane_has_neutral_towers(game, lane), rule('summon ' + card.name + ' against neutral') + rule('summon against neutral'), 0) +
	  if(lane_has_neutral_glyphs(game, lane), rule('summon ' + card.name + ' capture glyphs') + rule('summon capture glyphs'), 0) +
	  if(lane_has_enemy_glyphs(game, lane), rule('summon ' + card.name + ' capture enemy glyphs') + rule('summon capture enemy glyphs'), 0)

	  
	where is_lane_empty = lane_empty(game, lane)
	where lane = loc[0]",

	spell_targets_loc: "overload(
	  def(class message.play_card msg, [int] loc) ->bool
	    count(msg.targets, loc) > 0,
	  def(class message msg) ->bool false
	)",

	spell_name: "overload(
	  def(class message.play_card msg) ->string|null
	    if(card, card.name) where card = msg.card,
	  def(class message msg) ->string|null null
	)",

	score_spell: "def(class game game, class card card, [[int]] targets) ->int
		rule('cast ' + card.name) +
		if(size(targets) = 0, 0, fold([
			if(target_creature = null, 0,
			   if(target_creature.controller = game.current_player_index,
				  rule('cast ' + card.name + ' on friend') +
				  rule('cast ' + card.name + ' on friend ' + target_creature.name) +
				  if(game.stack and spell_targets_loc(game.stack[size(game.stack)-1], target_creature.loc),
				  rule('cast ' + card.name + ' on friend targeted by enemy spell') +
				  rule('cast ' + card.name + ' on friend targeted by ' + spell_name(game.stack[size(game.stack)-1])), 0) ,

				  rule('cast ' + card.name + ' on enemy') +
				  rule('cast ' + card.name + ' on enemy ' + target_creature.name) +
				  if(game.stack and spell_targets_loc(game.stack[size(game.stack)-1], target_creature.loc),
				  rule('cast ' + card.name + ' on enemy targeted by enemy spell') +
				  rule('cast ' + card.name + ' on enemy targeted by ' + spell_name(game.stack[size(game.stack)-1])), 0)
				  )
			   
			)
		], a+b) where target_creature = game.creature_at_loc(targets[0])
			
		)

		+ fold(map(card.ai_patterns(game, targets), rule(card.name + ' ' + value)), a+b)
	",

	choose_to_wait: "def(class game game, class card card) ->bool
	(
		rule('wait to play') +
		rule('wait to play ' + card.name) +
		if(card.creature_object, if('Haste' in card.creature_object.abilities,
				rule('Wait to play haste creature'),
				rule('Wait to play non-haste creature')), 0) +
		if(game.in_response_phase, rule('wait to play ' + card.name + ' in response'),
		   fold(map(game.player_obj.hand, rule('wait with card ' + value.name)), a+b))
	) > 0
	",
	
	deck: "[string]<- rules['deck']",

	default_deck: "[string]<-
		  ['Goblin King']*2 +
		  ['Wolf Rider']*3 +
		  ['Goblin Grenadier']*3 +
		  ['Goblin']*3 +
		  ['Goblin Sapper']*2 +
		  ['Wolf']*2 +
		  ['Green Adder']*2 +
		  [q(Nature's Blessing)]*3 +
		  ['Primal Rage']*3
	",

	rule: "def(string name) ->int  int<- rules[name]",

	rules: { variable: true, type: "object" },
	}
}
